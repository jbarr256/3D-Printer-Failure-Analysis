{
  "version": 3,
  "sources": ["../../@irojs/iro-core/src/color.ts", "../../@irojs/iro-core/src/slider.ts", "../../@irojs/iro-core/src/wheel.ts", "../../@irojs/iro-core/src/box.ts", "../../@irojs/iro-core/src/util.ts", "../../@irojs/iro-core/src/css.ts", "../../@irojs/iro-core/src/colorPickerOptions.ts"],
  "sourcesContent": ["// Some regular expressions for rgb() and hsl() Colors are borrowed from tinyColor\n// https://github.com/bgrins/TinyColor\n// Kelvin temperature math borrowed from Neil Barlett's implementation\n// from https://github.com/neilbartlett/color-temperature\n\n// https://www.w3.org/TR/css3-values/#integers\nconst CSS_INTEGER = '[-\\\\+]?\\\\d+%?';\n// http://www.w3.org/TR/css3-values/#number-value\nconst CSS_NUMBER = '[-\\\\+]?\\\\d*\\\\.\\\\d+%?';\n// Allow positive/negative integer/number. Don't capture the either/or, just the entire outcome\nconst CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')';\n\n// Parse function params\n// Parens and commas are optional, and this also allows for whitespace between numbers\nconst PERMISSIVE_MATCH_3 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?';\nconst PERMISSIVE_MATCH_4 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?';\n\n// Regex patterns for functional color strings\nconst REGEX_FUNCTIONAL_RGB = new RegExp('rgb' + PERMISSIVE_MATCH_3);\nconst REGEX_FUNCTIONAL_RGBA = new RegExp('rgba' + PERMISSIVE_MATCH_4);\nconst REGEX_FUNCTIONAL_HSL = new RegExp('hsl' + PERMISSIVE_MATCH_3);\nconst REGEX_FUNCTIONAL_HSLA = new RegExp('hsla' + PERMISSIVE_MATCH_4);\n\n// Color string parsing regex\nconst HEX_START = '^(?:#?|0x?)';\nconst HEX_INT_SINGLE = '([0-9a-fA-F]{1})';\nconst HEX_INT_DOUBLE = '([0-9a-fA-F]{2})';\nconst REGEX_HEX_3 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nconst REGEX_HEX_4 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nconst REGEX_HEX_6 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');\nconst REGEX_HEX_8 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');\n\n// Kelvin temperature bounds\nconst KELVIN_MIN = 2000;\nconst KELVIN_MAX = 40000;\n\n// Math shorthands\nconst { log, round, floor } = Math;\n\n/**\n * @desc Clamp a number between a min and max value\n * @param num - input value\n * @param min - min allowed value\n * @param max - max allowed value\n */\nfunction clamp(num: number, min: number, max: number): number {\n  return Math.min(Math.max(num, min), max)\n}\n\n/**\n * @desc Parse a css unit string - either regular int or a percentage number\n * @param str - css unit string\n * @param max - max unit value, used for calculating percentages\n */\nfunction parseUnit(str: string, max: number): number {\n  const isPercentage = str.indexOf('%') > -1;\n  const num = parseFloat(str);\n  return isPercentage ? (max / 100) * num : num;\n}\n\n/**\n * @desc Parse hex str to an int\n * @param str - hex string to parse\n */\nfunction parseHexInt(str: string): number {\n  return parseInt(str, 16);\n}\n\n/**\n * @desc Convert nunber into to 2-digit hex\n * @param int - number to convert\n */\nfunction intToHex(int: number): string {\n  return int.toString(16).padStart(2, '0');\n}\n\nexport interface ColorChanges {\n  h: boolean;\n  s: boolean;\n  v: boolean;\n  a: boolean;\n}\n\n// all hsv color channels are optional by design\nexport interface HsvColor {\n  h?: number;\n  s?: number;\n  v?: number;\n  a?: number;\n}\n\nexport interface RgbColor {\n  r: number;\n  g: number;\n  b: number;\n  a?: number;\n}\n\nexport interface HslColor {\n  h: number;\n  s: number;\n  l: number;\n  a?: number;\n}\n\nexport interface KelvinColor {\n  kelvin: number;\n}\n\nexport type IroColorValue = IroColor | HsvColor | RgbColor | HslColor | KelvinColor | string;\n\nexport class IroColor {\n  // internal color value storage\n  private $: HsvColor;\n  private onChange: Function;\n  private initialValue: HsvColor;\n\n  public index: number;\n\n  /**\n    * @constructor Color object\n    * @param value - initial color value\n  */\n  constructor(value?: IroColorValue, onChange?: Function) {\n    // The default Color value\n    this.$ = {h: 0, s: 0, v: 0, a: 1};\n    if (value) this.set(value);\n    // The watch callback function for this Color will be stored here\n    this.onChange = onChange;\n    this.initialValue = { ...this.$ }; // copy initial value\n  }\n\n  /**\n    * @desc Set the Color from any valid value\n    * @param value - new color value\n  */\n  public set(value: IroColorValue) {\n    if (typeof value === 'string') {\n      if (/^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(value as string)) {\n        this.hexString = value as string;\n      }\n      else if (/^rgba?/.test(value as string)) {\n        this.rgbString = value as string;\n      }\n      else if (/^hsla?/.test(value as string)) {\n        this.hslString = value as string;\n      }\n    }\n    else if (typeof value === 'object') {\n      if (value instanceof IroColor) {\n        this.hsva = value.hsva;\n      }\n      else if ('r' in value && 'g' in value && 'b' in value) {\n        this.rgb = value;\n      }\n      else if ('h' in value && 's' in value && 'v' in value) {\n        this.hsv = value;\n      }\n      else if ('h' in value && 's' in value && 'l' in value) {\n        this.hsl = value;\n      }\n      else if ('kelvin' in value) {\n        this.kelvin = value.kelvin;\n      }\n    }\n    else {\n      throw new Error('Invalid color value');\n    }\n  }\n\n  /**\n    * @desc Shortcut to set a specific channel value\n    * @param format - hsv | hsl | rgb\n    * @param channel - individual channel to set, for example if model = hsl, chanel = h | s | l\n    * @param value - new value for the channel\n  */\n  public setChannel(format: string, channel: string, value: number) {\n    this[format] = {...this[format], [channel]: value};\n  }\n\n  /**\n   * @desc Reset color back to its initial value\n   */\n  public reset() {\n    this.hsva = this.initialValue;\n  }\n\n  /**\n    * @desc make new Color instance with the same value as this one\n  */\n  public clone() {\n    return new IroColor(this);\n  }\n\n  /**\n   * @desc remove color onChange\n   */\n  public unbind() {\n    this.onChange = undefined;\n  }\n\n  /**\n    * @desc Convert hsv object to rgb\n    * @param hsv - hsv color object\n  */\n  public static hsvToRgb(hsv: HsvColor): RgbColor {\n    const h = hsv.h / 60;\n    const s = hsv.s / 100;\n    const v = hsv.v / 100;\n    const i = floor(h);\n    const f = h - i;\n    const p = v * (1 - s);\n    const q = v * (1 - f * s);\n    const t = v * (1 - (1 - f) * s);\n    const mod = i % 6;\n    const r = [v, q, p, p, t, v][mod];\n    const g = [t, v, v, q, p, p][mod];\n    const b = [p, p, t, v, v, q][mod];\n    return {\n      r: clamp(r * 255, 0, 255), \n      g: clamp(g * 255, 0, 255), \n      b: clamp(b * 255, 0, 255)\n    };\n  }\n\n  /**\n    * @desc Convert rgb object to hsv\n    * @param rgb - rgb object\n  */\n  public static rgbToHsv(rgb: RgbColor): HsvColor {\n    const r = rgb.r / 255;\n    const g = rgb.g / 255;\n    const b = rgb.b / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const delta = max - min;\n    let hue = 0;\n    let value = max;\n    let saturation = max === 0 ? 0 : delta / max;\n    switch (max) {\n      case min: \n        hue = 0; // achromatic\n        break;\n      case r: \n        hue = (g - b) / delta + (g < b ? 6 : 0);\n        break;\n      case g: \n        hue = (b - r) / delta + 2;\n        break;\n      case b:\n        hue = (r - g) / delta + 4;\n        break;\n    }\n    return {\n      h: (hue * 60) % 360,\n      s: clamp(saturation * 100, 0, 100),\n      v: clamp(value * 100, 0, 100)\n    }\n  }\n\n  /**\n    * @desc Convert hsv object to hsl\n    * @param hsv - hsv object\n  */\n  public static hsvToHsl(hsv: HsvColor): HslColor {\n    const s = hsv.s / 100;\n    const v = hsv.v / 100;\n    const l = (2 - s) * v;\n    const divisor = l <= 1 ? l : (2 - l);\n    // Avoid division by zero when lightness is close to zero\n    const saturation = divisor < 1e-9 ? 0 : (s * v) / divisor;\n    return {\n      h: hsv.h,\n      s: clamp(saturation * 100, 0, 100),\n      l: clamp(l * 50, 0, 100)\n    };\n  }\n\n  /**\n    * @desc Convert hsl object to hsv\n    * @param hsl - hsl object\n  */\n  public static hslToHsv(hsl: HslColor): HsvColor {\n    const l = hsl.l * 2;\n    const s = (hsl.s * ((l <= 100) ? l : 200 - l)) / 100;\n    // Avoid division by zero when l + s is near 0\n    const saturation = (l + s < 1e-9) ? 0 : (2 * s) / (l + s);\n    return {\n      h: hsl.h,\n      s: clamp(saturation * 100, 0, 100),\n      v: clamp((l + s) / 2, 0, 100)\n    };\n  }\n\n  /**\n    * @desc Convert a kelvin temperature to an approx, RGB value\n    * @param kelvin - kelvin temperature\n  */\n  public static kelvinToRgb(kelvin: number): RgbColor {\n    const temp = kelvin / 100;\n    let r, g, b;\n    if (temp < 66) {\n      r = 255\n      g = -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log(g)\n      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log(b)\n    } else {\n      r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log(r)\n      g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log(g)\n      b = 255\n    }\n    return {\n      r: clamp(floor(r), 0, 255),\n      g: clamp(floor(g), 0, 255),\n      b: clamp(floor(b), 0, 255)\n    };\n  }\n\n   /**\n    * @desc Convert an RGB color to an approximate kelvin temperature\n    * @param kelvin - kelvin temperature\n  */\n  public static rgbToKelvin(rgb: RgbColor): number {\n    const { r, g, b } = rgb;\n    const eps = 0.4;\n    let minTemp = KELVIN_MIN;\n    let maxTemp = KELVIN_MAX;\n    let temp;\n    while (maxTemp - minTemp > eps) {\n      temp = (maxTemp + minTemp) * 0.5;\n      const rgb = IroColor.kelvinToRgb(temp);\n      if ((rgb.b / rgb.r) >= (b / r)) {\n        maxTemp = temp;\n      } else {\n        minTemp = temp;\n      }\n    }\n    return temp;\n  }\n\n  public get hsv(): HsvColor {\n    // value is cloned to allow changes to be made to the values before passing them back\n    const value = this.$;\n    return {h: value.h, s: value.s, v: value.v};\n  }\n\n  public set hsv(newValue: HsvColor) {\n    const oldValue = this.$;\n\n    newValue = { ...oldValue, ...newValue };\n    // If this Color is being watched for changes we need to compare the new and old values to check the difference\n    // Otherwise we can just be lazy\n    if (this.onChange) {\n      // Compute changed values\n      let changes: ColorChanges = {\n        h: false,\n        v: false,\n        s: false,\n        a: false,\n      };\n\n      for (let key in oldValue) {\n        changes[key] = newValue[key] != oldValue[key]\n      };\n      // Update the old value\n      this.$ = newValue;\n      // If the value has changed, call hook callback\n      if (changes.h || changes.s || changes.v || changes.a) this.onChange(this, changes);\n    } else {\n      this.$ = newValue;\n    }\n  }\n\n  public get hsva(): HsvColor {\n    return {...this.$};\n  }\n\n  public set hsva(value: HsvColor) {\n    this.hsv = value;\n  }\n\n  public get hue(): number {\n    return this.$.h;\n  }\n\n  public set hue(value: number) {\n    this.hsv = { h: value };\n  }\n\n  public get saturation(): number {\n    return this.$.s;\n  }\n\n  public set saturation(value: number) {\n    this.hsv = { s: value };\n  }\n\n  public get value(): number {\n    return this.$.v;\n  }\n\n  public set value(value: number) {\n    this.hsv = { v: value };\n  }\n\n  public get alpha(): number {\n    return this.$.a;\n  }\n\n  public set alpha(value: number) {\n    this.hsv = { ...this.hsv, a: value };\n  }\n\n  public get kelvin(): number {\n    return IroColor.rgbToKelvin(this.rgb);\n  }\n\n  public set kelvin(value: number) {\n    this.rgb = IroColor.kelvinToRgb(value);\n  }\n\n  public get red(): number {\n    const rgb = this.rgb;\n    return rgb.r;\n  }\n\n  public set red(value: number) {\n    this.rgb = { ...this.rgb, r: value };\n  }\n\n  public get green(): number {\n    const rgb = this.rgb;\n    return rgb.g;\n  }\n\n  public set green(value: number) {\n    this.rgb = { ...this.rgb, g: value };\n  }\n\n  public get blue(): number {\n    const rgb = this.rgb;\n    return rgb.b;\n  }\n\n  public set blue(value: number) {\n    this.rgb = { ...this.rgb, b: value };\n  }\n\n  public get rgb(): RgbColor {\n    const {r, g, b} = IroColor.hsvToRgb(this.$);\n    return {\n      r: round(r),\n      g: round(g),\n      b: round(b),\n    };\n  }\n\n  public set rgb(value: RgbColor) {\n    this.hsv = {\n      ...IroColor.rgbToHsv(value), \n      a: (value.a === undefined) ? 1 : value.a\n    };\n  }\n\n  public get rgba(): RgbColor {\n    return { ...this.rgb, a: this.alpha };\n  }\n\n  public set rgba(value: RgbColor) {\n    this.rgb = value;\n  }\n\n  public get hsl(): HslColor {\n    const {h, s, l} = IroColor.hsvToHsl(this.$);\n    return {\n      h: round(h),\n      s: round(s),\n      l: round(l),\n    };\n  }\n\n  public set hsl(value: HslColor) {\n    this.hsv = {\n      ...IroColor.hslToHsv(value), \n      a: (value.a === undefined) ? 1 : value.a\n    };\n  }\n\n  public get hsla(): HslColor {\n    return { ...this.hsl, a: this.alpha };\n  }\n\n  public set hsla(value: HslColor) {\n    this.hsl = value;\n  }\n\n  public get rgbString(): string {\n    const rgb = this.rgb;\n    return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;\n  }\n\n  public set rgbString(value: string) {\n    let match;\n    let r, g, b, a = 1;\n    if (match = REGEX_FUNCTIONAL_RGB.exec(value)) {\n      r = parseUnit(match[1], 255);\n      g = parseUnit(match[2], 255);\n      b = parseUnit(match[3], 255);\n    }\n    else if (match = REGEX_FUNCTIONAL_RGBA.exec(value)) {\n      r = parseUnit(match[1], 255);\n      g = parseUnit(match[2], 255);\n      b = parseUnit(match[3], 255);\n      a = parseUnit(match[4], 1);\n    }\n    if (match) {\n      this.rgb = {r, g, b, a};\n    } \n    else {\n      throw new Error('Invalid rgb string');\n    }\n  }\n\n  public get rgbaString(): string {\n    const rgba = this.rgba;\n    return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;\n  }\n\n  public set rgbaString(value: string) {\n    this.rgbString = value;\n  }\n\n  public get hexString(): string {\n    const rgb = this.rgb;\n    return `#${ intToHex(rgb.r) }${ intToHex(rgb.g) }${ intToHex(rgb.b) }`;\n  }\n\n  public set hexString(value: string) {\n    let match;\n    let r, g, b, a = 255;\n    if (match = REGEX_HEX_3.exec(value)) {\n      r = parseHexInt(match[1]) * 17;\n      g = parseHexInt(match[2]) * 17;\n      b = parseHexInt(match[3]) * 17;\n    }\n    else if (match = REGEX_HEX_4.exec(value)) {\n      r = parseHexInt(match[1]) * 17;\n      g = parseHexInt(match[2]) * 17;\n      b = parseHexInt(match[3]) * 17;\n      a = parseHexInt(match[4]) * 17;\n    }\n    else if (match = REGEX_HEX_6.exec(value)) {\n      r = parseHexInt(match[1]);\n      g = parseHexInt(match[2]);\n      b = parseHexInt(match[3]);\n    }\n    else if (match = REGEX_HEX_8.exec(value)) {\n      r = parseHexInt(match[1]);\n      g = parseHexInt(match[2]);\n      b = parseHexInt(match[3]);\n      a = parseHexInt(match[4]);\n    }\n    if (match) {\n      this.rgb = {r, g, b, a: a / 255};\n    }\n    else {\n      throw new Error('Invalid hex string');\n    }\n  }\n\n  public get hex8String(): string {\n    const rgba = this.rgba;\n    return `#${intToHex(rgba.r)}${intToHex(rgba.g)}${intToHex(rgba.b)}${intToHex(floor(rgba.a * 255))}`;\n  }\n\n  public set hex8String(value: string) {\n    this.hexString = value;\n  }\n\n  public get hslString(): string {\n    const hsl = this.hsl;\n    return `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;\n  }\n\n  public set hslString(value: string) {\n    let match;\n    let h, s, l, a = 1;\n    if (match = REGEX_FUNCTIONAL_HSL.exec(value)) {\n      h = parseUnit(match[1], 360);\n      s = parseUnit(match[2], 100);\n      l = parseUnit(match[3], 100);\n    }\n    else if (match = REGEX_FUNCTIONAL_HSLA.exec(value)) {\n      h = parseUnit(match[1], 360);\n      s = parseUnit(match[2], 100);\n      l = parseUnit(match[3], 100);\n      a = parseUnit(match[4], 1);\n    }\n    if (match) {\n      this.hsl = {h, s, l, a};\n    } \n    else {\n      throw new Error('Invalid hsl string');\n    }\n  }\n\n  public get hslaString(): string {\n    const hsla = this.hsla;\n    return `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;\n  }\n\n  public set hslaString(value: string) {\n    this.hslString = value;\n  }\n}", "import { IroColor } from './color';\nimport { CssGradientStops } from './css';\nimport { IroColorPickerOptions } from './colorPickerOptions';\n\nexport type SliderShape = 'bar' | 'circle' | '';\nexport type SliderType = 'red' | 'green' | 'blue' |'alpha' | 'hue' | 'saturation' | 'value' | 'kelvin' | '';\n\nexport interface SliderOptions extends IroColorPickerOptions {\n  color: IroColor;\n  sliderShape: SliderShape;\n  sliderType: SliderType;\n  minTemperature: number;\n  maxTemperature: number;\n}\n\nexport const sliderDefaultOptions = {\n  sliderShape: 'bar',\n  sliderType: 'value',\n  minTemperature: 2200,\n  maxTemperature: 11000\n}\n\n/**\n * @desc Get the CSS styles for the slider root\n * @param props - slider props\n */\nexport function getSliderStyles(props: Partial<SliderOptions>) {\n  return {\n    [props.layoutDirection === 'horizontal' ? 'marginLeft' : 'marginTop']: props.sliderMargin\n  }\n}\n\n/**\n * @desc Get the bounding dimensions of the slider\n * @param props - slider props\n */\nexport function getSliderDimensions(props: Partial<SliderOptions>) {\n  let { width, sliderSize: sliderSize, borderWidth, handleRadius, padding, sliderShape } = props;\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  // automatically calculate sliderSize if its not defined\n  sliderSize = sliderSize ?? padding * 2 + handleRadius * 2;\n  if (sliderShape === 'circle') {\n    return {\n      handleStart: props.padding + props.handleRadius,\n      handleRange: width - padding * 2 - handleRadius * 2,\n      width: width,\n      height: width,\n      cx: width / 2,\n      cy: width / 2,\n      radius: width / 2 - borderWidth / 2\n    }\n  } else {\n    return {\n      handleStart: sliderSize / 2,\n      handleRange: width - sliderSize,\n      radius: sliderSize / 2,\n      x: 0,\n      y: 0,\n      width: ishorizontal ? sliderSize : width,\n      height: ishorizontal ? width : sliderSize,\n    }\n  }\n}\n\n/**\n * @desc Get the current slider value for a given color, as a percentage\n * @param props - slider props\n * @param color\n */\nexport function getCurrentSliderValue(props: Partial<SliderOptions>, color: IroColor) {\n  const hsva = color.hsva;\n  const rgb = color.rgb;\n\n  switch (props.sliderType) {\n    case 'red':\n      return rgb.r / 2.55;\n    case 'green':\n      return rgb.g / 2.55;\n    case 'blue':\n      return rgb.b / 2.55;\n    case 'alpha':\n      return hsva.a * 100;\n    case 'kelvin':\n      const { minTemperature, maxTemperature } = props;\n      const temperatureRange = maxTemperature - minTemperature;\n      const percent = ((color.kelvin - minTemperature) / temperatureRange) * 100;\n      // clmap percentage\n      return Math.max(0, Math.min(percent, 100));\n    case 'hue':\n      return hsva.h /= 3.6;\n    case 'saturation':\n      return hsva.s;\n    case 'value':\n    default:\n      return hsva.v;\n  }\n}\n\n/**\n * @desc Get the current slider value from user input\n * @param props - slider props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getSliderValueFromInput(props: Partial<SliderOptions>, x: number, y: number) {\n  const { handleRange, handleStart } = getSliderDimensions(props);\n  let handlePos;\n  if (props.layoutDirection === 'horizontal') {\n    handlePos = -1 * y + handleRange + handleStart;\n  } else {\n    handlePos = x - handleStart;\n  }\n  // clamp handle position\n  handlePos = Math.max(Math.min(handlePos, handleRange), 0);\n  const percent = Math.round((100 / handleRange) * handlePos);\n  switch (props.sliderType) {\n    case 'kelvin':\n      const { minTemperature, maxTemperature } = props;\n      const temperatureRange = maxTemperature - minTemperature;\n      return minTemperature + temperatureRange * (percent / 100);\n    case 'alpha':\n      return percent / 100;\n    case 'hue':\n      return percent * 3.6;\n    case 'red':\n    case 'blue':\n    case 'green':\n      return percent * 2.55;\n    default:\n      return percent;\n  }\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - slider props\n * @param color\n */\nexport function getSliderHandlePosition(props: Partial<SliderOptions>, color: IroColor) {\n  const { width, height, handleRange, handleStart } = getSliderDimensions(props);\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  const sliderValue = getCurrentSliderValue(props, color);\n  const midPoint = ishorizontal ? width / 2 : height / 2;\n  let handlePos = handleStart + (sliderValue / 100) * handleRange;\n  if (ishorizontal) {\n    handlePos = -1 * handlePos + handleRange + handleStart * 2;\n  } \n  return {\n    x: ishorizontal ? midPoint : handlePos, \n    y: ishorizontal ? handlePos : midPoint\n  };\n}\n\n/**\n * @desc Get the gradient stops for a slider\n * @param props - slider props\n * @param color\n */\nexport function getSliderGradient(props: Partial<SliderOptions>, color: IroColor): CssGradientStops {\n  const hsv = color.hsv;\n  const rgb = color.rgb;\n\n  switch (props.sliderType) {\n    case 'red':\n      return [\n        [0, `rgb(${ 0 },${ rgb.g },${ rgb.b })`],\n        [100, `rgb(${ 255 },${ rgb.g },${ rgb.b })`],\n      ];\n    case 'green':\n      return [\n        [0, `rgb(${ rgb.r },${ 0 },${ rgb.b })`],\n        [100, `rgb(${ rgb.r },${ 255 },${ rgb.b })`],\n      ];\n    case 'blue':\n      return [\n        [0, `rgb(${ rgb.r },${ rgb.g },${ 0 })`],\n        [100, `rgb(${ rgb.r },${ rgb.g },${ 255 })`],\n      ];\n    case 'alpha':\n      return [\n        [0, `rgba(${ rgb.r },${ rgb.g },${ rgb.b },0)`],\n        [100, `rgb(${ rgb.r },${ rgb.g },${ rgb.b })`],\n      ];\n    case 'kelvin':\n      const stops = [];\n      const min = props.minTemperature;\n      const max = props.maxTemperature;\n      const numStops = 8;\n      const range = max - min;\n      for (let kelvin = min, stop = 0; kelvin < max; kelvin += range / numStops, stop += 1) {\n        const { r, g, b } = IroColor.kelvinToRgb(kelvin);\n        stops.push([ 100 / numStops * stop, `rgb(${r},${g},${b})` ]);\n      }\n      return stops;\n    case 'hue':\n      return [\n        [0,      '#f00'],\n        [16.666, '#ff0'],\n        [33.333, '#0f0'],\n        [50,     '#0ff'],\n        [66.666, '#00f'],\n        [83.333, '#f0f'],\n        [100,    '#f00'],\n      ];\n    case 'saturation':\n      const noSat = IroColor.hsvToHsl({h: hsv.h, s: 0, v: hsv.v});\n      const fullSat = IroColor.hsvToHsl({h: hsv.h, s: 100, v: hsv.v});\n      return [\n        [0, `hsl(${noSat.h},${noSat.s}%,${noSat.l}%)`],\n        [100, `hsl(${fullSat.h},${fullSat.s}%,${fullSat.l}%)`]\n      ];\n    case 'value':\n    default:\n      const hsl = IroColor.hsvToHsl({h: hsv.h, s: hsv.s, v: 100});\n      return [\n        [0, '#000'],\n        [100, `hsl(${hsl.h},${hsl.s}%,${hsl.l}%)`]\n      ];\n  }\n}\n\n/**\n * @desc Get the gradient coords for a slider\n * @param props - slider props\n */\nexport function getSliderGradientCoords(props: Partial<SliderOptions>) {\n  const ishorizontal = props.layoutDirection === 'horizontal';\n  return {\n    x1: '0%',\n    y1: ishorizontal ? '100%' : '0%',\n    x2: ishorizontal ? '0%' : '100%',\n    y2: '0%'\n  }\n}", "import { IroColorPickerOptions } from './colorPickerOptions';\nimport { IroColor, IroColorValue } from './color';\n\nexport interface WheelProps extends IroColorPickerOptions {\n  color: IroColor;\n}\n\nconst TAU = Math.PI * 2;\n\n// javascript's modulo operator doesn't produce positive numbers with negative input\n// https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\nconst mod = (a: number, n: number) => (a % n + n) % n;\n\n// distance between points (x, y) and (0, 0)\nconst dist = (x: number, y: number) => Math.sqrt(x * x + y * y);\n\n/**\n * @param props - wheel props\n * @internal\n */\nfunction getHandleRange(props: Partial<WheelProps>) {\n  return props.width / 2 - props.padding - props.handleRadius - props.borderWidth;\n}\n\n/**\n * Returns true if point (x, y) lands inside the wheel\n * @param props - wheel props\n * @param x \n * @param y \n */\nexport function isInputInsideWheel(props: Partial<WheelProps>, x: number, y: number) {\n  const { cx, cy } = getWheelDimensions(props);\n  const r = props.width / 2;\n  return dist(cx - x, cy - y) < r;\n}\n\n/**\n * @desc Get the point as the center of the wheel\n * @param props - wheel props\n */\nexport function getWheelDimensions(props: Partial<WheelProps>) {\n  const r = props.width / 2;\n  return {\n    width: props.width,\n    radius: r - props.borderWidth,\n    cx: r,\n    cy: r\n  };\n}\n\n/**\n * @desc Translate an angle according to wheelAngle and wheelDirection\n * @param props - wheel props\n * @param angle - input angle\n */\nexport function translateWheelAngle(props: Partial<WheelProps>, angle: number, invert?: boolean) {\n  const wheelAngle = props.wheelAngle;\n  const wheelDirection = props.wheelDirection\n  // inverted and clockwisee\n  if (invert && wheelDirection === 'clockwise')\n    angle = wheelAngle + angle;\n  // clockwise (input handling)\n  else if (wheelDirection === 'clockwise')\n    angle = (360 - wheelAngle) + angle;\n  // inverted and anticlockwise\n  else if (invert && wheelDirection === 'anticlockwise')\n    angle = (wheelAngle + 180) - angle;\n  // anticlockwise (input handling)\n  else if (wheelDirection === 'anticlockwise')\n    angle = wheelAngle - angle;\n  return mod(angle, 360);\n}\n\n/**\n * @desc Get the current handle position for a given color\n * @param props - wheel props\n * @param color\n */\nexport function getWheelHandlePosition(props: Partial<WheelProps>, color: IroColor) {\n  const hsv = color.hsv;\n  const { cx, cy } = getWheelDimensions(props);\n  const handleRange = getHandleRange(props);\n  const handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (TAU / 360);\n  const handleDist = (hsv.s / 100) * handleRange;\n  const direction = props.wheelDirection === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + handleDist * Math.cos(handleAngle) * direction,\n    y: cy + handleDist * Math.sin(handleAngle) * direction,\n  }\n}\n\n/**\n * @desc Get the current wheel value from user input\n * @param props - wheel props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getWheelValueFromInput(props: Partial<WheelProps>, x: number, y: number) {\n  const { cx, cy } = getWheelDimensions(props);\n  const handleRange = getHandleRange(props);\n  x = cx - x;\n  y = cy - y;\n  // Calculate the hue by converting the angle to radians\n  const hue = translateWheelAngle(props, Math.atan2(-y, -x) * (360 / TAU));\n  // Find the point's distance from the center of the wheel\n  // This is used to show the saturation level\n  const handleDist = Math.min(dist(x, y), handleRange);\n  return {\n    h: Math.round(hue),\n    s: Math.round((100 / handleRange) * handleDist)\n  };\n}", "import { IroColor } from './color';\nimport { CssGradientStops } from './css';\nimport { IroColorPickerOptions } from './colorPickerOptions';\n\nexport interface BoxOptions extends IroColorPickerOptions {\n  color: IroColor;\n}\n\n/**\n * @desc Get the CSS styles for the box root element\n * @param props - box props\n */\nexport function getBoxStyles(props: Partial<BoxOptions>) {\n  return {\n    [props.layoutDirection === 'horizontal' ? 'marginLeft' : 'marginTop']: props.sliderMargin\n  }\n}\n\n/**\n * @desc Get the bounding dimensions of the box\n * @param props - box props\n */\nexport function getBoxDimensions(props: Partial<BoxOptions>) {\n  const { width, boxHeight, padding, handleRadius } = props;\n  return {\n    width: width,\n    height: boxHeight ?? width,\n    radius: padding + handleRadius\n  };\n}\n\n/**\n * @desc Get the current box value from user input\n * @param props - box props\n * @param x - global input x position\n * @param y - global input y position\n */\nexport function getBoxValueFromInput(props: Partial<BoxOptions>, x: number, y: number) {\n  const { width, height, radius } = getBoxDimensions(props);\n  const handleStart = radius;\n  const handleRangeX = width - radius * 2;\n  const handleRangeY = height - radius * 2;\n  const percentX = ((x - handleStart) / handleRangeX) * 100;\n  const percentY = ((y - handleStart) / handleRangeY) * 100;\n  return {\n    s: Math.max(0, Math.min(percentX, 100)),\n    v: Math.max(0, Math.min(100 - percentY, 100))\n  }\n}\n\n/**\n * @desc Get the current box handle position for a given color\n * @param props - box props\n * @param color\n */\nexport function getBoxHandlePosition(props: Partial<BoxOptions>, color: IroColor) {\n  const { width, height, radius } = getBoxDimensions(props);\n  const hsv = color.hsv;\n  const handleStart = radius;\n  const handleRangeX = width - radius * 2;\n  const handleRangeY = height - radius * 2;\n  return { \n    x: handleStart + (hsv.s / 100) * handleRangeX,\n    y: handleStart + (handleRangeY - ((hsv.v / 100) * handleRangeY))\n  }\n}\n\n/**\n * @desc Get the gradient stops for a box\n * @param props - box props\n * @param color\n */\nexport function getBoxGradients(props: Partial<BoxOptions>, color: IroColor): CssGradientStops[] {\n  const hue = color.hue;\n  return [\n    // saturation gradient\n    [\n      [0, '#fff'],\n      [100, `hsl(${hue},100%,50%)`],\n    ],\n    // lightness gradient\n    [\n      [0, 'rgba(0,0,0,0)'],\n      [100, '#000'],\n    ]\n  ];\n}", "import { IroColorPickerOptions } from './colorPickerOptions';\n\n// Keep track of html <base> elements for resolveSvgUrl\n// getElementsByTagName returns a live HTMLCollection, which stays in sync with the DOM tree\n// So it only needs to be called once\nlet BASE_ELEMENTS:  HTMLCollectionOf<HTMLBaseElement> | undefined;\n\n/**\n * @desc Resolve an SVG reference URL\n * This is required to work around how Safari and iOS webviews handle gradient URLS under certain conditions\n * If a page is using a client-side routing library which makes use of the HTML <base> tag, \n * Safari won't be able to render SVG gradients properly (as they are referenced by URLs)\n * More info on the problem: \n * https://stackoverflow.com/questions/19742805/angular-and-svg-filters/19753427#19753427\n * https://github.com/jaames/iro.js/issues/18\n * https://github.com/jaames/iro.js/issues/45\n * https://github.com/jaames/iro.js/pull/89\n * @props url - SVG reference URL\n */\nexport function resolveSvgUrl(url: string) {\n  if (!BASE_ELEMENTS)\n    BASE_ELEMENTS = document.getElementsByTagName('base');\n  // Sniff useragent string to check if the user is running Safari\n  const ua = window.navigator.userAgent;\n  const isSafari = /^((?!chrome|android).)*safari/i.test(ua);\n  const isIos = /iPhone|iPod|iPad/i.test(ua);\n  const location = window.location;\n  return ((isSafari || isIos) && (BASE_ELEMENTS.length > 0)) ? `${location.protocol}//${location.host}${location.pathname}${location.search}${url}` : url;\n}\n\n/**\n * @desc Get the path commands to draw an svg arc\n * @props cx - arc center point x\n * @props cy - arc center point y\n * @props radius - arc radius\n * @props startAngle - arc start angle\n * @props endAngle - arc end angle\n */\nexport function getSvgArcPath(cx: number, cy: number, radius: number, startAngle: number, endAngle: number) {\n  const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\n  startAngle *= Math.PI / 180;\n  endAngle *= Math.PI / 180;\n  const x1 = cx + radius * Math.cos(endAngle);\n  const y1 = cy + radius * Math.sin(endAngle);\n  const x2 = cx + radius * Math.cos(startAngle);\n  const y2 = cy + radius * Math.sin(startAngle);\n  return `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${x2} ${y2}`;\n}\n\n/**\n * @desc Given a specifc (x, y) position, test if there's a handle there and return its index, else return null.\n *       This is used for components like the box and wheel which support multiple handles when multicolor is active\n * @props x - point x position\n * @props y - point y position\n * @props handlePositions - array of {x, y} coords for each handle\n */\nexport function getHandleAtPoint(props: Partial<IroColorPickerOptions>, x: number, y: number, handlePositions: {x: number, y: number}[]) {\n  for (let i = 0; i < handlePositions.length; i++) {\n    const dX = handlePositions[i].x - x;\n    const dY = handlePositions[i].y - y;\n    const dist = Math.sqrt(dX * dX + dY * dY);\n    if (dist < props.handleRadius) {\n      return i;\n    }\n  }\n  return null;\n}", "import { IroColorPickerOptions } from './colorPickerOptions';\n\nexport function cssBorderStyles(props: IroColorPickerOptions) {\n  return {\n    boxSizing: 'border-box',\n    border: `${ props.borderWidth }px solid ${ props.borderColor }`\n  };\n}\n\nexport type CssGradientType = 'linear' | 'radial' | 'conical';\nexport type CssGradientStops = [number, number | string][];\n\nexport function cssGradient(type: CssGradientType, direction: string, stops: CssGradientStops) {\n  return `${ type }-gradient(${ direction }, ${ stops.map(([o, col]) => `${ col } ${ o }%`).join(',') })`;\n}\n\nexport function cssValue(value: number | string) {\n  if (typeof(value) === 'string')\n    return value;\n  return `${ value }px`;\n}", "import { IroColor, IroColorValue } from './color';\n\nexport type LayoutDirection = 'vertical' | 'horizontal' | '';\n\nexport type WheelDirection = 'clockwise' | 'anticlockwise' | '';\n\nexport interface IroColorPickerOptions {\n  width?: number;\n  height?: number;\n  color?: IroColorValue;\n  colors?: IroColorValue[];\n  padding?: number;\n  layoutDirection?: LayoutDirection;\n  borderColor?: string;\n  borderWidth?: number;\n  handleRadius?: number;\n  activeHandleRadius?: number;\n  handleSvg?: string;\n  handleProps?: any;\n  wheelLightness?: boolean;\n  wheelAngle?: number;\n  wheelDirection?: WheelDirection;\n  sliderSize?: number;\n  sliderMargin?: number;\n  boxHeight?: number;\n}\n\nexport const iroColorPickerOptionDefaults: IroColorPickerOptions = {\n  width: 300,\n  height: 300,\n  color: '#fff',\n  colors: [],\n  padding: 6,\n  layoutDirection: 'vertical',\n  borderColor: '#fff',\n  borderWidth: 0,\n  handleRadius: 8,\n  activeHandleRadius: null,\n  handleSvg: null,\n  handleProps: {x: 0, y: 0},\n  wheelLightness: true,\n  wheelAngle: 0,\n  wheelDirection: 'anticlockwise',\n  sliderSize: null,\n  sliderMargin: 12,\n  boxHeight: null\n}"],
  "mappings": "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",
  "names": ["CSS_INTEGER", "CSS_NUMBER", "CSS_UNIT", "PERMISSIVE_MATCH_3", "PERMISSIVE_MATCH_4", "REGEX_FUNCTIONAL_RGB", "RegExp", "REGEX_FUNCTIONAL_RGBA", "REGEX_FUNCTIONAL_HSL", "REGEX_FUNCTIONAL_HSLA", "HEX_START", "HEX_INT_SINGLE", "HEX_INT_DOUBLE", "REGEX_HEX_3", "REGEX_HEX_4", "REGEX_HEX_6", "REGEX_HEX_8", "KELVIN_MIN", "KELVIN_MAX", "log", "Math", "round", "floor", "clamp", "num", "min", "max", "parseUnit", "str", "isPercentage", "indexOf", "parseFloat", "parseHexInt", "parseInt", "intToHex", "int", "toString", "padStart", "IroColor", "value", "onChange", "$", "h", "s", "v", "a", "set", "initialValue", "test", "hexString", "rgbString", "hslString", "hsva", "rgb", "hsv", "hsl", "kelvin", "Error", "setChannel", "format", "channel", "reset", "clone", "unbind", "undefined", "hsvToRgb", "i", "f", "p", "q", "t", "mod", "r", "g", "b", "rgbToHsv", "delta", "hue", "saturation", "hsvToHsl", "l", "divisor", "hslToHsv", "kelvinToRgb", "temp", "rgbToKelvin", "eps", "minTemp", "maxTemp", "newValue", "oldValue", "changes", "key", "alpha", "match", "exec", "rgba", "hsla", "sliderDefaultOptions", "sliderShape", "sliderType", "minTemperature", "maxTemperature", "getSliderStyles", "props", "layoutDirection", "sliderMargin", "getSliderDimensions", "width", "sliderSize", "borderWidth", "handleRadius", "padding", "ishorizontal", "handleStart", "handleRange", "height", "cx", "cy", "radius", "x", "y", "getCurrentSliderValue", "color", "temperatureRange", "percent", "getSliderValueFromInput", "handlePos", "getSliderHandlePosition", "sliderValue", "midPoint", "getSliderGradient", "stops", "numStops", "range", "stop", "push", "noSat", "fullSat", "getSliderGradientCoords", "x1", "y1", "x2", "y2", "TAU", "PI", "n", "dist", "sqrt", "getHandleRange", "isInputInsideWheel", "getWheelDimensions", "translateWheelAngle", "angle", "invert", "wheelAngle", "wheelDirection", "getWheelHandlePosition", "handleAngle", "handleDist", "direction", "cos", "sin", "getWheelValueFromInput", "atan2", "getBoxStyles", "getBoxDimensions", "boxHeight", "getBoxValueFromInput", "handleRangeX", "handleRangeY", "percentX", "percentY", "getBoxHandlePosition", "getBoxGradients", "BASE_ELEMENTS", "resolveSvgUrl", "url", "document", "getElementsByTagName", "ua", "window", "navigator", "userAgent", "isSafari", "isIos", "location", "length", "protocol", "host", "pathname", "search", "getSvgArcPath", "startAngle", "endAngle", "largeArcFlag", "getHandleAtPoint", "handlePositions", "dX", "dY", "cssBorderStyles", "boxSizing", "border", "borderColor", "cssGradient", "type", "map", "o", "col", "join", "cssValue", "iroColorPickerOptionDefaults", "colors", "activeHandleRadius", "handleSvg", "handleProps", "wheelLightness"]
}
