import {
  Graph_default,
  linkSeriesData_default
} from "./chunk-E6MIXJ3L.js";
import {
  Base_default,
  FrameBuffer_default,
  Geo3DBuilder_default,
  Geometry_default,
  LabelsBuilder_default,
  Lines3D_default,
  Material_default,
  Matrix4_default,
  Mesh_default,
  OrbitControl_default,
  Orthographic_default,
  Pass_default,
  Plane_default,
  ProgressiveQuickSort_default,
  SceneHelper_default,
  Shader_default,
  Texture2D_default,
  Texture_default,
  Vector3_default,
  ViewGL_default,
  componentLightMixin_default,
  componentPostEffectMixin_default,
  componentShadingMixin_default,
  componentViewControlMixin_default,
  dynamicConvertMixin_default,
  geo3DCreator_default,
  geo3DModelMixin_default,
  getItemVisualColor,
  getItemVisualOpacity,
  getVisualColor,
  getVisualOpacity,
  glmatrix_default,
  graphicGL_default,
  install,
  lines3D_glsl_default,
  retrieve_default,
  trianglesSortMixin_default
} from "./chunk-7HYBQCTF.js";
import "./chunk-O7CTSDY3.js";
import {
  format_exports,
  helper_exports,
  number_exports,
  util_exports
} from "./chunk-FMOBVGFJ.js";
import "./chunk-WKGB3LPG.js";
import "./chunk-6A7JVADL.js";
import "./chunk-7CAD22Y3.js";
import {
  Chart_default,
  Model_default,
  SeriesData_default,
  Series_default,
  getCoordinateSystemDimensions,
  getLayoutRect
} from "./chunk-YDTUC6Z2.js";
import {
  applyTransform,
  brushSingle,
  color_exports,
  concatArray,
  containStroke,
  create2 as create,
  invert,
  requestAnimationFrame_default
} from "./chunk-ZEDOSNM2.js";
import "./chunk-NE6YQAF4.js";
import "./chunk-ROME4SDB.js";

// node_modules/echarts-gl/lib/chart/bar3D/cartesian3DLayout.js
var vec3 = glmatrix_default.vec3;
var isDimensionStacked = helper_exports.dataStack.isDimensionStacked;
function ifCrossZero(extent) {
  var min = extent[0];
  var max = extent[1];
  return !(min > 0 && max > 0 || min < 0 && max < 0);
}
function cartesian3DLayout(seriesModel, coordSys) {
  var data = seriesModel.getData();
  var barSize = seriesModel.get("barSize");
  if (barSize == null) {
    var size = coordSys.size;
    var barWidth;
    var barDepth;
    var xAxis = coordSys.getAxis("x");
    var yAxis = coordSys.getAxis("y");
    if (xAxis.type === "category") {
      barWidth = xAxis.getBandWidth() * 0.7;
    } else {
      barWidth = Math.round(size[0] / Math.sqrt(data.count())) * 0.6;
    }
    if (yAxis.type === "category") {
      barDepth = yAxis.getBandWidth() * 0.7;
    } else {
      barDepth = Math.round(size[1] / Math.sqrt(data.count())) * 0.6;
    }
    barSize = [barWidth, barDepth];
  } else if (!util_exports.isArray(barSize)) {
    barSize = [barSize, barSize];
  }
  var zAxisExtent = coordSys.getAxis("z").scale.getExtent();
  var ifZAxisCrossZero = ifCrossZero(zAxisExtent);
  var dims = ["x", "y", "z"].map(function(coordDimName) {
    return seriesModel.coordDimToDataDim(coordDimName)[0];
  });
  var isStacked = isDimensionStacked(data, dims[2]);
  var valueDim = isStacked ? data.getCalculationInfo("stackResultDimension") : dims[2];
  data.each(dims, function(x, y, z, idx) {
    var stackedValue = data.get(valueDim, idx);
    var baseValue = isStacked ? stackedValue - z : ifZAxisCrossZero ? 0 : zAxisExtent[0];
    var start = coordSys.dataToPoint([x, y, baseValue]);
    var end = coordSys.dataToPoint([x, y, stackedValue]);
    var height = vec3.dist(start, end);
    var dir = [0, end[1] < start[1] ? -1 : 1, 0];
    if (Math.abs(height) === 0) {
      height = 0.1;
    }
    var size2 = [barSize[0], height, barSize[1]];
    data.setItemLayout(idx, [start, dir, size2]);
  });
  data.setLayout("orient", [1, 0, 0]);
}
var cartesian3DLayout_default = cartesian3DLayout;

// node_modules/echarts-gl/lib/chart/bar3D/evaluateBarSparseness.js
function evaluateBarSparseness_default(data, dimX, dimY) {
  var xExtent = data.getDataExtent(dimX);
  var yExtent = data.getDataExtent(dimY);
  var xSpan = xExtent[1] - xExtent[0] || xExtent[0];
  var ySpan = yExtent[1] - yExtent[0] || yExtent[0];
  var dimSize = 50;
  var tmp = new Uint8Array(dimSize * dimSize);
  for (var i = 0; i < data.count(); i++) {
    var x = data.get(dimX, i);
    var y = data.get(dimY, i);
    var xIdx = Math.floor((x - xExtent[0]) / xSpan * (dimSize - 1));
    var yIdx = Math.floor((y - yExtent[0]) / ySpan * (dimSize - 1));
    var idx = yIdx * dimSize + xIdx;
    tmp[idx] = tmp[idx] || 1;
  }
  var filledCount = 0;
  for (var i = 0; i < tmp.length; i++) {
    if (tmp[i]) {
      filledCount++;
    }
  }
  return filledCount / tmp.length;
}

// node_modules/echarts-gl/lib/chart/bar3D/bar3DLayout.js
var vec32 = glmatrix_default.vec3;
var isDimensionStacked2 = helper_exports.dataStack.isDimensionStacked;
function globeLayout(seriesModel, coordSys) {
  var data = seriesModel.getData();
  var barMinHeight = seriesModel.get("minHeight") || 0;
  var barSize = seriesModel.get("barSize");
  var dims = ["lng", "lat", "alt"].map(function(coordDimName) {
    return seriesModel.coordDimToDataDim(coordDimName)[0];
  });
  if (barSize == null) {
    var perimeter = coordSys.radius * Math.PI;
    var fillRatio = evaluateBarSparseness_default(data, dims[0], dims[1]);
    barSize = [perimeter / Math.sqrt(data.count() / fillRatio), perimeter / Math.sqrt(data.count() / fillRatio)];
  } else if (!util_exports.isArray(barSize)) {
    barSize = [barSize, barSize];
  }
  var valueDim = getValueDimension(data, dims);
  data.each(dims, function(lng, lat, val, idx) {
    var stackedValue = data.get(valueDim.dimension, idx);
    var baseValue = valueDim.isStacked ? stackedValue - val : coordSys.altitudeAxis.scale.getExtent()[0];
    var height = Math.max(coordSys.altitudeAxis.dataToCoord(val), barMinHeight);
    var start = coordSys.dataToPoint([lng, lat, baseValue]);
    var end = coordSys.dataToPoint([lng, lat, stackedValue]);
    var dir = vec32.sub([], end, start);
    vec32.normalize(dir, dir);
    var size = [barSize[0], height, barSize[1]];
    data.setItemLayout(idx, [start, dir, size]);
  });
  data.setLayout("orient", Vector3_default.UP.array);
}
function geo3DLayout(seriesModel, coordSys) {
  var data = seriesModel.getData();
  var barSize = seriesModel.get("barSize");
  var barMinHeight = seriesModel.get("minHeight") || 0;
  var dims = ["lng", "lat", "alt"].map(function(coordDimName) {
    return seriesModel.coordDimToDataDim(coordDimName)[0];
  });
  if (barSize == null) {
    var size = Math.min(coordSys.size[0], coordSys.size[2]);
    var fillRatio = evaluateBarSparseness_default(data, dims[0], dims[1]);
    barSize = [size / Math.sqrt(data.count() / fillRatio), size / Math.sqrt(data.count() / fillRatio)];
  } else if (!util_exports.isArray(barSize)) {
    barSize = [barSize, barSize];
  }
  var dir = [0, 1, 0];
  var valueDim = getValueDimension(data, dims);
  data.each(dims, function(lng, lat, val, idx) {
    var stackedValue = data.get(valueDim.dimension, idx);
    var baseValue = valueDim.isStacked ? stackedValue - val : coordSys.altitudeAxis.scale.getExtent()[0];
    var height = Math.max(coordSys.altitudeAxis.dataToCoord(val), barMinHeight);
    var start = coordSys.dataToPoint([lng, lat, baseValue]);
    var size2 = [barSize[0], height, barSize[1]];
    data.setItemLayout(idx, [start, dir, size2]);
  });
  data.setLayout("orient", [1, 0, 0]);
}
function mapService3DLayout(seriesModel, coordSys) {
  var data = seriesModel.getData();
  var dimLng = seriesModel.coordDimToDataDim("lng")[0];
  var dimLat = seriesModel.coordDimToDataDim("lat")[0];
  var dimAlt = seriesModel.coordDimToDataDim("alt")[0];
  var barSize = seriesModel.get("barSize");
  var barMinHeight = seriesModel.get("minHeight") || 0;
  if (barSize == null) {
    var xExtent = data.getDataExtent(dimLng);
    var yExtent = data.getDataExtent(dimLat);
    var corner0 = coordSys.dataToPoint([xExtent[0], yExtent[0]]);
    var corner1 = coordSys.dataToPoint([xExtent[1], yExtent[1]]);
    var size = Math.min(Math.abs(corner0[0] - corner1[0]), Math.abs(corner0[1] - corner1[1])) || 1;
    var fillRatio = evaluateBarSparseness_default(data, dimLng, dimLat);
    barSize = [size / Math.sqrt(data.count() / fillRatio), size / Math.sqrt(data.count() / fillRatio)];
  } else {
    if (!util_exports.isArray(barSize)) {
      barSize = [barSize, barSize];
    }
    barSize[0] /= coordSys.getScale() / 16;
    barSize[1] /= coordSys.getScale() / 16;
  }
  var dir = [0, 0, 1];
  var dims = [dimLng, dimLat, dimAlt];
  var valueDim = getValueDimension(data, dims);
  data.each(dims, function(lng, lat, val, idx) {
    var stackedValue = data.get(valueDim.dimension, idx);
    var baseValue = valueDim.isStacked ? stackedValue - val : 0;
    var start = coordSys.dataToPoint([lng, lat, baseValue]);
    var end = coordSys.dataToPoint([lng, lat, stackedValue]);
    var height = Math.max(end[2] - start[2], barMinHeight);
    var size2 = [barSize[0], height, barSize[1]];
    data.setItemLayout(idx, [start, dir, size2]);
  });
  data.setLayout("orient", [1, 0, 0]);
}
function getValueDimension(data, dataDims) {
  var isStacked = isDimensionStacked2(data, dataDims[2]);
  return {
    dimension: isStacked ? data.getCalculationInfo("stackResultDimension") : dataDims[2],
    isStacked
  };
}
function registerBarLayout(registers) {
  registers.registerLayout(function(ecModel, api) {
    ecModel.eachSeriesByType("bar3D", function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var coordSysType = coordSys && coordSys.type;
      if (coordSysType === "globe") {
        globeLayout(seriesModel, coordSys);
      } else if (coordSysType === "cartesian3D") {
        cartesian3DLayout_default(seriesModel, coordSys);
      } else if (coordSysType === "geo3D") {
        geo3DLayout(seriesModel, coordSys);
      } else if (coordSysType === "mapbox3D" || coordSysType === "maptalks3D") {
        mapService3DLayout(seriesModel, coordSys);
      } else {
        if (true) {
          if (!coordSys) {
            throw new Error("bar3D doesn't have coordinate system.");
          } else {
            throw new Error("bar3D doesn't support coordinate system " + coordSys.type);
          }
        }
      }
    });
  });
}

// node_modules/echarts-gl/lib/util/format.js
var formatUtil = {};
formatUtil.getFormattedLabel = function(seriesModel, dataIndex, status, dataType, dimIndex) {
  status = status || "normal";
  var data = seriesModel.getData(dataType);
  var itemModel = data.getItemModel(dataIndex);
  var params = seriesModel.getDataParams(dataIndex, dataType);
  if (dimIndex != null && params.value instanceof Array) {
    params.value = params.value[dimIndex];
  }
  var formatter = itemModel.get(status === "normal" ? ["label", "formatter"] : ["emphasis", "label", "formatter"]);
  if (formatter == null) {
    formatter = itemModel.get(["label", "formatter"]);
  }
  var text;
  if (typeof formatter === "function") {
    params.status = status;
    text = formatter(params);
  } else if (typeof formatter === "string") {
    text = format_exports.formatTpl(formatter, params);
  }
  return text;
};
formatUtil.normalizeToArray = function(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
};
var format_default = formatUtil;

// node_modules/echarts-gl/lib/chart/common/formatTooltip.js
function otherDimToDataDim(data, otherDim) {
  var dataDim = [];
  util_exports.each(data.dimensions, function(dimName) {
    var dimItem = data.getDimensionInfo(dimName);
    var otherDims = dimItem.otherDims;
    var dimIndex = otherDims[otherDim];
    if (dimIndex != null && dimIndex !== false) {
      dataDim[dimIndex] = dimItem.name;
    }
  });
  return dataDim;
}
function formatTooltip_default(seriesModel, dataIndex, multipleSeries) {
  function formatArrayValue(value2) {
    var vertially = true;
    var result = [];
    var tooltipDims = otherDimToDataDim(data, "tooltip");
    tooltipDims.length ? util_exports.each(tooltipDims, function(dimIdx) {
      setEachItem(data.get(dimIdx, dataIndex), dimIdx);
    }) : util_exports.each(value2, setEachItem);
    function setEachItem(val, dimIdx) {
      var dimInfo = data.getDimensionInfo(dimIdx);
      if (!dimInfo || dimInfo.otherDims.tooltip === false) {
        return;
      }
      var dimType = dimInfo.type;
      var valStr = (vertially ? "- " + (dimInfo.tooltipName || dimInfo.name) + ": " : "") + (dimType === "ordinal" ? val + "" : dimType === "time" ? multipleSeries ? "" : format_exports.formatTime("yyyy/MM/dd hh:mm:ss", val) : format_exports.addCommas(val));
      valStr && result.push(format_exports.encodeHTML(valStr));
    }
    return (vertially ? "<br/>" : "") + result.join(vertially ? "<br/>" : ", ");
  }
  var data = seriesModel.getData();
  var value = seriesModel.getRawValue(dataIndex);
  var formattedValue = util_exports.isArray(value) ? formatArrayValue(value) : format_exports.encodeHTML(format_exports.addCommas(value));
  var name = data.getName(dataIndex);
  var color = getItemVisualColor(data, dataIndex);
  if (util_exports.isObject(color) && color.colorStops) {
    color = (color.colorStops[0] || {}).color;
  }
  color = color || "transparent";
  var colorEl = format_exports.getTooltipMarker(color);
  var seriesName = seriesModel.name;
  if (seriesName === "\0-") {
    seriesName = "";
  }
  seriesName = seriesName ? format_exports.encodeHTML(seriesName) + (!multipleSeries ? "<br/>" : ": ") : "";
  return !multipleSeries ? seriesName + colorEl + (name ? format_exports.encodeHTML(name) + ": " + formattedValue : formattedValue) : colorEl + seriesName + formattedValue;
}

// node_modules/echarts-gl/lib/chart/common/createList.js
function createList_default(seriesModel, dims, source) {
  source = source || seriesModel.getSource();
  var coordSysDimensions = dims || getCoordinateSystemDimensions(seriesModel.get("coordinateSystem")) || ["x", "y", "z"];
  var dimensions = helper_exports.createDimensions(source, {
    dimensionsDefine: source.dimensionsDefine || seriesModel.get("dimensions"),
    encodeDefine: source.encodeDefine || seriesModel.get("encode"),
    coordDimensions: coordSysDimensions.map(function(dim) {
      var axis3DModel = seriesModel.getReferringComponents(dim + "Axis3D").models[0];
      return {
        type: axis3DModel && axis3DModel.get("type") === "category" ? "ordinal" : "float",
        name: dim
        // Find stackable dimension. Which will represent value.
        // stackable: dim === 'z'
      };
    })
  });
  if (seriesModel.get("coordinateSystem") === "cartesian3D") {
    dimensions.forEach(function(dimInfo) {
      if (coordSysDimensions.indexOf(dimInfo.coordDim) >= 0) {
        var axis3DModel = seriesModel.getReferringComponents(dimInfo.coordDim + "Axis3D").models[0];
        if (axis3DModel && axis3DModel.get("type") === "category") {
          dimInfo.ordinalMeta = axis3DModel.getOrdinalMeta();
        }
      }
    });
  }
  var stackCalculationInfo = helper_exports.dataStack.enableDataStack(
    // Only support 'z' and `byIndex` now.
    seriesModel,
    dimensions,
    {
      byIndex: true,
      stackedCoordDimension: "z"
    }
  );
  var data = new SeriesData_default(dimensions, seriesModel);
  data.setCalculationInfo(stackCalculationInfo);
  data.initData(source);
  return data;
}

// node_modules/echarts-gl/lib/chart/bar3D/Bar3DSeries.js
var Bar3DSeries = Series_default.extend({
  type: "series.bar3D",
  dependencies: ["globe"],
  visualStyleAccessPathvisu: "itemStyle",
  getInitialData: function(option, ecModel) {
    return createList_default(this);
  },
  getFormattedLabel: function(dataIndex, status, dataType, dimIndex) {
    var text = format_default.getFormattedLabel(this, dataIndex, status, dataType, dimIndex);
    if (text == null) {
      text = this.getData().get("z", dataIndex);
    }
    return text;
  },
  formatTooltip: function(dataIndex) {
    return formatTooltip_default(this, dataIndex);
  },
  defaultOption: {
    coordinateSystem: "cartesian3D",
    globeIndex: 0,
    grid3DIndex: 0,
    zlevel: -10,
    // bevelSize, 0 has no bevel
    bevelSize: 0,
    // higher is smoother
    bevelSmoothness: 2,
    // Bar width and depth
    // barSize: [1, 1],
    // On grid plane when coordinateSystem is cartesian3D
    onGridPlane: "xy",
    // Shading of globe
    shading: "color",
    minHeight: 0,
    itemStyle: {
      opacity: 1
    },
    label: {
      show: false,
      distance: 2,
      textStyle: {
        fontSize: 14,
        color: "#000",
        backgroundColor: "rgba(255,255,255,0.7)",
        padding: 3,
        borderRadius: 3
      }
    },
    emphasis: {
      label: {
        show: true
      }
    },
    animationDurationUpdate: 500
  }
});
util_exports.merge(Bar3DSeries.prototype, componentShadingMixin_default);
var Bar3DSeries_default = Bar3DSeries;

// node_modules/echarts-gl/lib/util/geometry/Bars3DGeometry.js
var vec33 = glmatrix_default.vec3;
var mat3 = glmatrix_default.mat3;
var BarsGeometry = Geometry_default.extend(
  function() {
    return {
      attributes: {
        position: new Geometry_default.Attribute("position", "float", 3, "POSITION"),
        normal: new Geometry_default.Attribute("normal", "float", 3, "NORMAL"),
        color: new Geometry_default.Attribute("color", "float", 4, "COLOR"),
        prevPosition: new Geometry_default.Attribute("prevPosition", "float", 3),
        prevNormal: new Geometry_default.Attribute("prevNormal", "float", 3)
      },
      dynamic: true,
      enableNormal: false,
      bevelSize: 1,
      bevelSegments: 0,
      // Map from vertexIndex to dataIndex.
      _dataIndices: null,
      _vertexOffset: 0,
      _triangleOffset: 0
    };
  },
  /** @lends module:echarts-gl/chart/bars/BarsGeometry.prototype */
  {
    resetOffset: function() {
      this._vertexOffset = 0;
      this._triangleOffset = 0;
    },
    setBarCount: function(barCount) {
      var enableNormal = this.enableNormal;
      var vertexCount = this.getBarVertexCount() * barCount;
      var triangleCount = this.getBarTriangleCount() * barCount;
      if (this.vertexCount !== vertexCount) {
        this.attributes.position.init(vertexCount);
        if (enableNormal) {
          this.attributes.normal.init(vertexCount);
        } else {
          this.attributes.normal.value = null;
        }
        this.attributes.color.init(vertexCount);
      }
      if (this.triangleCount !== triangleCount) {
        this.indices = vertexCount > 65535 ? new Uint32Array(triangleCount * 3) : new Uint16Array(triangleCount * 3);
        this._dataIndices = new Uint32Array(vertexCount);
      }
    },
    getBarVertexCount: function() {
      var bevelSegments = this.bevelSize > 0 ? this.bevelSegments : 0;
      return bevelSegments > 0 ? this._getBevelBarVertexCount(bevelSegments) : this.enableNormal ? 24 : 8;
    },
    getBarTriangleCount: function() {
      var bevelSegments = this.bevelSize > 0 ? this.bevelSegments : 0;
      return bevelSegments > 0 ? this._getBevelBarTriangleCount(bevelSegments) : 12;
    },
    _getBevelBarVertexCount: function(bevelSegments) {
      return (bevelSegments + 1) * 4 * (bevelSegments + 1) * 2;
    },
    _getBevelBarTriangleCount: function(bevelSegments) {
      var widthSegments = bevelSegments * 4 + 3;
      var heightSegments = bevelSegments * 2 + 1;
      return (widthSegments + 1) * heightSegments * 2 + 4;
    },
    setColor: function(idx, color) {
      var vertexCount = this.getBarVertexCount();
      var start = vertexCount * idx;
      var end = vertexCount * (idx + 1);
      for (var i = start; i < end; i++) {
        this.attributes.color.set(i, color);
      }
      this.dirtyAttribute("color");
    },
    /**
     * Get dataIndex of vertex.
     * @param {number} vertexIndex
     */
    getDataIndexOfVertex: function(vertexIndex) {
      return this._dataIndices ? this._dataIndices[vertexIndex] : null;
    },
    /**
     * Add a bar
     * @param {Array.<number>} start
     * @param {Array.<number>} end
     * @param {Array.<number>} orient  right direction
     * @param {Array.<number>} size size on x and z
     * @param {Array.<number>} color
     */
    addBar: function() {
      var v3Create = vec33.create;
      var v3ScaleAndAdd = vec33.scaleAndAdd;
      var end = v3Create();
      var px = v3Create();
      var py = v3Create();
      var pz = v3Create();
      var nx = v3Create();
      var ny = v3Create();
      var nz = v3Create();
      var pts = [];
      var normals = [];
      for (var i = 0; i < 8; i++) {
        pts[i] = v3Create();
      }
      var cubeFaces4 = [
        // PX
        [0, 1, 5, 4],
        // NX
        [2, 3, 7, 6],
        // PY
        [4, 5, 6, 7],
        // NY
        [3, 2, 1, 0],
        // PZ
        [0, 4, 7, 3],
        // NZ
        [1, 2, 6, 5]
      ];
      var face4To3 = [0, 1, 2, 0, 2, 3];
      var cubeFaces3 = [];
      for (var i = 0; i < cubeFaces4.length; i++) {
        var face4 = cubeFaces4[i];
        for (var j = 0; j < 2; j++) {
          var face = [];
          for (var k = 0; k < 3; k++) {
            face.push(face4[face4To3[j * 3 + k]]);
          }
          cubeFaces3.push(face);
        }
      }
      return function(start, dir, leftDir, size, color, dataIndex) {
        var startVertex = this._vertexOffset;
        if (this.bevelSize > 0 && this.bevelSegments > 0) {
          this._addBevelBar(start, dir, leftDir, size, this.bevelSize, this.bevelSegments, color);
        } else {
          vec33.copy(py, dir);
          vec33.normalize(py, py);
          vec33.cross(pz, leftDir, py);
          vec33.normalize(pz, pz);
          vec33.cross(px, py, pz);
          vec33.normalize(pz, pz);
          vec33.negate(nx, px);
          vec33.negate(ny, py);
          vec33.negate(nz, pz);
          v3ScaleAndAdd(pts[0], start, px, size[0] / 2);
          v3ScaleAndAdd(pts[0], pts[0], pz, size[2] / 2);
          v3ScaleAndAdd(pts[1], start, px, size[0] / 2);
          v3ScaleAndAdd(pts[1], pts[1], nz, size[2] / 2);
          v3ScaleAndAdd(pts[2], start, nx, size[0] / 2);
          v3ScaleAndAdd(pts[2], pts[2], nz, size[2] / 2);
          v3ScaleAndAdd(pts[3], start, nx, size[0] / 2);
          v3ScaleAndAdd(pts[3], pts[3], pz, size[2] / 2);
          v3ScaleAndAdd(end, start, py, size[1]);
          v3ScaleAndAdd(pts[4], end, px, size[0] / 2);
          v3ScaleAndAdd(pts[4], pts[4], pz, size[2] / 2);
          v3ScaleAndAdd(pts[5], end, px, size[0] / 2);
          v3ScaleAndAdd(pts[5], pts[5], nz, size[2] / 2);
          v3ScaleAndAdd(pts[6], end, nx, size[0] / 2);
          v3ScaleAndAdd(pts[6], pts[6], nz, size[2] / 2);
          v3ScaleAndAdd(pts[7], end, nx, size[0] / 2);
          v3ScaleAndAdd(pts[7], pts[7], pz, size[2] / 2);
          var attributes = this.attributes;
          if (this.enableNormal) {
            normals[0] = px;
            normals[1] = nx;
            normals[2] = py;
            normals[3] = ny;
            normals[4] = pz;
            normals[5] = nz;
            var vertexOffset = this._vertexOffset;
            for (var i2 = 0; i2 < cubeFaces4.length; i2++) {
              var idx3 = this._triangleOffset * 3;
              for (var k2 = 0; k2 < 6; k2++) {
                this.indices[idx3++] = vertexOffset + face4To3[k2];
              }
              vertexOffset += 4;
              this._triangleOffset += 2;
            }
            for (var i2 = 0; i2 < cubeFaces4.length; i2++) {
              var normal2 = normals[i2];
              for (var k2 = 0; k2 < 4; k2++) {
                var idx = cubeFaces4[i2][k2];
                attributes.position.set(this._vertexOffset, pts[idx]);
                attributes.normal.set(this._vertexOffset, normal2);
                attributes.color.set(this._vertexOffset++, color);
              }
            }
          } else {
            for (var i2 = 0; i2 < cubeFaces3.length; i2++) {
              var idx3 = this._triangleOffset * 3;
              for (var k2 = 0; k2 < 3; k2++) {
                this.indices[idx3 + k2] = cubeFaces3[i2][k2] + this._vertexOffset;
              }
              this._triangleOffset++;
            }
            for (var i2 = 0; i2 < pts.length; i2++) {
              attributes.position.set(this._vertexOffset, pts[i2]);
              attributes.color.set(this._vertexOffset++, color);
            }
          }
        }
        var endVerex = this._vertexOffset;
        for (var i2 = startVertex; i2 < endVerex; i2++) {
          this._dataIndices[i2] = dataIndex;
        }
      };
    }(),
    /**
     * Add a bar with bevel
     * @param {Array.<number>} start
     * @param {Array.<number>} end
     * @param {Array.<number>} orient  right direction
     * @param {Array.<number>} size size on x and z
     * @param {number} bevelSize
     * @param {number} bevelSegments
     * @param {Array.<number>} color
     */
    _addBevelBar: function() {
      var px = vec33.create();
      var py = vec33.create();
      var pz = vec33.create();
      var rotateMat = mat3.create();
      var bevelStartSize = [];
      var xOffsets = [1, -1, -1, 1];
      var zOffsets = [1, 1, -1, -1];
      var yOffsets = [2, 0];
      return function(start, dir, leftDir, size, bevelSize, bevelSegments, color) {
        vec33.copy(py, dir);
        vec33.normalize(py, py);
        vec33.cross(pz, leftDir, py);
        vec33.normalize(pz, pz);
        vec33.cross(px, py, pz);
        vec33.normalize(pz, pz);
        rotateMat[0] = px[0];
        rotateMat[1] = px[1];
        rotateMat[2] = px[2];
        rotateMat[3] = py[0];
        rotateMat[4] = py[1];
        rotateMat[5] = py[2];
        rotateMat[6] = pz[0];
        rotateMat[7] = pz[1];
        rotateMat[8] = pz[2];
        bevelSize = Math.min(size[0], size[2]) / 2 * bevelSize;
        for (var i = 0; i < 3; i++) {
          bevelStartSize[i] = Math.max(size[i] - bevelSize * 2, 0);
        }
        var rx = (size[0] - bevelStartSize[0]) / 2;
        var ry = (size[1] - bevelStartSize[1]) / 2;
        var rz = (size[2] - bevelStartSize[2]) / 2;
        var pos = [];
        var normal2 = [];
        var vertexOffset = this._vertexOffset;
        var endIndices = [];
        for (var i = 0; i < 2; i++) {
          endIndices[i] = endIndices[i] = [];
          for (var m = 0; m <= bevelSegments; m++) {
            for (var j = 0; j < 4; j++) {
              if (m === 0 && i === 0 || i === 1 && m === bevelSegments) {
                endIndices[i].push(vertexOffset);
              }
              for (var n = 0; n <= bevelSegments; n++) {
                var phi = n / bevelSegments * Math.PI / 2 + Math.PI / 2 * j;
                var theta = m / bevelSegments * Math.PI / 2 + Math.PI / 2 * i;
                normal2[0] = rx * Math.cos(phi) * Math.sin(theta);
                normal2[1] = ry * Math.cos(theta);
                normal2[2] = rz * Math.sin(phi) * Math.sin(theta);
                pos[0] = normal2[0] + xOffsets[j] * bevelStartSize[0] / 2;
                pos[1] = normal2[1] + ry + yOffsets[i] * bevelStartSize[1] / 2;
                pos[2] = normal2[2] + zOffsets[j] * bevelStartSize[2] / 2;
                if (!(Math.abs(rx - ry) < 1e-6 && Math.abs(ry - rz) < 1e-6)) {
                  normal2[0] /= rx * rx;
                  normal2[1] /= ry * ry;
                  normal2[2] /= rz * rz;
                }
                vec33.normalize(normal2, normal2);
                vec33.transformMat3(pos, pos, rotateMat);
                vec33.transformMat3(normal2, normal2, rotateMat);
                vec33.add(pos, pos, start);
                this.attributes.position.set(vertexOffset, pos);
                if (this.enableNormal) {
                  this.attributes.normal.set(vertexOffset, normal2);
                }
                this.attributes.color.set(vertexOffset, color);
                vertexOffset++;
              }
            }
          }
        }
        var widthSegments = bevelSegments * 4 + 3;
        var heightSegments = bevelSegments * 2 + 1;
        var len = widthSegments + 1;
        for (var j = 0; j < heightSegments; j++) {
          for (var i = 0; i <= widthSegments; i++) {
            var i2 = j * len + i + this._vertexOffset;
            var i1 = j * len + (i + 1) % len + this._vertexOffset;
            var i4 = (j + 1) * len + (i + 1) % len + this._vertexOffset;
            var i3 = (j + 1) * len + i + this._vertexOffset;
            this.setTriangleIndices(this._triangleOffset++, [i4, i2, i1]);
            this.setTriangleIndices(this._triangleOffset++, [i4, i3, i2]);
          }
        }
        this.setTriangleIndices(this._triangleOffset++, [endIndices[0][0], endIndices[0][2], endIndices[0][1]]);
        this.setTriangleIndices(this._triangleOffset++, [endIndices[0][0], endIndices[0][3], endIndices[0][2]]);
        this.setTriangleIndices(this._triangleOffset++, [endIndices[1][0], endIndices[1][1], endIndices[1][2]]);
        this.setTriangleIndices(this._triangleOffset++, [endIndices[1][0], endIndices[1][2], endIndices[1][3]]);
        this._vertexOffset = vertexOffset;
      };
    }()
  }
);
util_exports.defaults(BarsGeometry.prototype, dynamicConvertMixin_default);
util_exports.defaults(BarsGeometry.prototype, trianglesSortMixin_default);
var Bars3DGeometry_default = BarsGeometry;

// node_modules/echarts-gl/lib/chart/bar3D/Bar3DView.js
var vec34 = glmatrix_default.vec3;
var Bar3DView_default = Chart_default.extend({
  type: "bar3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL_default.Node();
    this._api = api;
    this._labelsBuilder = new LabelsBuilder_default(256, 256, api);
    var self2 = this;
    this._labelsBuilder.getLabelPosition = function(dataIndex, position, distance) {
      if (self2._data) {
        var layout = self2._data.getItemLayout(dataIndex);
        var start = layout[0];
        var dir = layout[1];
        var height = layout[2][1];
        return vec34.scaleAndAdd([], start, dir, distance + height);
      } else {
        return [0, 0];
      }
    };
    this._labelsBuilder.getMesh().renderOrder = 100;
  },
  render: function(seriesModel, ecModel, api) {
    var tmp = this._prevBarMesh;
    this._prevBarMesh = this._barMesh;
    this._barMesh = tmp;
    if (!this._barMesh) {
      this._barMesh = new graphicGL_default.Mesh({
        geometry: new Bars3DGeometry_default(),
        shadowDepthMaterial: new graphicGL_default.Material({
          shader: new graphicGL_default.Shader(graphicGL_default.Shader.source("ecgl.sm.depth.vertex"), graphicGL_default.Shader.source("ecgl.sm.depth.fragment"))
        }),
        // Only cartesian3D enable culling
        // FIXME Performance
        culling: seriesModel.coordinateSystem.type === "cartesian3D",
        // Render after axes
        renderOrder: 10,
        // Render normal in normal pass
        renderNormal: true
      });
    }
    this.groupGL.remove(this._prevBarMesh);
    this.groupGL.add(this._barMesh);
    this.groupGL.add(this._labelsBuilder.getMesh());
    var coordSys = seriesModel.coordinateSystem;
    this._doRender(seriesModel, api);
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
      var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
      this._barMesh.material[methodName]("fragment", "SRGB_DECODE");
    }
    this._data = seriesModel.getData();
    this._labelsBuilder.updateData(this._data);
    this._labelsBuilder.updateLabels();
    this._updateAnimation(seriesModel);
  },
  _updateAnimation: function(seriesModel) {
    graphicGL_default.updateVertexAnimation([["prevPosition", "position"], ["prevNormal", "normal"]], this._prevBarMesh, this._barMesh, seriesModel);
  },
  _doRender: function(seriesModel, api) {
    var data = seriesModel.getData();
    var shading = seriesModel.get("shading");
    var enableNormal = shading !== "color";
    var self2 = this;
    var barMesh = this._barMesh;
    var shadingPrefix = "ecgl." + shading;
    if (!barMesh.material || barMesh.material.shader.name !== shadingPrefix) {
      barMesh.material = graphicGL_default.createMaterial(shadingPrefix, ["VERTEX_COLOR"]);
    }
    graphicGL_default.setMaterialFromModel(shading, barMesh.material, seriesModel, api);
    barMesh.geometry.enableNormal = enableNormal;
    barMesh.geometry.resetOffset();
    var bevelSize = seriesModel.get("bevelSize");
    var bevelSegments = seriesModel.get("bevelSmoothness");
    barMesh.geometry.bevelSegments = bevelSegments;
    barMesh.geometry.bevelSize = bevelSize;
    var colorArr = [];
    var vertexColors = new Float32Array(data.count() * 4);
    var colorOffset = 0;
    var barCount = 0;
    var hasTransparent = false;
    data.each(function(idx) {
      if (!data.hasValue(idx)) {
        return;
      }
      var color = getItemVisualColor(data, idx);
      var opacity = getItemVisualOpacity(data, idx);
      if (opacity == null) {
        opacity = 1;
      }
      graphicGL_default.parseColor(color, colorArr);
      colorArr[3] *= opacity;
      vertexColors[colorOffset++] = colorArr[0];
      vertexColors[colorOffset++] = colorArr[1];
      vertexColors[colorOffset++] = colorArr[2];
      vertexColors[colorOffset++] = colorArr[3];
      if (colorArr[3] > 0) {
        barCount++;
        if (colorArr[3] < 0.99) {
          hasTransparent = true;
        }
      }
    });
    barMesh.geometry.setBarCount(barCount);
    var orient = data.getLayout("orient");
    var barIndexOfData = this._barIndexOfData = new Int32Array(data.count());
    var barCount = 0;
    data.each(function(idx) {
      if (!data.hasValue(idx)) {
        barIndexOfData[idx] = -1;
        return;
      }
      var layout = data.getItemLayout(idx);
      var start = layout[0];
      var dir = layout[1];
      var size = layout[2];
      var idx4 = idx * 4;
      colorArr[0] = vertexColors[idx4++];
      colorArr[1] = vertexColors[idx4++];
      colorArr[2] = vertexColors[idx4++];
      colorArr[3] = vertexColors[idx4++];
      if (colorArr[3] > 0) {
        self2._barMesh.geometry.addBar(start, dir, orient, size, colorArr, idx);
        barIndexOfData[idx] = barCount++;
      }
    });
    barMesh.geometry.dirty();
    barMesh.geometry.updateBoundingBox();
    var material = barMesh.material;
    material.transparent = hasTransparent;
    material.depthMask = !hasTransparent;
    barMesh.geometry.sortTriangles = hasTransparent;
    this._initHandler(seriesModel, api);
  },
  _initHandler: function(seriesModel, api) {
    var data = seriesModel.getData();
    var barMesh = this._barMesh;
    var isCartesian3D = seriesModel.coordinateSystem.type === "cartesian3D";
    barMesh.seriesIndex = seriesModel.seriesIndex;
    var lastDataIndex = -1;
    barMesh.off("mousemove");
    barMesh.off("mouseout");
    barMesh.on("mousemove", function(e) {
      var dataIndex = barMesh.geometry.getDataIndexOfVertex(e.triangle[0]);
      if (dataIndex !== lastDataIndex) {
        this._downplay(lastDataIndex);
        this._highlight(dataIndex);
        this._labelsBuilder.updateLabels([dataIndex]);
        if (isCartesian3D) {
          api.dispatchAction({
            type: "grid3DShowAxisPointer",
            value: [data.get("x", dataIndex), data.get("y", dataIndex), data.get("z", dataIndex, true)]
          });
        }
      }
      lastDataIndex = dataIndex;
      barMesh.dataIndex = dataIndex;
    }, this);
    barMesh.on("mouseout", function(e) {
      this._downplay(lastDataIndex);
      this._labelsBuilder.updateLabels();
      lastDataIndex = -1;
      barMesh.dataIndex = -1;
      if (isCartesian3D) {
        api.dispatchAction({
          type: "grid3DHideAxisPointer"
        });
      }
    }, this);
  },
  _highlight: function(dataIndex) {
    var data = this._data;
    if (!data) {
      return;
    }
    var barIndex = this._barIndexOfData[dataIndex];
    if (barIndex < 0) {
      return;
    }
    var itemModel = data.getItemModel(dataIndex);
    var emphasisItemStyleModel = itemModel.getModel("emphasis.itemStyle");
    var emphasisColor = emphasisItemStyleModel.get("color");
    var emphasisOpacity = emphasisItemStyleModel.get("opacity");
    if (emphasisColor == null) {
      var color = getItemVisualColor(data, dataIndex);
      emphasisColor = color_exports.lift(color, -0.4);
    }
    if (emphasisOpacity == null) {
      emphasisOpacity = getItemVisualOpacity(data, dataIndex);
    }
    var colorArr = graphicGL_default.parseColor(emphasisColor);
    colorArr[3] *= emphasisOpacity;
    this._barMesh.geometry.setColor(barIndex, colorArr);
    this._api.getZr().refresh();
  },
  _downplay: function(dataIndex) {
    var data = this._data;
    if (!data) {
      return;
    }
    var barIndex = this._barIndexOfData[dataIndex];
    if (barIndex < 0) {
      return;
    }
    var color = getItemVisualColor(data, dataIndex);
    var opacity = getItemVisualOpacity(data, dataIndex);
    var colorArr = graphicGL_default.parseColor(color);
    colorArr[3] *= opacity;
    this._barMesh.geometry.setColor(barIndex, colorArr);
    this._api.getZr().refresh();
  },
  highlight: function(seriesModel, ecModel, api, payload) {
    this._toggleStatus("highlight", seriesModel, ecModel, api, payload);
  },
  downplay: function(seriesModel, ecModel, api, payload) {
    this._toggleStatus("downplay", seriesModel, ecModel, api, payload);
  },
  _toggleStatus: function(status, seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = retrieve_default.queryDataIndex(data, payload);
    var self2 = this;
    if (dataIndex != null) {
      util_exports.each(format_default.normalizeToArray(dataIndex), function(dataIdx) {
        status === "highlight" ? this._highlight(dataIdx) : this._downplay(dataIdx);
      }, this);
    } else {
      data.each(function(dataIdx) {
        status === "highlight" ? self2._highlight(dataIdx) : self2._downplay(dataIdx);
      });
    }
  },
  remove: function() {
    this.groupGL.removeAll();
  },
  dispose: function() {
    this._labelsBuilder.dispose();
    this.groupGL.removeAll();
  }
});

// node_modules/echarts-gl/lib/chart/bar3D/install.js
function install2(registers) {
  registers.registerChartView(Bar3DView_default);
  registers.registerSeriesModel(Bar3DSeries_default);
  registerBarLayout(registers);
  registers.registerProcessor(function(ecModel, api) {
    ecModel.eachSeriesByType("bar3d", function(seriesModel) {
      var data = seriesModel.getData();
      data.filterSelf(function(idx) {
        return data.hasValue(idx);
      });
    });
  });
}

// node_modules/echarts-gl/lib/chart/line3D/Line3DSeries.js
var Line3DSeries = Series_default.extend({
  type: "series.line3D",
  dependencies: ["grid3D"],
  visualStyleAccessPath: "lineStyle",
  visualDrawType: "stroke",
  getInitialData: function(option, ecModel) {
    return createList_default(this);
  },
  formatTooltip: function(dataIndex) {
    return formatTooltip_default(this, dataIndex);
  },
  defaultOption: {
    coordinateSystem: "cartesian3D",
    zlevel: -10,
    // Cartesian coordinate system
    grid3DIndex: 0,
    lineStyle: {
      width: 2
    },
    animationDurationUpdate: 500
  }
});
var Line3DSeries_default = Line3DSeries;

// node_modules/echarts-gl/lib/chart/line3D/Line3DView.js
var vec35 = glmatrix_default.vec3;
graphicGL_default.Shader.import(lines3D_glsl_default);
var Line3DView_default = Chart_default.extend({
  type: "line3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL_default.Node();
    this._api = api;
  },
  render: function(seriesModel, ecModel, api) {
    var tmp = this._prevLine3DMesh;
    this._prevLine3DMesh = this._line3DMesh;
    this._line3DMesh = tmp;
    if (!this._line3DMesh) {
      this._line3DMesh = new graphicGL_default.Mesh({
        geometry: new Lines3D_default({
          useNativeLine: false,
          sortTriangles: true
        }),
        material: new graphicGL_default.Material({
          shader: graphicGL_default.createShader("ecgl.meshLines3D")
        }),
        // Render after axes
        renderOrder: 10
      });
      this._line3DMesh.geometry.pick = this._pick.bind(this);
    }
    this.groupGL.remove(this._prevLine3DMesh);
    this.groupGL.add(this._line3DMesh);
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
      var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
      this._line3DMesh.material[methodName]("fragment", "SRGB_DECODE");
    }
    this._doRender(seriesModel, api);
    this._data = seriesModel.getData();
    this._camera = coordSys.viewGL.camera;
    this.updateCamera();
    this._updateAnimation(seriesModel);
  },
  updateCamera: function() {
    this._updateNDCPosition();
  },
  _doRender: function(seriesModel, api) {
    var data = seriesModel.getData();
    var lineMesh = this._line3DMesh;
    lineMesh.geometry.resetOffset();
    var points = data.getLayout("points");
    var colorArr = [];
    var vertexColors = new Float32Array(points.length / 3 * 4);
    var colorOffset = 0;
    var hasTransparent = false;
    data.each(function(idx) {
      var color = getItemVisualColor(data, idx);
      var opacity = getItemVisualOpacity(data, idx);
      if (opacity == null) {
        opacity = 1;
      }
      graphicGL_default.parseColor(color, colorArr);
      colorArr[3] *= opacity;
      vertexColors[colorOffset++] = colorArr[0];
      vertexColors[colorOffset++] = colorArr[1];
      vertexColors[colorOffset++] = colorArr[2];
      vertexColors[colorOffset++] = colorArr[3];
      if (colorArr[3] < 0.99) {
        hasTransparent = true;
      }
    });
    lineMesh.geometry.setVertexCount(lineMesh.geometry.getPolylineVertexCount(points));
    lineMesh.geometry.setTriangleCount(lineMesh.geometry.getPolylineTriangleCount(points));
    lineMesh.geometry.addPolyline(points, vertexColors, retrieve_default.firstNotNull(seriesModel.get("lineStyle.width"), 1));
    lineMesh.geometry.dirty();
    lineMesh.geometry.updateBoundingBox();
    var material = lineMesh.material;
    material.transparent = hasTransparent;
    material.depthMask = !hasTransparent;
    var debugWireframeModel = seriesModel.getModel("debug.wireframe");
    if (debugWireframeModel.get("show")) {
      lineMesh.geometry.createAttribute("barycentric", "float", 3);
      lineMesh.geometry.generateBarycentric();
      lineMesh.material.set("both", "WIREFRAME_TRIANGLE");
      lineMesh.material.set("wireframeLineColor", graphicGL_default.parseColor(debugWireframeModel.get("lineStyle.color") || "rgba(0,0,0,0.5)"));
      lineMesh.material.set("wireframeLineWidth", retrieve_default.firstNotNull(debugWireframeModel.get("lineStyle.width"), 1));
    } else {
      lineMesh.material.set("both", "WIREFRAME_TRIANGLE");
    }
    this._points = points;
    this._initHandler(seriesModel, api);
  },
  _updateAnimation: function(seriesModel) {
    graphicGL_default.updateVertexAnimation([["prevPosition", "position"], ["prevPositionPrev", "positionPrev"], ["prevPositionNext", "positionNext"]], this._prevLine3DMesh, this._line3DMesh, seriesModel);
  },
  _initHandler: function(seriesModel, api) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;
    var lineMesh = this._line3DMesh;
    var lastDataIndex = -1;
    lineMesh.seriesIndex = seriesModel.seriesIndex;
    lineMesh.off("mousemove");
    lineMesh.off("mouseout");
    lineMesh.on("mousemove", function(e) {
      var value = coordSys.pointToData(e.point.array);
      var dataIndex = data.indicesOfNearest("x", value[0])[0];
      if (dataIndex !== lastDataIndex) {
        api.dispatchAction({
          type: "grid3DShowAxisPointer",
          value: [data.get("x", dataIndex), data.get("y", dataIndex), data.get("z", dataIndex)]
        });
        lineMesh.dataIndex = dataIndex;
      }
      lastDataIndex = dataIndex;
    }, this);
    lineMesh.on("mouseout", function(e) {
      lastDataIndex = -1;
      lineMesh.dataIndex = -1;
      api.dispatchAction({
        type: "grid3DHideAxisPointer"
      });
    }, this);
  },
  // _highlight: function (dataIndex) {
  //     var data = this._data;
  //     if (!data) {
  //         return;
  //     }
  // },
  // _downplay: function (dataIndex) {
  //     var data = this._data;
  //     if (!data) {
  //         return;
  //     }
  // },
  _updateNDCPosition: function() {
    var worldViewProjection = new Matrix4_default();
    var camera = this._camera;
    Matrix4_default.multiply(worldViewProjection, camera.projectionMatrix, camera.viewMatrix);
    var positionNDC = this._positionNDC;
    var points = this._points;
    var nPoints = points.length / 3;
    if (!positionNDC || positionNDC.length / 2 !== nPoints) {
      positionNDC = this._positionNDC = new Float32Array(nPoints * 2);
    }
    var pos = [];
    for (var i = 0; i < nPoints; i++) {
      var i3 = i * 3;
      var i2 = i * 2;
      pos[0] = points[i3];
      pos[1] = points[i3 + 1];
      pos[2] = points[i3 + 2];
      pos[3] = 1;
      vec35.transformMat4(pos, pos, worldViewProjection.array);
      positionNDC[i2] = pos[0] / pos[3];
      positionNDC[i2 + 1] = pos[1] / pos[3];
    }
  },
  _pick: function(x, y, renderer, camera, renderable, out) {
    var positionNDC = this._positionNDC;
    var seriesModel = this._data.hostModel;
    var lineWidth = seriesModel.get("lineStyle.width");
    var dataIndex = -1;
    var width = renderer.viewport.width;
    var height = renderer.viewport.height;
    var halfWidth = width * 0.5;
    var halfHeight = height * 0.5;
    x = (x + 1) * halfWidth;
    y = (y + 1) * halfHeight;
    for (var i = 1; i < positionNDC.length / 2; i++) {
      var x0 = (positionNDC[(i - 1) * 2] + 1) * halfWidth;
      var y0 = (positionNDC[(i - 1) * 2 + 1] + 1) * halfHeight;
      var x1 = (positionNDC[i * 2] + 1) * halfWidth;
      var y1 = (positionNDC[i * 2 + 1] + 1) * halfHeight;
      if (containStroke(x0, y0, x1, y1, lineWidth, x, y)) {
        var dist0 = (x0 - x) * (x0 - x) + (y0 - y) * (y0 - y);
        var dist1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);
        dataIndex = dist0 < dist1 ? i - 1 : i;
      }
    }
    if (dataIndex >= 0) {
      var i3 = dataIndex * 3;
      var point = new Vector3_default(this._points[i3], this._points[i3 + 1], this._points[i3 + 2]);
      out.push({
        dataIndex,
        point,
        pointWorld: point.clone(),
        target: this._line3DMesh,
        distance: this._camera.getWorldPosition().dist(point)
      });
    }
  },
  remove: function() {
    this.groupGL.removeAll();
  },
  dispose: function() {
    this.groupGL.removeAll();
  }
});

// node_modules/echarts-gl/lib/chart/line3D/install.js
function install3(registers) {
  registers.registerChartView(Line3DView_default);
  registers.registerSeriesModel(Line3DSeries_default);
  registers.registerLayout(function(ecModel, api) {
    ecModel.eachSeriesByType("line3D", function(seriesModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys) {
        if (coordSys.type !== "cartesian3D") {
          if (true) {
            console.error("line3D needs cartesian3D coordinateSystem");
          }
          return;
        }
        var points = new Float32Array(data.count() * 3);
        var item = [];
        var out = [];
        var coordDims = coordSys.dimensions;
        var dims = coordDims.map(function(coordDim) {
          return seriesModel.coordDimToDataDim(coordDim)[0];
        });
        if (coordSys) {
          data.each(dims, function(x, y, z, idx) {
            item[0] = x;
            item[1] = y;
            item[2] = z;
            coordSys.dataToPoint(item, out);
            points[idx * 3] = out[0];
            points[idx * 3 + 1] = out[1];
            points[idx * 3 + 2] = out[2];
          });
        }
        data.setLayout("points", points);
      }
    });
  });
}

// node_modules/echarts-gl/lib/chart/scatter3D/Scatter3DSeries.js
var Scatter3DSeries_default = Series_default.extend({
  type: "series.scatter3D",
  dependencies: ["globe", "grid3D", "geo3D"],
  visualStyleAccessPath: "itemStyle",
  hasSymbolVisual: true,
  getInitialData: function(option, ecModel) {
    return createList_default(this);
  },
  getFormattedLabel: function(dataIndex, status, dataType, dimIndex) {
    var text = format_default.getFormattedLabel(this, dataIndex, status, dataType, dimIndex);
    if (text == null) {
      var data = this.getData();
      var lastDim = data.dimensions[data.dimensions.length - 1];
      text = data.get(lastDim, dataIndex);
    }
    return text;
  },
  formatTooltip: function(dataIndex) {
    return formatTooltip_default(this, dataIndex);
  },
  defaultOption: {
    coordinateSystem: "cartesian3D",
    zlevel: -10,
    progressive: 1e5,
    progressiveThreshold: 1e5,
    // Cartesian coordinate system
    grid3DIndex: 0,
    globeIndex: 0,
    symbol: "circle",
    symbolSize: 10,
    // Support source-over, lighter
    blendMode: "source-over",
    label: {
      show: false,
      position: "right",
      // Screen space distance
      distance: 5,
      textStyle: {
        fontSize: 14,
        color: "#000",
        backgroundColor: "rgba(255,255,255,0.7)",
        padding: 3,
        borderRadius: 3
      }
    },
    itemStyle: {
      opacity: 0.8
    },
    emphasis: {
      label: {
        show: true
      }
    },
    animationDurationUpdate: 500
  }
});

// node_modules/echarts-gl/lib/util/sprite.js
function makeSprite(size, canvas, draw) {
  var canvas = canvas || document.createElement("canvas");
  canvas.width = size;
  canvas.height = size;
  var ctx = canvas.getContext("2d");
  draw && draw(ctx);
  return canvas;
}
function makePath(symbol, symbolSize, style, marginBias) {
  if (!util_exports.isArray(symbolSize)) {
    symbolSize = [symbolSize, symbolSize];
  }
  var margin = spriteUtil.getMarginByStyle(style, marginBias);
  var width = symbolSize[0] + margin.left + margin.right;
  var height = symbolSize[1] + margin.top + margin.bottom;
  var path = helper_exports.createSymbol(symbol, 0, 0, symbolSize[0], symbolSize[1]);
  var size = Math.max(width, height);
  path.x = margin.left;
  path.y = margin.top;
  if (width > height) {
    path.y += (size - height) / 2;
  } else {
    path.x += (size - width) / 2;
  }
  var rect = path.getBoundingRect();
  path.x -= rect.x;
  path.y -= rect.y;
  path.setStyle(style);
  path.update();
  path.__size = size;
  return path;
}
function generateSDF(ctx, sourceImageData, range) {
  var sourceWidth = sourceImageData.width;
  var sourceHeight = sourceImageData.height;
  var width = ctx.canvas.width;
  var height = ctx.canvas.height;
  var scaleX = sourceWidth / width;
  var scaleY = sourceHeight / height;
  function sign2(r) {
    return r < 128 ? 1 : -1;
  }
  function searchMinDistance(x2, y2) {
    var minDistSqr = Infinity;
    x2 = Math.floor(x2 * scaleX);
    y2 = Math.floor(y2 * scaleY);
    var i2 = y2 * sourceWidth + x2;
    var r = sourceImageData.data[i2 * 4];
    var a = sign2(r);
    for (var y22 = Math.max(y2 - range, 0); y22 < Math.min(y2 + range, sourceHeight); y22++) {
      for (var x22 = Math.max(x2 - range, 0); x22 < Math.min(x2 + range, sourceWidth); x22++) {
        var i2 = y22 * sourceWidth + x22;
        var r2 = sourceImageData.data[i2 * 4];
        var b = sign2(r2);
        var dx = x22 - x2;
        var dy = y22 - y2;
        if (a !== b) {
          var distSqr = dx * dx + dy * dy;
          if (distSqr < minDistSqr) {
            minDistSqr = distSqr;
          }
        }
      }
    }
    return a * Math.sqrt(minDistSqr);
  }
  var sdfImageData = ctx.createImageData(width, height);
  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      var dist = searchMinDistance(x, y);
      var normalized = dist / range * 0.5 + 0.5;
      var i = (y * width + x) * 4;
      sdfImageData.data[i++] = (1 - normalized) * 255;
      sdfImageData.data[i++] = (1 - normalized) * 255;
      sdfImageData.data[i++] = (1 - normalized) * 255;
      sdfImageData.data[i++] = 255;
    }
  }
  return sdfImageData;
}
var spriteUtil = {
  getMarginByStyle: function(style) {
    var minMargin = style.minMargin || 0;
    var lineWidth = 0;
    if (style.stroke && style.stroke !== "none") {
      lineWidth = style.lineWidth == null ? 1 : style.lineWidth;
    }
    var shadowBlurSize = style.shadowBlur || 0;
    var shadowOffsetX = style.shadowOffsetX || 0;
    var shadowOffsetY = style.shadowOffsetY || 0;
    var margin = {};
    margin.left = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize, minMargin);
    margin.right = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize, minMargin);
    margin.top = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize, minMargin);
    margin.bottom = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize, minMargin);
    return margin;
  },
  // TODO Not consider shadowOffsetX, shadowOffsetY.
  /**
   * @param {string} symbol
   * @param {number | Array.<number>} symbolSize
   * @param {Object} style
   */
  createSymbolSprite: function(symbol, symbolSize, style, canvas) {
    var path = makePath(symbol, symbolSize, style);
    var margin = spriteUtil.getMarginByStyle(style);
    return {
      image: makeSprite(path.__size, canvas, function(ctx) {
        brushSingle(ctx, path);
      }),
      margin
    };
  },
  createSDFFromCanvas: function(canvas, size, range, outCanvas) {
    return makeSprite(size, outCanvas, function(outCtx) {
      var ctx = canvas.getContext("2d");
      var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      outCtx.putImageData(generateSDF(outCtx, imgData, range), 0, 0);
    });
  },
  createSimpleSprite: function(size, canvas) {
    return makeSprite(size, canvas, function(ctx) {
      var halfSize = size / 2;
      ctx.beginPath();
      ctx.arc(halfSize, halfSize, 60, 0, Math.PI * 2, false);
      ctx.closePath();
      var gradient = ctx.createRadialGradient(halfSize, halfSize, 0, halfSize, halfSize, halfSize);
      gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
      gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.5)");
      gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
      ctx.fillStyle = gradient;
      ctx.fill();
    });
  }
};
var sprite_default = spriteUtil;

// node_modules/echarts-gl/lib/util/geometry/verticesSortMixin.js
var vec36 = glmatrix_default.vec3;
var verticesSortMixin_default = {
  needsSortVertices: function() {
    return this.sortVertices;
  },
  needsSortVerticesProgressively: function() {
    return this.needsSortVertices() && this.vertexCount >= 2e4;
  },
  doSortVertices: function(cameraPos, frame) {
    var indices = this.indices;
    var p = vec36.create();
    if (!indices) {
      indices = this.indices = this.vertexCount > 65535 ? new Uint32Array(this.vertexCount) : new Uint16Array(this.vertexCount);
      for (var i = 0; i < indices.length; i++) {
        indices[i] = i;
      }
    }
    if (frame === 0) {
      var posAttr = this.attributes.position;
      var cameraPos = cameraPos.array;
      var noneCount = 0;
      if (!this._zList || this._zList.length !== this.vertexCount) {
        this._zList = new Float32Array(this.vertexCount);
      }
      var firstZ;
      for (var i = 0; i < this.vertexCount; i++) {
        posAttr.get(i, p);
        var z = vec36.sqrDist(p, cameraPos);
        if (isNaN(z)) {
          z = 1e7;
          noneCount++;
        }
        if (i === 0) {
          firstZ = z;
          z = 0;
        } else {
          z = z - firstZ;
        }
        this._zList[i] = z;
      }
      this._noneCount = noneCount;
    }
    if (this.vertexCount < 2e4) {
      if (frame === 0) {
        this._simpleSort(this._noneCount / this.vertexCount > 0.05);
      }
    } else {
      for (var i = 0; i < 3; i++) {
        this._progressiveQuickSort(frame * 3 + i);
      }
    }
    this.dirtyIndices();
  },
  _simpleSort: function(useNativeQuickSort) {
    var zList = this._zList;
    var indices = this.indices;
    function compare(a, b) {
      return zList[b] - zList[a];
    }
    if (useNativeQuickSort) {
      Array.prototype.sort.call(indices, compare);
    } else {
      ProgressiveQuickSort_default.sort(indices, compare, 0, indices.length - 1);
    }
  },
  _progressiveQuickSort: function(frame) {
    var zList = this._zList;
    var indices = this.indices;
    this._quickSort = this._quickSort || new ProgressiveQuickSort_default();
    this._quickSort.step(indices, function(a, b) {
      return zList[b] - zList[a];
    }, frame);
  }
};

// node_modules/echarts-gl/lib/chart/common/sdfSprite.glsl.js
var sdfSprite_glsl_default = "@export ecgl.sdfSprite.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform float elapsedTime : 0;\n\nattribute vec3 position : POSITION;\n\n#ifdef VERTEX_SIZE\nattribute float size;\n#else\nuniform float u_Size;\n#endif\n\n#ifdef VERTEX_COLOR\nattribute vec4 a_FillColor: COLOR;\nvarying vec4 v_Color;\n#endif\n\n#ifdef VERTEX_ANIMATION\nattribute vec3 prevPosition;\nattribute float prevSize;\nuniform float percent : 1.0;\n#endif\n\n\n#ifdef POSITIONTEXTURE_ENABLED\nuniform sampler2D positionTexture;\n#endif\n\nvarying float v_Size;\n\nvoid main()\n{\n\n#ifdef POSITIONTEXTURE_ENABLED\n gl_Position = worldViewProjection * vec4(texture2D(positionTexture, position.xy).xy, -10.0, 1.0);\n#else\n\n #ifdef VERTEX_ANIMATION\n vec3 pos = mix(prevPosition, position, percent);\n #else\n vec3 pos = position;\n #endif\n gl_Position = worldViewProjection * vec4(pos, 1.0);\n#endif\n\n#ifdef VERTEX_SIZE\n#ifdef VERTEX_ANIMATION\n v_Size = mix(prevSize, size, percent);\n#else\n v_Size = size;\n#endif\n#else\n v_Size = u_Size;\n#endif\n\n#ifdef VERTEX_COLOR\n v_Color = a_FillColor;\n #endif\n\n gl_PointSize = v_Size;\n}\n\n@end\n\n@export ecgl.sdfSprite.fragment\n\nuniform vec4 color: [1, 1, 1, 1];\nuniform vec4 strokeColor: [1, 1, 1, 1];\nuniform float smoothing: 0.07;\n\nuniform float lineWidth: 0.0;\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\nvarying float v_Size;\n\nuniform sampler2D sprite;\n\n@import clay.util.srgb\n\nvoid main()\n{\n gl_FragColor = color;\n\n vec4 _strokeColor = strokeColor;\n\n#ifdef VERTEX_COLOR\n gl_FragColor *= v_Color;\n #endif\n\n#ifdef SPRITE_ENABLED\n float d = texture2D(sprite, gl_PointCoord).r;\n gl_FragColor.a *= smoothstep(0.5 - smoothing, 0.5 + smoothing, d);\n\n if (lineWidth > 0.0) {\n float sLineWidth = lineWidth / 2.0;\n\n float outlineMaxValue0 = 0.5 + sLineWidth;\n float outlineMaxValue1 = 0.5 + sLineWidth + smoothing;\n float outlineMinValue0 = 0.5 - sLineWidth - smoothing;\n float outlineMinValue1 = 0.5 - sLineWidth;\n\n if (d <= outlineMaxValue1 && d >= outlineMinValue0) {\n float a = _strokeColor.a;\n if (d <= outlineMinValue1) {\n a = a * smoothstep(outlineMinValue0, outlineMinValue1, d);\n }\n else {\n a = a * smoothstep(outlineMaxValue1, outlineMaxValue0, d);\n }\n gl_FragColor.rgb = mix(gl_FragColor.rgb * gl_FragColor.a, _strokeColor.rgb, a);\n gl_FragColor.a = gl_FragColor.a * (1.0 - a) + a;\n }\n }\n#endif\n\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(gl_FragColor);\n#endif\n}\n@end";

// node_modules/echarts-gl/lib/chart/common/PointsMesh.js
var vec4 = glmatrix_default.vec4;
graphicGL_default.Shader.import(sdfSprite_glsl_default);
var PointsMesh = graphicGL_default.Mesh.extend(function() {
  var geometry = new graphicGL_default.Geometry({
    dynamic: true,
    attributes: {
      color: new graphicGL_default.Geometry.Attribute("color", "float", 4, "COLOR"),
      position: new graphicGL_default.Geometry.Attribute("position", "float", 3, "POSITION"),
      size: new graphicGL_default.Geometry.Attribute("size", "float", 1),
      prevPosition: new graphicGL_default.Geometry.Attribute("prevPosition", "float", 3),
      prevSize: new graphicGL_default.Geometry.Attribute("prevSize", "float", 1)
    }
  });
  Object.assign(geometry, verticesSortMixin_default);
  var material = new graphicGL_default.Material({
    shader: graphicGL_default.createShader("ecgl.sdfSprite"),
    transparent: true,
    depthMask: false
  });
  material.enableTexture("sprite");
  material.define("both", "VERTEX_COLOR");
  material.define("both", "VERTEX_SIZE");
  var sdfTexture = new graphicGL_default.Texture2D({
    image: document.createElement("canvas"),
    flipY: false
  });
  material.set("sprite", sdfTexture);
  geometry.pick = this._pick.bind(this);
  return {
    geometry,
    material,
    mode: graphicGL_default.Mesh.POINTS,
    sizeScale: 1
  };
}, {
  _pick: function(x, y, renderer, camera, renderable, out) {
    var positionNDC = this._positionNDC;
    if (!positionNDC) {
      return;
    }
    var viewport = renderer.viewport;
    var ndcScaleX = 2 / viewport.width;
    var ndcScaleY = 2 / viewport.height;
    for (var i = this.geometry.vertexCount - 1; i >= 0; i--) {
      var idx;
      if (!this.geometry.indices) {
        idx = i;
      } else {
        idx = this.geometry.indices[i];
      }
      var cx = positionNDC[idx * 2];
      var cy = positionNDC[idx * 2 + 1];
      var size = this.geometry.attributes.size.get(idx) / this.sizeScale;
      var halfSize = size / 2;
      if (x > cx - halfSize * ndcScaleX && x < cx + halfSize * ndcScaleX && y > cy - halfSize * ndcScaleY && y < cy + halfSize * ndcScaleY) {
        var point = new graphicGL_default.Vector3();
        var pointWorld = new graphicGL_default.Vector3();
        this.geometry.attributes.position.get(idx, point.array);
        graphicGL_default.Vector3.transformMat4(pointWorld, point, this.worldTransform);
        out.push({
          vertexIndex: idx,
          point,
          pointWorld,
          target: this,
          distance: pointWorld.distance(camera.getWorldPosition())
        });
      }
    }
  },
  updateNDCPosition: function(worldViewProjection, is2D, api) {
    var positionNDC = this._positionNDC;
    var geometry = this.geometry;
    if (!positionNDC || positionNDC.length / 2 !== geometry.vertexCount) {
      positionNDC = this._positionNDC = new Float32Array(geometry.vertexCount * 2);
    }
    var pos = vec4.create();
    for (var i = 0; i < geometry.vertexCount; i++) {
      geometry.attributes.position.get(i, pos);
      pos[3] = 1;
      vec4.transformMat4(pos, pos, worldViewProjection.array);
      vec4.scale(pos, pos, 1 / pos[3]);
      positionNDC[i * 2] = pos[0];
      positionNDC[i * 2 + 1] = pos[1];
    }
  }
});
var PointsMesh_default = PointsMesh;

// node_modules/echarts-gl/lib/chart/common/PointsBuilder.js
var SDF_RANGE = 20;
var Z_2D = -10;
function isSymbolSizeSame(a, b) {
  return a && b && a[0] === b[0] && a[1] === b[1];
}
function PointsBuilder(is2D, api) {
  this.rootNode = new graphicGL_default.Node();
  this.is2D = is2D;
  this._labelsBuilder = new LabelsBuilder_default(256, 256, api);
  this._labelsBuilder.getMesh().renderOrder = 100;
  this.rootNode.add(this._labelsBuilder.getMesh());
  this._api = api;
  this._spriteImageCanvas = document.createElement("canvas");
  this._startDataIndex = 0;
  this._endDataIndex = 0;
  this._sizeScale = 1;
}
PointsBuilder.prototype = {
  constructor: PointsBuilder,
  /**
   * If highlight on over
   */
  highlightOnMouseover: true,
  update: function(seriesModel, ecModel, api, start, end) {
    var tmp = this._prevMesh;
    this._prevMesh = this._mesh;
    this._mesh = tmp;
    var data = seriesModel.getData();
    if (start == null) {
      start = 0;
    }
    if (end == null) {
      end = data.count();
    }
    this._startDataIndex = start;
    this._endDataIndex = end - 1;
    if (!this._mesh) {
      var material = this._prevMesh && this._prevMesh.material;
      this._mesh = new PointsMesh_default({
        // Render after axes
        renderOrder: 10,
        // FIXME
        frustumCulling: false
      });
      if (material) {
        this._mesh.material = material;
      }
    }
    var material = this._mesh.material;
    var geometry = this._mesh.geometry;
    var attributes = geometry.attributes;
    this.rootNode.remove(this._prevMesh);
    this.rootNode.add(this._mesh);
    this._setPositionTextureToMesh(this._mesh, this._positionTexture);
    var symbolInfo = this._getSymbolInfo(seriesModel, start, end);
    var dpr = api.getDevicePixelRatio();
    var itemStyle = seriesModel.getModel("itemStyle").getItemStyle();
    var largeMode = seriesModel.get("large");
    var pointSizeScale = 1;
    if (symbolInfo.maxSize > 2) {
      pointSizeScale = this._updateSymbolSprite(seriesModel, itemStyle, symbolInfo, dpr);
      material.enableTexture("sprite");
    } else {
      material.disableTexture("sprite");
    }
    attributes.position.init(end - start);
    var rgbaArr = [];
    if (largeMode) {
      material.undefine("VERTEX_SIZE");
      material.undefine("VERTEX_COLOR");
      var color = getVisualColor(data);
      var opacity = getVisualOpacity(data);
      graphicGL_default.parseColor(color, rgbaArr);
      rgbaArr[3] *= opacity;
      material.set({
        color: rgbaArr,
        "u_Size": symbolInfo.maxSize * this._sizeScale
      });
    } else {
      material.set({
        color: [1, 1, 1, 1]
      });
      material.define("VERTEX_SIZE");
      material.define("VERTEX_COLOR");
      attributes.size.init(end - start);
      attributes.color.init(end - start);
      this._originalOpacity = new Float32Array(end - start);
    }
    var points = data.getLayout("points");
    var positionArr = attributes.position.value;
    var hasTransparentPoint = false;
    for (var i = 0; i < end - start; i++) {
      var i3 = i * 3;
      var i2 = i * 2;
      if (this.is2D) {
        positionArr[i3] = points[i2];
        positionArr[i3 + 1] = points[i2 + 1];
        positionArr[i3 + 2] = Z_2D;
      } else {
        positionArr[i3] = points[i3];
        positionArr[i3 + 1] = points[i3 + 1];
        positionArr[i3 + 2] = points[i3 + 2];
      }
      if (!largeMode) {
        var color = getItemVisualColor(data, i);
        var opacity = getItemVisualOpacity(data, i);
        graphicGL_default.parseColor(color, rgbaArr);
        rgbaArr[3] *= opacity;
        attributes.color.set(i, rgbaArr);
        if (rgbaArr[3] < 0.99) {
          hasTransparentPoint = true;
        }
        var symbolSize = data.getItemVisual(i, "symbolSize");
        symbolSize = symbolSize instanceof Array ? Math.max(symbolSize[0], symbolSize[1]) : symbolSize;
        if (isNaN(symbolSize)) {
          symbolSize = 0;
        }
        attributes.size.value[i] = symbolSize * pointSizeScale * this._sizeScale;
        this._originalOpacity[i] = rgbaArr[3];
      }
    }
    this._mesh.sizeScale = pointSizeScale;
    geometry.updateBoundingBox();
    geometry.dirty();
    this._updateMaterial(seriesModel, itemStyle);
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
      material[methodName]("fragment", "SRGB_DECODE");
    }
    if (!largeMode) {
      this._updateLabelBuilder(seriesModel, start, end);
    }
    this._updateHandler(seriesModel, ecModel, api);
    this._updateAnimation(seriesModel);
    this._api = api;
  },
  getPointsMesh: function() {
    return this._mesh;
  },
  updateLabels: function(highlightDataIndices) {
    this._labelsBuilder.updateLabels(highlightDataIndices);
  },
  hideLabels: function() {
    this.rootNode.remove(this._labelsBuilder.getMesh());
  },
  showLabels: function() {
    this.rootNode.add(this._labelsBuilder.getMesh());
  },
  dispose: function() {
    this._labelsBuilder.dispose();
  },
  _updateSymbolSprite: function(seriesModel, itemStyle, symbolInfo, dpr) {
    symbolInfo.maxSize = Math.min(symbolInfo.maxSize * 2, 200);
    var symbolSize = [];
    if (symbolInfo.aspect > 1) {
      symbolSize[0] = symbolInfo.maxSize;
      symbolSize[1] = symbolInfo.maxSize / symbolInfo.aspect;
    } else {
      symbolSize[1] = symbolInfo.maxSize;
      symbolSize[0] = symbolInfo.maxSize * symbolInfo.aspect;
    }
    symbolSize[0] = symbolSize[0] || 1;
    symbolSize[1] = symbolSize[1] || 1;
    if (this._symbolType !== symbolInfo.type || !isSymbolSizeSame(this._symbolSize, symbolSize) || this._lineWidth !== itemStyle.lineWidth) {
      sprite_default.createSymbolSprite(symbolInfo.type, symbolSize, {
        fill: "#fff",
        lineWidth: itemStyle.lineWidth,
        stroke: "transparent",
        shadowColor: "transparent",
        minMargin: Math.min(symbolSize[0] / 2, 10)
      }, this._spriteImageCanvas);
      sprite_default.createSDFFromCanvas(this._spriteImageCanvas, Math.min(this._spriteImageCanvas.width, 32), SDF_RANGE, this._mesh.material.get("sprite").image);
      this._symbolType = symbolInfo.type;
      this._symbolSize = symbolSize;
      this._lineWidth = itemStyle.lineWidth;
    }
    return this._spriteImageCanvas.width / symbolInfo.maxSize * dpr;
  },
  _updateMaterial: function(seriesModel, itemStyle) {
    var blendFunc = seriesModel.get("blendMode") === "lighter" ? graphicGL_default.additiveBlend : null;
    var material = this._mesh.material;
    material.blend = blendFunc;
    material.set("lineWidth", itemStyle.lineWidth / SDF_RANGE);
    var strokeColor = graphicGL_default.parseColor(itemStyle.stroke);
    material.set("strokeColor", strokeColor);
    material.transparent = true;
    material.depthMask = false;
    material.depthTest = !this.is2D;
    material.sortVertices = !this.is2D;
  },
  _updateLabelBuilder: function(seriesModel, start, end) {
    var data = seriesModel.getData();
    var geometry = this._mesh.geometry;
    var positionArr = geometry.attributes.position.value;
    var start = this._startDataIndex;
    var pointSizeScale = this._mesh.sizeScale;
    this._labelsBuilder.updateData(data, start, end);
    this._labelsBuilder.getLabelPosition = function(dataIndex, positionDesc, distance) {
      var idx3 = (dataIndex - start) * 3;
      return [positionArr[idx3], positionArr[idx3 + 1], positionArr[idx3 + 2]];
    };
    this._labelsBuilder.getLabelDistance = function(dataIndex, positionDesc, distance) {
      var size = geometry.attributes.size.get(dataIndex - start) / pointSizeScale;
      return size / 2 + distance;
    };
    this._labelsBuilder.updateLabels();
  },
  _updateAnimation: function(seriesModel) {
    graphicGL_default.updateVertexAnimation([["prevPosition", "position"], ["prevSize", "size"]], this._prevMesh, this._mesh, seriesModel);
  },
  _updateHandler: function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var pointsMesh = this._mesh;
    var self2 = this;
    var lastDataIndex = -1;
    var isCartesian3D = seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian3D";
    var grid3DModel;
    if (isCartesian3D) {
      grid3DModel = seriesModel.coordinateSystem.model;
    }
    pointsMesh.seriesIndex = seriesModel.seriesIndex;
    pointsMesh.off("mousemove");
    pointsMesh.off("mouseout");
    pointsMesh.on("mousemove", function(e) {
      var dataIndex = e.vertexIndex + self2._startDataIndex;
      if (dataIndex !== lastDataIndex) {
        if (this.highlightOnMouseover) {
          this.downplay(data, lastDataIndex);
          this.highlight(data, dataIndex);
          this._labelsBuilder.updateLabels([dataIndex]);
        }
        if (isCartesian3D) {
          api.dispatchAction({
            type: "grid3DShowAxisPointer",
            value: [data.get(seriesModel.coordDimToDataDim("x")[0], dataIndex), data.get(seriesModel.coordDimToDataDim("y")[0], dataIndex), data.get(seriesModel.coordDimToDataDim("z")[0], dataIndex)],
            grid3DIndex: grid3DModel.componentIndex
          });
        }
      }
      pointsMesh.dataIndex = dataIndex;
      lastDataIndex = dataIndex;
    }, this);
    pointsMesh.on("mouseout", function(e) {
      var dataIndex = e.vertexIndex + self2._startDataIndex;
      if (this.highlightOnMouseover) {
        this.downplay(data, dataIndex);
        this._labelsBuilder.updateLabels();
      }
      lastDataIndex = -1;
      pointsMesh.dataIndex = -1;
      if (isCartesian3D) {
        api.dispatchAction({
          type: "grid3DHideAxisPointer",
          grid3DIndex: grid3DModel.componentIndex
        });
      }
    }, this);
  },
  updateLayout: function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    if (!this._mesh) {
      return;
    }
    var positionArr = this._mesh.geometry.attributes.position.value;
    var points = data.getLayout("points");
    if (this.is2D) {
      for (var i = 0; i < points.length / 2; i++) {
        var i3 = i * 3;
        var i2 = i * 2;
        positionArr[i3] = points[i2];
        positionArr[i3 + 1] = points[i2 + 1];
        positionArr[i3 + 2] = Z_2D;
      }
    } else {
      for (var i = 0; i < points.length; i++) {
        positionArr[i] = points[i];
      }
    }
    this._mesh.geometry.dirty();
    api.getZr().refresh();
  },
  updateView: function(camera) {
    if (!this._mesh) {
      return;
    }
    var worldViewProjection = new Matrix4_default();
    Matrix4_default.mul(worldViewProjection, camera.viewMatrix, this._mesh.worldTransform);
    Matrix4_default.mul(worldViewProjection, camera.projectionMatrix, worldViewProjection);
    this._mesh.updateNDCPosition(worldViewProjection, this.is2D, this._api);
  },
  highlight: function(data, dataIndex) {
    if (dataIndex > this._endDataIndex || dataIndex < this._startDataIndex) {
      return;
    }
    var itemModel = data.getItemModel(dataIndex);
    var emphasisItemStyleModel = itemModel.getModel("emphasis.itemStyle");
    var emphasisColor = emphasisItemStyleModel.get("color");
    var emphasisOpacity = emphasisItemStyleModel.get("opacity");
    if (emphasisColor == null) {
      var color = getItemVisualColor(data, dataIndex);
      emphasisColor = color_exports.lift(color, -0.4);
    }
    if (emphasisOpacity == null) {
      emphasisOpacity = getItemVisualOpacity(data, dataIndex);
    }
    var colorArr = graphicGL_default.parseColor(emphasisColor);
    colorArr[3] *= emphasisOpacity;
    this._mesh.geometry.attributes.color.set(dataIndex - this._startDataIndex, colorArr);
    this._mesh.geometry.dirtyAttribute("color");
    this._api.getZr().refresh();
  },
  downplay: function(data, dataIndex) {
    if (dataIndex > this._endDataIndex || dataIndex < this._startDataIndex) {
      return;
    }
    var color = getItemVisualColor(data, dataIndex);
    var opacity = getItemVisualOpacity(data, dataIndex);
    var colorArr = graphicGL_default.parseColor(color);
    colorArr[3] *= opacity;
    this._mesh.geometry.attributes.color.set(dataIndex - this._startDataIndex, colorArr);
    this._mesh.geometry.dirtyAttribute("color");
    this._api.getZr().refresh();
  },
  fadeOutAll: function(fadeOutPercent) {
    if (this._originalOpacity) {
      var geo = this._mesh.geometry;
      for (var i = 0; i < geo.vertexCount; i++) {
        var fadeOutOpacity = this._originalOpacity[i] * fadeOutPercent;
        geo.attributes.color.value[i * 4 + 3] = fadeOutOpacity;
      }
      geo.dirtyAttribute("color");
      this._api.getZr().refresh();
    }
  },
  fadeInAll: function() {
    this.fadeOutAll(1);
  },
  setPositionTexture: function(texture) {
    if (this._mesh) {
      this._setPositionTextureToMesh(this._mesh, texture);
    }
    this._positionTexture = texture;
  },
  removePositionTexture: function() {
    this._positionTexture = null;
    if (this._mesh) {
      this._setPositionTextureToMesh(this._mesh, null);
    }
  },
  setSizeScale: function(sizeScale) {
    if (sizeScale !== this._sizeScale) {
      if (this._mesh) {
        var originalSize = this._mesh.material.get("u_Size");
        this._mesh.material.set("u_Size", originalSize / this._sizeScale * sizeScale);
        var attributes = this._mesh.geometry.attributes;
        if (attributes.size.value) {
          for (var i = 0; i < attributes.size.value.length; i++) {
            attributes.size.value[i] = attributes.size.value[i] / this._sizeScale * sizeScale;
          }
        }
      }
      this._sizeScale = sizeScale;
    }
  },
  _setPositionTextureToMesh: function(mesh, texture) {
    if (texture) {
      mesh.material.set("positionTexture", texture);
    }
    mesh.material[texture ? "enableTexture" : "disableTexture"]("positionTexture");
  },
  _getSymbolInfo: function(seriesModel, start, end) {
    if (seriesModel.get("large")) {
      var symbolSize = retrieve_default.firstNotNull(seriesModel.get("symbolSize"), 1);
      var maxSymbolSize;
      var symbolAspect;
      if (symbolSize instanceof Array) {
        maxSymbolSize = Math.max(symbolSize[0], symbolSize[1]);
        symbolAspect = symbolSize[0] / symbolSize[1];
      } else {
        maxSymbolSize = symbolSize;
        symbolAspect = 1;
      }
      return {
        maxSize: symbolSize,
        type: seriesModel.get("symbol"),
        aspect: symbolAspect
      };
    }
    var data = seriesModel.getData();
    var symbolAspect;
    var differentSymbolAspect = false;
    var symbolType = data.getItemVisual(0, "symbol") || "circle";
    var differentSymbolType = false;
    var maxSymbolSize = 0;
    for (var idx = start; idx < end; idx++) {
      var symbolSize = data.getItemVisual(idx, "symbolSize");
      var currentSymbolType = data.getItemVisual(idx, "symbol");
      var currentSymbolAspect;
      if (!(symbolSize instanceof Array)) {
        if (isNaN(symbolSize)) {
          continue;
        }
        currentSymbolAspect = 1;
        maxSymbolSize = Math.max(symbolSize, maxSymbolSize);
      } else {
        currentSymbolAspect = symbolSize[0] / symbolSize[1];
        maxSymbolSize = Math.max(Math.max(symbolSize[0], symbolSize[1]), maxSymbolSize);
      }
      if (true) {
        if (symbolAspect != null && Math.abs(currentSymbolAspect - symbolAspect) > 0.05) {
          differentSymbolAspect = true;
        }
        if (currentSymbolType !== symbolType) {
          differentSymbolType = true;
        }
      }
      symbolType = currentSymbolType;
      symbolAspect = currentSymbolAspect;
    }
    if (true) {
      if (differentSymbolAspect) {
        console.warn("Different symbol width / height ratio will be ignored.");
      }
      if (differentSymbolType) {
        console.warn("Different symbol type will be ignored.");
      }
    }
    return {
      maxSize: maxSymbolSize,
      type: symbolType,
      aspect: symbolAspect
    };
  }
};
var PointsBuilder_default = PointsBuilder;

// node_modules/echarts-gl/lib/chart/scatter3D/Scatter3DView.js
var Scatter3DView_default = Chart_default.extend({
  type: "scatter3D",
  hasSymbolVisual: true,
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL_default.Node();
    this._pointsBuilderList = [];
    this._currentStep = 0;
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    if (!seriesModel.getData().count()) {
      return;
    }
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
      this._camera = coordSys.viewGL.camera;
      var pointsBuilder = this._pointsBuilderList[0];
      if (!pointsBuilder) {
        pointsBuilder = this._pointsBuilderList[0] = new PointsBuilder_default(false, api);
      }
      this._pointsBuilderList.length = 1;
      this.groupGL.add(pointsBuilder.rootNode);
      pointsBuilder.update(seriesModel, ecModel, api);
      pointsBuilder.updateView(coordSys.viewGL.camera);
    } else {
      if (true) {
        throw new Error("Invalid coordinate system");
      }
    }
  },
  incrementalPrepareRender: function(seriesModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
      this._camera = coordSys.viewGL.camera;
    } else {
      if (true) {
        throw new Error("Invalid coordinate system");
      }
    }
    this.groupGL.removeAll();
    this._currentStep = 0;
  },
  incrementalRender: function(params, seriesModel, ecModel, api) {
    if (params.end <= params.start) {
      return;
    }
    var pointsBuilder = this._pointsBuilderList[this._currentStep];
    if (!pointsBuilder) {
      pointsBuilder = new PointsBuilder_default(false, api);
      this._pointsBuilderList[this._currentStep] = pointsBuilder;
    }
    this.groupGL.add(pointsBuilder.rootNode);
    pointsBuilder.update(seriesModel, ecModel, api, params.start, params.end);
    pointsBuilder.updateView(seriesModel.coordinateSystem.viewGL.camera);
    this._currentStep++;
  },
  updateCamera: function() {
    this._pointsBuilderList.forEach(function(pointsBuilder) {
      pointsBuilder.updateView(this._camera);
    }, this);
  },
  highlight: function(seriesModel, ecModel, api, payload) {
    this._toggleStatus("highlight", seriesModel, ecModel, api, payload);
  },
  downplay: function(seriesModel, ecModel, api, payload) {
    this._toggleStatus("downplay", seriesModel, ecModel, api, payload);
  },
  _toggleStatus: function(status, seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = retrieve_default.queryDataIndex(data, payload);
    var isHighlight = status === "highlight";
    if (dataIndex != null) {
      util_exports.each(format_default.normalizeToArray(dataIndex), function(dataIdx) {
        for (var i = 0; i < this._pointsBuilderList.length; i++) {
          var pointsBuilder = this._pointsBuilderList[i];
          isHighlight ? pointsBuilder.highlight(data, dataIdx) : pointsBuilder.downplay(data, dataIdx);
        }
      }, this);
    } else {
      data.each(function(dataIdx) {
        for (var i = 0; i < this._pointsBuilderList.length; i++) {
          var pointsBuilder = this._pointsBuilderList[i];
          isHighlight ? pointsBuilder.highlight(data, dataIdx) : pointsBuilder.downplay(data, dataIdx);
        }
      });
    }
  },
  dispose: function() {
    this._pointsBuilderList.forEach(function(pointsBuilder) {
      pointsBuilder.dispose();
    });
    this.groupGL.removeAll();
  },
  remove: function() {
    this.groupGL.removeAll();
  }
});

// node_modules/echarts-gl/lib/chart/scatter3D/install.js
function install4(registers) {
  registers.registerChartView(Scatter3DView_default);
  registers.registerSeriesModel(Scatter3DSeries_default);
  registers.registerLayout({
    seriesType: "scatter3D",
    reset: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys) {
        var coordDims = coordSys.dimensions;
        if (coordDims.length < 3) {
          if (true) {
            console.error("scatter3D needs 3D coordinateSystem");
          }
          return;
        }
        var dims = coordDims.map(function(coordDim) {
          return seriesModel.coordDimToDataDim(coordDim)[0];
        });
        var item = [];
        var out = [];
        return {
          progress: function(params, data) {
            var points = new Float32Array((params.end - params.start) * 3);
            for (var idx = params.start; idx < params.end; idx++) {
              var idx3 = (idx - params.start) * 3;
              item[0] = data.get(dims[0], idx);
              item[1] = data.get(dims[1], idx);
              item[2] = data.get(dims[2], idx);
              coordSys.dataToPoint(item, out);
              points[idx3] = out[0];
              points[idx3 + 1] = out[1];
              points[idx3 + 2] = out[2];
            }
            data.setLayout("points", points);
          }
        };
      }
    }
  });
}

// node_modules/echarts-gl/lib/chart/lines3D/lines3DLayout.js
var vec37 = glmatrix_default.vec3;
var vec2 = glmatrix_default.vec2;
var normalize = vec37.normalize;
var cross = vec37.cross;
var sub = vec37.sub;
var add = vec37.add;
var create2 = vec37.create;
var normal = create2();
var tangent = create2();
var bitangent = create2();
var halfVector = create2();
var coord0 = [];
var coord1 = [];
function getCubicPointsOnGlobe(coords, coordSys) {
  vec2.copy(coord0, coords[0]);
  vec2.copy(coord1, coords[1]);
  var pts = [];
  var p0 = pts[0] = create2();
  var p1 = pts[1] = create2();
  var p2 = pts[2] = create2();
  var p3 = pts[3] = create2();
  coordSys.dataToPoint(coord0, p0);
  coordSys.dataToPoint(coord1, p3);
  normalize(normal, p0);
  sub(tangent, p3, p0);
  normalize(tangent, tangent);
  cross(bitangent, tangent, normal);
  normalize(bitangent, bitangent);
  cross(tangent, normal, bitangent);
  add(p1, normal, tangent);
  normalize(p1, p1);
  normalize(normal, p3);
  sub(tangent, p0, p3);
  normalize(tangent, tangent);
  cross(bitangent, tangent, normal);
  normalize(bitangent, bitangent);
  cross(tangent, normal, bitangent);
  add(p2, normal, tangent);
  normalize(p2, p2);
  add(halfVector, p0, p3);
  normalize(halfVector, halfVector);
  var projDist = vec37.dot(p0, halfVector);
  var cosTheta = vec37.dot(halfVector, p1);
  var len = (Math.max(vec37.len(p0), vec37.len(p3)) - projDist) / cosTheta * 2;
  vec37.scaleAndAdd(p1, p0, p1, len);
  vec37.scaleAndAdd(p2, p3, p2, len);
  return pts;
}
function getCubicPointsOnPlane(coords, coordSys, up) {
  var pts = [];
  var p0 = pts[0] = vec37.create();
  var p1 = pts[1] = vec37.create();
  var p2 = pts[2] = vec37.create();
  var p3 = pts[3] = vec37.create();
  coordSys.dataToPoint(coords[0], p0);
  coordSys.dataToPoint(coords[1], p3);
  var len = vec37.dist(p0, p3);
  vec37.lerp(p1, p0, p3, 0.3);
  vec37.lerp(p2, p0, p3, 0.3);
  vec37.scaleAndAdd(p1, p1, up, Math.min(len * 0.1, 10));
  vec37.scaleAndAdd(p2, p2, up, Math.min(len * 0.1, 10));
  return pts;
}
function getPolylinePoints(coords, coordSys) {
  var pts = new Float32Array(coords.length * 3);
  var off = 0;
  var pt = [];
  for (var i = 0; i < coords.length; i++) {
    coordSys.dataToPoint(coords[i], pt);
    pts[off++] = pt[0];
    pts[off++] = pt[1];
    pts[off++] = pt[2];
  }
  return pts;
}
function prepareCoords(data) {
  var coordsList = [];
  data.each(function(idx) {
    var itemModel = data.getItemModel(idx);
    var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords", true);
    if (true) {
      if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {
        throw new Error("Invalid coords " + JSON.stringify(coords) + ". Lines must have 2d coords array in data item.");
      }
    }
    coordsList.push(coords);
  });
  return {
    coordsList
  };
}
function layoutGlobe(seriesModel, coordSys) {
  var data = seriesModel.getData();
  var isPolyline = seriesModel.get("polyline");
  data.setLayout("lineType", isPolyline ? "polyline" : "cubicBezier");
  var res = prepareCoords(data);
  data.each(function(idx) {
    var coords = res.coordsList[idx];
    var getPointsMethod = isPolyline ? getPolylinePoints : getCubicPointsOnGlobe;
    data.setItemLayout(idx, getPointsMethod(coords, coordSys));
  });
}
function layoutOnPlane(seriesModel, coordSys, normal2) {
  var data = seriesModel.getData();
  var isPolyline = seriesModel.get("polyline");
  var res = prepareCoords(data);
  data.setLayout("lineType", isPolyline ? "polyline" : "cubicBezier");
  data.each(function(idx) {
    var coords = res.coordsList[idx];
    var pts = isPolyline ? getPolylinePoints(coords, coordSys) : getCubicPointsOnPlane(coords, coordSys, normal2);
    data.setItemLayout(idx, pts);
  });
}
function lines3DLayout(ecModel, api) {
  ecModel.eachSeriesByType("lines3D", function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys.type === "globe") {
      layoutGlobe(seriesModel, coordSys);
    } else if (coordSys.type === "geo3D") {
      layoutOnPlane(seriesModel, coordSys, [0, 1, 0]);
    } else if (coordSys.type === "mapbox3D" || coordSys.type === "maptalks3D") {
      layoutOnPlane(seriesModel, coordSys, [0, 0, 1]);
    }
  });
}

// node_modules/echarts-gl/lib/chart/lines3D/Lines3DSeries.js
var Lines3DSeries_default = Series_default.extend({
  type: "series.lines3D",
  dependencies: ["globe"],
  visualStyleAccessPath: "lineStyle",
  visualDrawType: "stroke",
  getInitialData: function(option, ecModel) {
    var lineData = new SeriesData_default(["value"], this);
    lineData.hasItemOption = false;
    lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
      if (dataItem instanceof Array) {
        return NaN;
      } else {
        lineData.hasItemOption = true;
        var value = dataItem.value;
        if (value != null) {
          return value instanceof Array ? value[dimIndex] : value;
        }
      }
    });
    return lineData;
  },
  defaultOption: {
    coordinateSystem: "globe",
    globeIndex: 0,
    geo3DIndex: 0,
    zlevel: -10,
    polyline: false,
    effect: {
      show: false,
      period: 4,
      // Trail width
      trailWidth: 4,
      trailLength: 0.2,
      spotIntensity: 6
    },
    silent: true,
    // Support source-over, lighter
    blendMode: "source-over",
    lineStyle: {
      width: 1,
      opacity: 0.5
      // color
    }
  }
});

// node_modules/echarts-gl/lib/chart/lines3D/shader/trail2.glsl.js
var trail2_glsl_default = "@export ecgl.trail2.vertex\nattribute vec3 position: POSITION;\nattribute vec3 positionPrev;\nattribute vec3 positionNext;\nattribute float offset;\nattribute float dist;\nattribute float distAll;\nattribute float start;\n\nattribute vec4 a_Color : COLOR;\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform vec4 viewport : VIEWPORT;\nuniform float near : NEAR;\n\nuniform float speed : 0;\nuniform float trailLength: 0.3;\nuniform float time;\nuniform float period: 1000;\n\nuniform float spotSize: 1;\n\nvarying vec4 v_Color;\nvarying float v_Percent;\nvarying float v_SpotPercent;\n\n@import ecgl.common.wireframe.vertexHeader\n\n@import ecgl.lines3D.clipNear\n\nvoid main()\n{\n @import ecgl.lines3D.expandLine\n\n gl_Position = currProj;\n\n v_Color = a_Color;\n\n @import ecgl.common.wireframe.vertexMain\n\n#ifdef CONSTANT_SPEED\n float t = mod((speed * time + start) / distAll, 1. + trailLength) - trailLength;\n#else\n float t = mod((time + start) / period, 1. + trailLength) - trailLength;\n#endif\n\n float trailLen = distAll * trailLength;\n\n v_Percent = (dist - t * distAll) / trailLen;\n\n v_SpotPercent = spotSize / distAll;\n\n }\n@end\n\n\n@export ecgl.trail2.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nuniform float spotIntensity: 5;\n\nvarying vec4 v_Color;\nvarying float v_Percent;\nvarying float v_SpotPercent;\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.util.srgb\n\nvoid main()\n{\n if (v_Percent > 1.0 || v_Percent < 0.0) {\n discard;\n }\n\n float fade = v_Percent;\n\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(color * v_Color);\n#else\n gl_FragColor = color * v_Color;\n#endif\n\n @import ecgl.common.wireframe.fragmentMain\n\n if (v_Percent > (1.0 - v_SpotPercent)) {\n gl_FragColor.rgb *= spotIntensity;\n }\n\n gl_FragColor.a *= fade;\n}\n\n@end";

// node_modules/echarts-gl/lib/chart/lines3D/TrailMesh2.js
var vec38 = glmatrix_default.vec3;
function sign(a) {
  return a > 0 ? 1 : -1;
}
graphicGL_default.Shader.import(trail2_glsl_default);
var TrailMesh2_default = graphicGL_default.Mesh.extend(function() {
  var material = new graphicGL_default.Material({
    shader: new graphicGL_default.Shader(graphicGL_default.Shader.source("ecgl.trail2.vertex"), graphicGL_default.Shader.source("ecgl.trail2.fragment")),
    transparent: true,
    depthMask: false
  });
  var geometry = new Lines3D_default({
    dynamic: true
  });
  geometry.createAttribute("dist", "float", 1);
  geometry.createAttribute("distAll", "float", 1);
  geometry.createAttribute("start", "float", 1);
  return {
    geometry,
    material,
    culling: false,
    $ignorePicking: true
  };
}, {
  updateData: function(data, api, lines3DGeometry) {
    var seriesModel = data.hostModel;
    var geometry = this.geometry;
    var effectModel = seriesModel.getModel("effect");
    var size = effectModel.get("trailWidth") * api.getDevicePixelRatio();
    var trailLength = effectModel.get("trailLength");
    var speed = seriesModel.get("effect.constantSpeed");
    var period = seriesModel.get("effect.period") * 1e3;
    var useConstantSpeed = speed != null;
    if (true) {
      if (!this.getScene()) {
        console.error("TrailMesh must been add to scene before updateData");
      }
    }
    useConstantSpeed ? this.material.set("speed", speed / 1e3) : this.material.set("period", period);
    this.material[useConstantSpeed ? "define" : "undefine"]("vertex", "CONSTANT_SPEED");
    var isPolyline = seriesModel.get("polyline");
    geometry.trailLength = trailLength;
    this.material.set("trailLength", trailLength);
    geometry.resetOffset();
    ["position", "positionPrev", "positionNext"].forEach(function(attrName) {
      geometry.attributes[attrName].value = lines3DGeometry.attributes[attrName].value;
    });
    var extraAttrs = ["dist", "distAll", "start", "offset", "color"];
    extraAttrs.forEach(function(attrName) {
      geometry.attributes[attrName].init(geometry.vertexCount);
    });
    geometry.indices = lines3DGeometry.indices;
    var colorArr = [];
    var effectColor = effectModel.get("trailColor");
    var effectOpacity = effectModel.get("trailOpacity");
    var hasEffectColor = effectColor != null;
    var hasEffectOpacity = effectOpacity != null;
    this.updateWorldTransform();
    var xScale = this.worldTransform.x.len();
    var yScale = this.worldTransform.y.len();
    var zScale = this.worldTransform.z.len();
    var vertexOffset = 0;
    var maxDistance = 0;
    data.each(function(idx) {
      var pts = data.getItemLayout(idx);
      var opacity = hasEffectOpacity ? effectOpacity : getItemVisualOpacity(data, idx);
      var color = getItemVisualColor(data, idx);
      if (opacity == null) {
        opacity = 1;
      }
      colorArr = graphicGL_default.parseColor(hasEffectColor ? effectColor : color, colorArr);
      colorArr[3] *= opacity;
      var vertexCount = isPolyline ? lines3DGeometry.getPolylineVertexCount(pts) : lines3DGeometry.getCubicCurveVertexCount(pts[0], pts[1], pts[2], pts[3]);
      var dist = 0;
      var pos = [];
      var posPrev = [];
      for (var i = vertexOffset; i < vertexOffset + vertexCount; i++) {
        geometry.attributes.position.get(i, pos);
        pos[0] *= xScale;
        pos[1] *= yScale;
        pos[2] *= zScale;
        if (i > vertexOffset) {
          dist += vec38.dist(pos, posPrev);
        }
        geometry.attributes.dist.set(i, dist);
        vec38.copy(posPrev, pos);
      }
      maxDistance = Math.max(maxDistance, dist);
      var randomStart = Math.random() * (useConstantSpeed ? dist : period);
      for (var i = vertexOffset; i < vertexOffset + vertexCount; i++) {
        geometry.attributes.distAll.set(i, dist);
        geometry.attributes.start.set(i, randomStart);
        geometry.attributes.offset.set(i, sign(lines3DGeometry.attributes.offset.get(i)) * size / 2);
        geometry.attributes.color.set(i, colorArr);
      }
      vertexOffset += vertexCount;
    });
    this.material.set("spotSize", maxDistance * 0.1 * trailLength);
    this.material.set("spotIntensity", effectModel.get("spotIntensity"));
    geometry.dirty();
  },
  setAnimationTime: function(time) {
    this.material.set("time", time);
  }
});

// node_modules/echarts-gl/lib/chart/lines3D/Lines3DView.js
graphicGL_default.Shader.import(lines3D_glsl_default);
function getCoordSysSize(coordSys) {
  if (coordSys.radius != null) {
    return coordSys.radius;
  }
  if (coordSys.size != null) {
    return Math.max(coordSys.size[0], coordSys.size[1], coordSys.size[2]);
  } else {
    return 100;
  }
}
var Lines3DView_default = Chart_default.extend({
  type: "lines3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL_default.Node();
    this._meshLinesMaterial = new graphicGL_default.Material({
      shader: graphicGL_default.createShader("ecgl.meshLines3D"),
      transparent: true,
      depthMask: false
    });
    this._linesMesh = new graphicGL_default.Mesh({
      geometry: new Lines3D_default(),
      material: this._meshLinesMaterial,
      $ignorePicking: true
    });
    this._trailMesh = new TrailMesh2_default();
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.add(this._linesMesh);
    var coordSys = seriesModel.coordinateSystem;
    var data = seriesModel.getData();
    if (coordSys && coordSys.viewGL) {
      var viewGL = coordSys.viewGL;
      viewGL.add(this.groupGL);
      this._updateLines(seriesModel, ecModel, api);
      var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
      this._linesMesh.material[methodName]("fragment", "SRGB_DECODE");
      this._trailMesh.material[methodName]("fragment", "SRGB_DECODE");
    }
    var trailMesh = this._trailMesh;
    trailMesh.stopAnimation();
    if (seriesModel.get("effect.show")) {
      this.groupGL.add(trailMesh);
      trailMesh.updateData(data, api, this._linesMesh.geometry);
      trailMesh.__time = trailMesh.__time || 0;
      var time = 3600 * 1e3;
      this._curveEffectsAnimator = trailMesh.animate("", {
        loop: true
      }).when(time, {
        __time: time
      }).during(function() {
        trailMesh.setAnimationTime(trailMesh.__time);
      }).start();
    } else {
      this.groupGL.remove(trailMesh);
      this._curveEffectsAnimator = null;
    }
    this._linesMesh.material.blend = this._trailMesh.material.blend = seriesModel.get("blendMode") === "lighter" ? graphicGL_default.additiveBlend : null;
  },
  pauseEffect: function() {
    if (this._curveEffectsAnimator) {
      this._curveEffectsAnimator.pause();
    }
  },
  resumeEffect: function() {
    if (this._curveEffectsAnimator) {
      this._curveEffectsAnimator.resume();
    }
  },
  toggleEffect: function() {
    var animator = this._curveEffectsAnimator;
    if (animator) {
      animator.isPaused() ? animator.resume() : animator.pause();
    }
  },
  _updateLines: function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;
    var geometry = this._linesMesh.geometry;
    var isPolyline = seriesModel.get("polyline");
    geometry.expandLine = true;
    var size = getCoordSysSize(coordSys);
    geometry.segmentScale = size / 20;
    var lineWidthQueryPath = "lineStyle.width".split(".");
    var dpr = api.getDevicePixelRatio();
    var maxLineWidth = 0;
    data.each(function(idx) {
      var itemModel = data.getItemModel(idx);
      var lineWidth = itemModel.get(lineWidthQueryPath);
      if (lineWidth == null) {
        lineWidth = 1;
      }
      data.setItemVisual(idx, "lineWidth", lineWidth);
      maxLineWidth = Math.max(lineWidth, maxLineWidth);
    });
    geometry.useNativeLine = false;
    var nVertex = 0;
    var nTriangle = 0;
    data.each(function(idx) {
      var pts = data.getItemLayout(idx);
      if (isPolyline) {
        nVertex += geometry.getPolylineVertexCount(pts);
        nTriangle += geometry.getPolylineTriangleCount(pts);
      } else {
        nVertex += geometry.getCubicCurveVertexCount(pts[0], pts[1], pts[2], pts[3]);
        nTriangle += geometry.getCubicCurveTriangleCount(pts[0], pts[1], pts[2], pts[3]);
      }
    });
    geometry.setVertexCount(nVertex);
    geometry.setTriangleCount(nTriangle);
    geometry.resetOffset();
    var colorArr = [];
    data.each(function(idx) {
      var pts = data.getItemLayout(idx);
      var color = getItemVisualColor(data, idx);
      var opacity = getItemVisualOpacity(data, idx);
      var lineWidth = data.getItemVisual(idx, "lineWidth") * dpr;
      if (opacity == null) {
        opacity = 1;
      }
      colorArr = graphicGL_default.parseColor(color, colorArr);
      colorArr[3] *= opacity;
      if (isPolyline) {
        geometry.addPolyline(pts, colorArr, lineWidth);
      } else {
        geometry.addCubicCurve(pts[0], pts[1], pts[2], pts[3], colorArr, lineWidth);
      }
    });
    geometry.dirty();
  },
  remove: function() {
    this.groupGL.removeAll();
  },
  dispose: function() {
    this.groupGL.removeAll();
  }
});

// node_modules/echarts-gl/lib/chart/lines3D/install.js
function install5(registers) {
  registers.registerChartView(Lines3DView_default);
  registers.registerSeriesModel(Lines3DSeries_default);
  registers.registerLayout(lines3DLayout);
  registers.registerAction({
    type: "lines3DPauseEffect",
    event: "lines3deffectpaused",
    update: "series.lines3D:pauseEffect"
  }, function() {
  });
  registers.registerAction({
    type: "lines3DResumeEffect",
    event: "lines3deffectresumed",
    update: "series.lines3D:resumeEffect"
  }, function() {
  });
  registers.registerAction({
    type: "lines3DToggleEffect",
    event: "lines3deffectchanged",
    update: "series.lines3D:toggleEffect"
  }, function() {
  });
}

// node_modules/echarts-gl/lib/chart/polygons3D/Polygons3DSeries.js
function transformPolygon(coordSys, poly) {
  var ret = [];
  for (var i = 0; i < poly.length; i++) {
    ret.push(coordSys.dataToPoint(poly[i]));
  }
  return ret;
}
var Polygons3DSeries = Series_default.extend({
  type: "series.polygons3D",
  getRegionModel: function(idx) {
    return this.getData().getItemModel(idx);
  },
  getRegionPolygonCoords: function(idx) {
    var coordSys = this.coordinateSystem;
    var itemModel = this.getData().getItemModel(idx);
    var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
    if (!itemModel.get("multiPolygon")) {
      coords = [coords];
    }
    var out = [];
    for (var i = 0; i < coords.length; i++) {
      var interiors = [];
      for (var k = 1; k < coords[i].length; k++) {
        interiors.push(transformPolygon(coordSys, coords[i][k]));
      }
      out.push({
        exterior: transformPolygon(coordSys, coords[i][0]),
        interiors
      });
    }
    return out;
  },
  getInitialData: function(option) {
    var polygonsData = new SeriesData_default(["value"], this);
    polygonsData.hasItemOption = false;
    polygonsData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
      if (dataItem instanceof Array) {
        return NaN;
      } else {
        polygonsData.hasItemOption = true;
        var value = dataItem.value;
        if (value != null) {
          return value instanceof Array ? value[dimIndex] : value;
        }
      }
    });
    return polygonsData;
  },
  defaultOption: {
    show: true,
    data: null,
    multiPolygon: false,
    progressiveThreshold: 1e3,
    progressive: 1e3,
    zlevel: -10,
    label: {
      show: false,
      // Distance in 3d space.
      distance: 2,
      textStyle: {
        fontSize: 20,
        color: "#000",
        backgroundColor: "rgba(255,255,255,0.7)",
        padding: 3,
        borderRadius: 4
      }
    },
    itemStyle: {
      color: "#fff",
      borderWidth: 0,
      borderColor: "#333"
    },
    emphasis: {
      itemStyle: {
        color: "#639fc0"
      },
      label: {
        show: true
      }
    }
  }
});
util_exports.merge(Polygons3DSeries.prototype, componentShadingMixin_default);
var Polygons3DSeries_default = Polygons3DSeries;

// node_modules/echarts-gl/lib/chart/polygons3D/Polygons3DView.js
var Polygons3DView_default = Chart_default.extend({
  type: "polygons3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL_default.Node();
    this._geo3DBuilderList = [];
    this._currentStep = 0;
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
    }
    var geo3DBuilder = this._geo3DBuilderList[0];
    if (!geo3DBuilder) {
      geo3DBuilder = new Geo3DBuilder_default(api);
      geo3DBuilder.extrudeY = coordSys.type !== "mapbox3D" && coordSys.type !== "maptalks3D";
      this._geo3DBuilderList[0] = geo3DBuilder;
    }
    this._updateShaderDefines(coordSys, geo3DBuilder);
    geo3DBuilder.update(seriesModel, ecModel, api);
    this._geo3DBuilderList.length = 1;
    this.groupGL.add(geo3DBuilder.rootNode);
  },
  incrementalPrepareRender: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
    }
    this._currentStep = 0;
  },
  incrementalRender: function(params, seriesModel, ecModel, api) {
    var geo3DBuilder = this._geo3DBuilderList[this._currentStep];
    var coordSys = seriesModel.coordinateSystem;
    if (!geo3DBuilder) {
      geo3DBuilder = new Geo3DBuilder_default(api);
      geo3DBuilder.extrudeY = coordSys.type !== "mapbox3D" && coordSys.type !== "maptalks3D";
      this._geo3DBuilderList[this._currentStep] = geo3DBuilder;
    }
    geo3DBuilder.update(seriesModel, ecModel, api, params.start, params.end);
    this.groupGL.add(geo3DBuilder.rootNode);
    this._updateShaderDefines(coordSys, geo3DBuilder);
    this._currentStep++;
  },
  _updateShaderDefines: function(coordSys, geo3DBuilder) {
    var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
    geo3DBuilder.rootNode.traverse(function(mesh) {
      if (mesh.material) {
        mesh.material[methodName]("fragment", "SRGB_DECODE");
        if (coordSys.type === "mapbox3D" || coordSys.type === "maptalks3D") {
          mesh.material.define("fragment", "NORMAL_UP_AXIS", 2);
          mesh.material.define("fragment", "NORMAL_FRONT_AXIS", 1);
        }
      }
    });
  },
  remove: function() {
    this.groupGL.removeAll();
  },
  dispose: function() {
    this.groupGL.removeAll();
    this._geo3DBuilderList.forEach(function(geo3DBuilder) {
      geo3DBuilder.dispose();
    });
  }
});

// node_modules/echarts-gl/lib/chart/polygons3D/install.js
function install6(registers) {
  registers.registerChartView(Polygons3DView_default);
  registers.registerSeriesModel(Polygons3DSeries_default);
}

// node_modules/echarts-gl/lib/chart/surface/SurfaceSeries.js
var SurfaceSeries = Series_default.extend({
  type: "series.surface",
  dependencies: ["globe", "grid3D", "geo3D"],
  visualStyleAccessPath: "itemStyle",
  formatTooltip: function(dataIndex) {
    return formatTooltip_default(this, dataIndex);
  },
  getInitialData: function(option, ecModel) {
    var data = option.data;
    function validateDimension(dimOpts) {
      return !(isNaN(dimOpts.min) || isNaN(dimOpts.max) || isNaN(dimOpts.step));
    }
    function getPrecision(dimOpts) {
      var getPrecision2 = number_exports.getPrecisionSafe;
      return Math.max(getPrecision2(dimOpts.min), getPrecision2(dimOpts.max), getPrecision2(dimOpts.step)) + 1;
    }
    if (!data) {
      if (!option.parametric) {
        var equation = option.equation || {};
        var xOpts = equation.x || {};
        var yOpts = equation.y || {};
        ["x", "y"].forEach(function(dim) {
          if (!validateDimension(equation[dim])) {
            if (true) {
              console.error("Invalid equation.%s", dim);
            }
            return;
          }
        });
        if (typeof equation.z !== "function") {
          if (true) {
            console.error("equation.z needs to be function");
          }
          return;
        }
        var xCount = Math.floor((xOpts.max + xOpts.step - xOpts.min) / xOpts.step);
        var yCount = Math.floor((yOpts.max + yOpts.step - yOpts.min) / yOpts.step);
        data = new Float32Array(xCount * yCount * 3);
        var xPrecision = getPrecision(xOpts);
        var yPrecision = getPrecision(yOpts);
        var off = 0;
        for (var j = 0; j < yCount; j++) {
          for (var i = 0; i < xCount; i++) {
            var x = i * xOpts.step + xOpts.min;
            var y = j * yOpts.step + yOpts.min;
            var x2 = number_exports.round(Math.min(x, xOpts.max), xPrecision);
            var y2 = number_exports.round(Math.min(y, yOpts.max), yPrecision);
            var z = equation.z(x2, y2);
            data[off++] = x2;
            data[off++] = y2;
            data[off++] = z;
          }
        }
      } else {
        var parametricEquation = option.parametricEquation || {};
        var uOpts = parametricEquation.u || {};
        var vOpts = parametricEquation.v || {};
        ["u", "v"].forEach(function(dim) {
          if (!validateDimension(parametricEquation[dim])) {
            if (true) {
              console.error("Invalid parametricEquation.%s", dim);
            }
            return;
          }
        });
        ["x", "y", "z"].forEach(function(dim) {
          if (typeof parametricEquation[dim] !== "function") {
            if (true) {
              console.error("parametricEquation.%s needs to be function", dim);
            }
            return;
          }
        });
        var uCount = Math.floor((uOpts.max + uOpts.step - uOpts.min) / uOpts.step);
        var vCount = Math.floor((vOpts.max + vOpts.step - vOpts.min) / vOpts.step);
        data = new Float32Array(uCount * vCount * 5);
        var uPrecision = getPrecision(uOpts);
        var vPrecision = getPrecision(vOpts);
        var off = 0;
        for (var j = 0; j < vCount; j++) {
          for (var i = 0; i < uCount; i++) {
            var u = i * uOpts.step + uOpts.min;
            var v = j * vOpts.step + vOpts.min;
            var u2 = number_exports.round(Math.min(u, uOpts.max), uPrecision);
            var v2 = number_exports.round(Math.min(v, vOpts.max), vPrecision);
            var x = parametricEquation.x(u2, v2);
            var y = parametricEquation.y(u2, v2);
            var z = parametricEquation.z(u2, v2);
            data[off++] = x;
            data[off++] = y;
            data[off++] = z;
            data[off++] = u2;
            data[off++] = v2;
          }
        }
      }
    }
    var dims = ["x", "y", "z"];
    if (option.parametric) {
      dims.push("u", "v");
    }
    var list = createList_default(this, dims, data);
    return list;
  },
  defaultOption: {
    coordinateSystem: "cartesian3D",
    zlevel: -10,
    // Cartesian coordinate system
    grid3DIndex: 0,
    // Surface needs lambert shading to show the difference
    shading: "lambert",
    // If parametric surface
    parametric: false,
    wireframe: {
      show: true,
      lineStyle: {
        color: "rgba(0,0,0,0.5)",
        width: 1
      }
    },
    /**
     * Generate surface data from z = f(x, y) equation
     */
    equation: {
      // [min, max, step]
      x: {
        min: -1,
        max: 1,
        step: 0.1
      },
      y: {
        min: -1,
        max: 1,
        step: 0.1
      },
      z: null
    },
    parametricEquation: {
      // [min, max, step]
      u: {
        min: -1,
        max: 1,
        step: 0.1
      },
      v: {
        min: -1,
        max: 1,
        step: 0.1
      },
      // [x, y, z] = f(x, y)
      x: null,
      y: null,
      z: null
    },
    // Shape of give data
    // It is an array to specify rows and columns.
    // For example [30, 30]
    dataShape: null,
    itemStyle: {
      // Color
    },
    animationDurationUpdate: 500
  }
});
util_exports.merge(SurfaceSeries.prototype, componentShadingMixin_default);
var SurfaceSeries_default = SurfaceSeries;

// node_modules/echarts-gl/lib/chart/surface/SurfaceView.js
var vec39 = glmatrix_default.vec3;
function isPointsNaN(pt) {
  return isNaN(pt[0]) || isNaN(pt[1]) || isNaN(pt[2]);
}
var SurfaceView_default = Chart_default.extend({
  type: "surface",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL_default.Node();
  },
  render: function(seriesModel, ecModel, api) {
    var tmp = this._prevSurfaceMesh;
    this._prevSurfaceMesh = this._surfaceMesh;
    this._surfaceMesh = tmp;
    if (!this._surfaceMesh) {
      this._surfaceMesh = this._createSurfaceMesh();
    }
    this.groupGL.remove(this._prevSurfaceMesh);
    this.groupGL.add(this._surfaceMesh);
    var coordSys = seriesModel.coordinateSystem;
    var shading = seriesModel.get("shading");
    var data = seriesModel.getData();
    var shadingPrefix = "ecgl." + shading;
    if (!this._surfaceMesh.material || this._surfaceMesh.material.shader.name !== shadingPrefix) {
      this._surfaceMesh.material = graphicGL_default.createMaterial(shadingPrefix, ["VERTEX_COLOR", "DOUBLE_SIDED"]);
    }
    graphicGL_default.setMaterialFromModel(shading, this._surfaceMesh.material, seriesModel, api);
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
      var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
      this._surfaceMesh.material[methodName]("fragment", "SRGB_DECODE");
    }
    var isParametric = seriesModel.get("parametric");
    var dataShape = seriesModel.get("dataShape");
    if (!dataShape) {
      dataShape = this._getDataShape(data, isParametric);
      if (true) {
        if (seriesModel.get("data")) {
          console.warn("dataShape is not provided. Guess it is ", dataShape);
        }
      }
    }
    var wireframeModel = seriesModel.getModel("wireframe");
    var wireframeLineWidth = wireframeModel.get("lineStyle.width");
    var showWireframe = wireframeModel.get("show") && wireframeLineWidth > 0;
    this._updateSurfaceMesh(this._surfaceMesh, seriesModel, dataShape, showWireframe);
    var material = this._surfaceMesh.material;
    if (showWireframe) {
      material.define("WIREFRAME_QUAD");
      material.set("wireframeLineWidth", wireframeLineWidth);
      material.set("wireframeLineColor", graphicGL_default.parseColor(wireframeModel.get("lineStyle.color")));
    } else {
      material.undefine("WIREFRAME_QUAD");
    }
    this._initHandler(seriesModel, api);
    this._updateAnimation(seriesModel);
  },
  _updateAnimation: function(seriesModel) {
    graphicGL_default.updateVertexAnimation([["prevPosition", "position"], ["prevNormal", "normal"]], this._prevSurfaceMesh, this._surfaceMesh, seriesModel);
  },
  _createSurfaceMesh: function() {
    var mesh = new graphicGL_default.Mesh({
      geometry: new graphicGL_default.Geometry({
        dynamic: true,
        sortTriangles: true
      }),
      shadowDepthMaterial: new graphicGL_default.Material({
        shader: new graphicGL_default.Shader(graphicGL_default.Shader.source("ecgl.sm.depth.vertex"), graphicGL_default.Shader.source("ecgl.sm.depth.fragment"))
      }),
      culling: false,
      // Render after axes
      renderOrder: 10,
      // Render normal in normal pass
      renderNormal: true
    });
    mesh.geometry.createAttribute("barycentric", "float", 4);
    mesh.geometry.createAttribute("prevPosition", "float", 3);
    mesh.geometry.createAttribute("prevNormal", "float", 3);
    Object.assign(mesh.geometry, trianglesSortMixin_default);
    return mesh;
  },
  _initHandler: function(seriesModel, api) {
    var data = seriesModel.getData();
    var surfaceMesh = this._surfaceMesh;
    var coordSys = seriesModel.coordinateSystem;
    function getNearestPointIdx(triangle, point) {
      var nearestDist = Infinity;
      var nearestIdx = -1;
      var pos = [];
      for (var i = 0; i < triangle.length; i++) {
        surfaceMesh.geometry.attributes.position.get(triangle[i], pos);
        var dist = vec39.dist(point.array, pos);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestIdx = triangle[i];
        }
      }
      return nearestIdx;
    }
    surfaceMesh.seriesIndex = seriesModel.seriesIndex;
    var lastDataIndex = -1;
    surfaceMesh.off("mousemove");
    surfaceMesh.off("mouseout");
    surfaceMesh.on("mousemove", function(e) {
      var idx = getNearestPointIdx(e.triangle, e.point);
      if (idx >= 0) {
        var point = [];
        surfaceMesh.geometry.attributes.position.get(idx, point);
        var value = coordSys.pointToData(point);
        var minDist = Infinity;
        var dataIndex = -1;
        var item = [];
        for (var i = 0; i < data.count(); i++) {
          item[0] = data.get("x", i);
          item[1] = data.get("y", i);
          item[2] = data.get("z", i);
          var dist = vec39.squaredDistance(item, value);
          if (dist < minDist) {
            dataIndex = i;
            minDist = dist;
          }
        }
        if (dataIndex !== lastDataIndex) {
          api.dispatchAction({
            type: "grid3DShowAxisPointer",
            value
          });
        }
        lastDataIndex = dataIndex;
        surfaceMesh.dataIndex = dataIndex;
      } else {
        surfaceMesh.dataIndex = -1;
      }
    }, this);
    surfaceMesh.on("mouseout", function(e) {
      lastDataIndex = -1;
      surfaceMesh.dataIndex = -1;
      api.dispatchAction({
        type: "grid3DHideAxisPointer"
      });
    }, this);
  },
  _updateSurfaceMesh: function(surfaceMesh, seriesModel, dataShape, showWireframe) {
    var geometry = surfaceMesh.geometry;
    var data = seriesModel.getData();
    var pointsArr = data.getLayout("points");
    var invalidDataCount = 0;
    data.each(function(idx2) {
      if (!data.hasValue(idx2)) {
        invalidDataCount++;
      }
    });
    var needsSplitQuad = invalidDataCount || showWireframe;
    var positionAttr = geometry.attributes.position;
    var normalAttr = geometry.attributes.normal;
    var texcoordAttr = geometry.attributes.texcoord0;
    var barycentricAttr = geometry.attributes.barycentric;
    var colorAttr = geometry.attributes.color;
    var row = dataShape[0];
    var column = dataShape[1];
    var shading = seriesModel.get("shading");
    var needsNormal = shading !== "color";
    if (needsSplitQuad) {
      var vertexCount = (row - 1) * (column - 1) * 4;
      positionAttr.init(vertexCount);
      if (showWireframe) {
        barycentricAttr.init(vertexCount);
      }
    } else {
      positionAttr.value = new Float32Array(pointsArr);
    }
    colorAttr.init(geometry.vertexCount);
    texcoordAttr.init(geometry.vertexCount);
    var quadToTriangle = [0, 3, 1, 1, 3, 2];
    var quadBarycentric = [[1, 1, 0, 0], [0, 1, 0, 1], [1, 0, 0, 1], [1, 0, 1, 0]];
    var indices = geometry.indices = new (geometry.vertexCount > 65535 ? Uint32Array : Uint16Array)((row - 1) * (column - 1) * 6);
    var getQuadIndices = function(i2, j2, out) {
      out[1] = i2 * column + j2;
      out[0] = i2 * column + j2 + 1;
      out[3] = (i2 + 1) * column + j2 + 1;
      out[2] = (i2 + 1) * column + j2;
    };
    var isTransparent = false;
    if (needsSplitQuad) {
      var quadIndices = [];
      var pos = [];
      var faceOffset = 0;
      if (needsNormal) {
        normalAttr.init(geometry.vertexCount);
      } else {
        normalAttr.value = null;
      }
      var pts = [[], [], []];
      var v21 = [], v32 = [];
      var normal2 = vec39.create();
      var getFromArray = function(arr, idx2, out) {
        var idx32 = idx2 * 3;
        out[0] = arr[idx32];
        out[1] = arr[idx32 + 1];
        out[2] = arr[idx32 + 2];
        return out;
      };
      var vertexNormals = new Float32Array(pointsArr.length);
      var vertexColors = new Float32Array(pointsArr.length / 3 * 4);
      for (var i = 0; i < data.count(); i++) {
        if (data.hasValue(i)) {
          var rgbaArr = graphicGL_default.parseColor(getItemVisualColor(data, i));
          var opacity = getItemVisualOpacity(data, i);
          opacity != null && (rgbaArr[3] *= opacity);
          if (rgbaArr[3] < 0.99) {
            isTransparent = true;
          }
          for (var k = 0; k < 4; k++) {
            vertexColors[i * 4 + k] = rgbaArr[k];
          }
        }
      }
      var farPoints = [1e7, 1e7, 1e7];
      for (var i = 0; i < row - 1; i++) {
        for (var j = 0; j < column - 1; j++) {
          var dataIndex = i * (column - 1) + j;
          var vertexOffset = dataIndex * 4;
          getQuadIndices(i, j, quadIndices);
          var invisibleQuad = false;
          for (var k = 0; k < 4; k++) {
            getFromArray(pointsArr, quadIndices[k], pos);
            if (isPointsNaN(pos)) {
              invisibleQuad = true;
            }
          }
          for (var k = 0; k < 4; k++) {
            if (invisibleQuad) {
              positionAttr.set(vertexOffset + k, farPoints);
            } else {
              getFromArray(pointsArr, quadIndices[k], pos);
              positionAttr.set(vertexOffset + k, pos);
            }
            if (showWireframe) {
              barycentricAttr.set(vertexOffset + k, quadBarycentric[k]);
            }
          }
          for (var k = 0; k < 6; k++) {
            indices[faceOffset++] = quadToTriangle[k] + vertexOffset;
          }
          if (needsNormal && !invisibleQuad) {
            for (var k = 0; k < 2; k++) {
              var k3 = k * 3;
              for (var m = 0; m < 3; m++) {
                var idx = quadIndices[quadToTriangle[k3] + m];
                getFromArray(pointsArr, idx, pts[m]);
              }
              vec39.sub(v21, pts[0], pts[1]);
              vec39.sub(v32, pts[1], pts[2]);
              vec39.cross(normal2, v21, v32);
              for (var m = 0; m < 3; m++) {
                var idx3 = quadIndices[quadToTriangle[k3] + m] * 3;
                vertexNormals[idx3] = vertexNormals[idx3] + normal2[0];
                vertexNormals[idx3 + 1] = vertexNormals[idx3 + 1] + normal2[1];
                vertexNormals[idx3 + 2] = vertexNormals[idx3 + 2] + normal2[2];
              }
            }
          }
        }
      }
      if (needsNormal) {
        for (var i = 0; i < vertexNormals.length / 3; i++) {
          getFromArray(vertexNormals, i, normal2);
          vec39.normalize(normal2, normal2);
          vertexNormals[i * 3] = normal2[0];
          vertexNormals[i * 3 + 1] = normal2[1];
          vertexNormals[i * 3 + 2] = normal2[2];
        }
      }
      var rgbaArr = [];
      var uvArr = [];
      for (var i = 0; i < row - 1; i++) {
        for (var j = 0; j < column - 1; j++) {
          var dataIndex = i * (column - 1) + j;
          var vertexOffset = dataIndex * 4;
          getQuadIndices(i, j, quadIndices);
          for (var k = 0; k < 4; k++) {
            for (var m = 0; m < 4; m++) {
              rgbaArr[m] = vertexColors[quadIndices[k] * 4 + m];
            }
            colorAttr.set(vertexOffset + k, rgbaArr);
            if (needsNormal) {
              getFromArray(vertexNormals, quadIndices[k], normal2);
              normalAttr.set(vertexOffset + k, normal2);
            }
            var idx = quadIndices[k];
            uvArr[0] = idx % column / (column - 1);
            uvArr[1] = Math.floor(idx / column) / (row - 1);
            texcoordAttr.set(vertexOffset + k, uvArr);
          }
          dataIndex++;
        }
      }
    } else {
      var uvArr = [];
      for (var i = 0; i < data.count(); i++) {
        uvArr[0] = i % column / (column - 1);
        uvArr[1] = Math.floor(i / column) / (row - 1);
        var rgbaArr = graphicGL_default.parseColor(getItemVisualColor(data, i));
        var opacity = getItemVisualOpacity(data, i);
        opacity != null && (rgbaArr[3] *= opacity);
        if (rgbaArr[3] < 0.99) {
          isTransparent = true;
        }
        colorAttr.set(i, rgbaArr);
        texcoordAttr.set(i, uvArr);
      }
      var quadIndices = [];
      var cursor = 0;
      for (var i = 0; i < row - 1; i++) {
        for (var j = 0; j < column - 1; j++) {
          getQuadIndices(i, j, quadIndices);
          for (var k = 0; k < 6; k++) {
            indices[cursor++] = quadIndices[quadToTriangle[k]];
          }
        }
      }
      if (needsNormal) {
        geometry.generateVertexNormals();
      } else {
        normalAttr.value = null;
      }
    }
    if (surfaceMesh.material.get("normalMap")) {
      geometry.generateTangents();
    }
    geometry.updateBoundingBox();
    geometry.dirty();
    surfaceMesh.material.transparent = isTransparent;
    surfaceMesh.material.depthMask = !isTransparent;
  },
  _getDataShape: function(data, isParametric) {
    var prevX = -Infinity;
    var rowCount = 0;
    var columnCount = 0;
    var prevColumnCount = 0;
    var mayInvalid = false;
    var rowDim = isParametric ? "u" : "x";
    var dataCount = data.count();
    for (var i = 0; i < dataCount; i++) {
      var x = data.get(rowDim, i);
      if (x < prevX) {
        if (prevColumnCount && prevColumnCount !== columnCount) {
          if (true) {
            mayInvalid = true;
          }
        }
        prevColumnCount = columnCount;
        columnCount = 0;
        rowCount++;
      }
      prevX = x;
      columnCount++;
    }
    if (!rowCount || columnCount === 1) {
      mayInvalid = true;
    }
    if (!mayInvalid) {
      return [rowCount + 1, columnCount];
    }
    var rows = Math.floor(Math.sqrt(dataCount));
    while (rows > 0) {
      if (Math.floor(dataCount / rows) === dataCount / rows) {
        return [rows, dataCount / rows];
      }
      rows--;
    }
    rows = Math.floor(Math.sqrt(dataCount));
    return [rows, rows];
  },
  dispose: function() {
    this.groupGL.removeAll();
  },
  remove: function() {
    this.groupGL.removeAll();
  }
});

// node_modules/echarts-gl/lib/chart/surface/install.js
function install7(registers) {
  registers.registerChartView(SurfaceView_default);
  registers.registerSeriesModel(SurfaceSeries_default);
  registers.registerLayout(function(ecModel, api) {
    ecModel.eachSeriesByType("surface", function(surfaceModel) {
      var cartesian = surfaceModel.coordinateSystem;
      if (!cartesian || cartesian.type !== "cartesian3D") {
        if (true) {
          console.error("Surface chart only support cartesian3D coordinateSystem");
        }
      }
      var data = surfaceModel.getData();
      var points = new Float32Array(3 * data.count());
      var nanPoint = [NaN, NaN, NaN];
      if (cartesian && cartesian.type === "cartesian3D") {
        var coordDims = cartesian.dimensions;
        var dims = coordDims.map(function(coordDim) {
          return surfaceModel.coordDimToDataDim(coordDim)[0];
        });
        data.each(dims, function(x, y, z, idx) {
          var pt;
          if (!data.hasValue(idx)) {
            pt = nanPoint;
          } else {
            pt = cartesian.dataToPoint([x, y, z]);
          }
          points[idx * 3] = pt[0];
          points[idx * 3 + 1] = pt[1];
          points[idx * 3 + 2] = pt[2];
        });
      }
      data.setLayout("points", points);
    });
  });
}

// node_modules/echarts-gl/lib/chart/map3D/Map3DSeries.js
function transformPolygon2(mapbox3DCoordSys, poly) {
  var newPoly = [];
  for (var k = 0; k < poly.length; k++) {
    newPoly.push(mapbox3DCoordSys.dataToPoint(poly[k]));
  }
  return newPoly;
}
var Map3DSeries = Series_default.extend({
  type: "series.map3D",
  layoutMode: "box",
  coordinateSystem: null,
  visualStyleAccessPath: "itemStyle",
  optionUpdated: function(newOpt) {
    newOpt = newOpt || {};
    var coordSysType = this.get("coordinateSystem");
    if (coordSysType == null || coordSysType === "geo3D") {
      return;
    }
    if (true) {
      var propsNeedToCheck = ["left", "top", "width", "height", "boxWidth", "boxDepth", "boxHeight", "light", "viewControl", "postEffect", "temporalSuperSampling", "environment", "groundPlane"];
      var ignoredProperties = [];
      propsNeedToCheck.forEach(function(propName) {
        if (newOpt[propName] != null) {
          ignoredProperties.push(propName);
        }
      });
      if (ignoredProperties.length) {
        console.warn("Property %s in map3D series will be ignored if coordinate system is %s", ignoredProperties.join(", "), coordSysType);
      }
    }
    if (this.get("groundPlane.show")) {
      this.option.groundPlane.show = false;
    }
    this._geo = null;
  },
  getInitialData: function(option) {
    option.data = this.getFilledRegions(option.data, option.map);
    var dimensions = helper_exports.createDimensions(option.data, {
      coordDimensions: ["value"]
    });
    var list = new SeriesData_default(dimensions, this);
    list.initData(option.data);
    var regionModelMap = {};
    list.each(function(idx) {
      var name = list.getName(idx);
      var itemModel = list.getItemModel(idx);
      regionModelMap[name] = itemModel;
    });
    this._regionModelMap = regionModelMap;
    return list;
  },
  formatTooltip: function(dataIndex) {
    return formatTooltip_default(this, dataIndex);
  },
  getRegionModel: function(idx) {
    var name = this.getData().getName(idx);
    return this._regionModelMap[name] || new Model_default(null, this);
  },
  getRegionPolygonCoords: function(idx) {
    var coordSys = this.coordinateSystem;
    var name = this.getData().getName(idx);
    if (coordSys.transform) {
      var region = coordSys.getRegion(name);
      return region ? region.geometries : [];
    } else {
      if (!this._geo) {
        this._geo = geo3DCreator_default.createGeo3D(this);
      }
      var region = this._geo.getRegion(name);
      var ret = [];
      for (var k = 0; k < region.geometries.length; k++) {
        var geo = region.geometries[k];
        var interiors = [];
        var exterior = transformPolygon2(coordSys, geo.exterior);
        if (interiors && interiors.length) {
          for (var m = 0; m < geo.interiors.length; m++) {
            interiors.push(transformPolygon2(coordSys, interiors[m]));
          }
        }
        ret.push({
          interiors,
          exterior
        });
      }
      return ret;
    }
  },
  /**
   * Format label
   * @param {string} name Region name
   * @param {string} [status='normal'] 'normal' or 'emphasis'
   * @return {string}
   */
  getFormattedLabel: function(dataIndex, status) {
    var text = format_default.getFormattedLabel(this, dataIndex, status);
    if (text == null) {
      text = this.getData().getName(dataIndex);
    }
    return text;
  },
  defaultOption: {
    // Support geo3D, mapbox, maptalks3D
    coordinateSystem: "geo3D",
    // itemStyle: {},
    // height,
    // label: {}
    data: null
  }
});
util_exports.merge(Map3DSeries.prototype, geo3DModelMixin_default);
util_exports.merge(Map3DSeries.prototype, componentViewControlMixin_default);
util_exports.merge(Map3DSeries.prototype, componentPostEffectMixin_default);
util_exports.merge(Map3DSeries.prototype, componentLightMixin_default);
util_exports.merge(Map3DSeries.prototype, componentShadingMixin_default);
var Map3DSeries_default = Map3DSeries;

// node_modules/echarts-gl/lib/chart/map3D/Map3DView.js
var Map3DView_default = Chart_default.extend({
  type: "map3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this._geo3DBuilder = new Geo3DBuilder_default(api);
    this.groupGL = new graphicGL_default.Node();
  },
  render: function(map3DModel, ecModel, api) {
    var coordSys = map3DModel.coordinateSystem;
    if (!coordSys || !coordSys.viewGL) {
      return;
    }
    this.groupGL.add(this._geo3DBuilder.rootNode);
    coordSys.viewGL.add(this.groupGL);
    var geo3D;
    if (coordSys.type === "geo3D") {
      geo3D = coordSys;
      if (!this._sceneHelper) {
        this._sceneHelper = new SceneHelper_default();
        this._sceneHelper.initLight(this.groupGL);
      }
      this._sceneHelper.setScene(coordSys.viewGL.scene);
      this._sceneHelper.updateLight(map3DModel);
      coordSys.viewGL.setPostEffect(map3DModel.getModel("postEffect"), api);
      coordSys.viewGL.setTemporalSuperSampling(map3DModel.getModel("temporalSuperSampling"));
      var control = this._control;
      if (!control) {
        control = this._control = new OrbitControl_default({
          zr: api.getZr()
        });
        this._control.init();
      }
      var viewControlModel = map3DModel.getModel("viewControl");
      control.setViewGL(coordSys.viewGL);
      control.setFromViewControlModel(viewControlModel, 0);
      control.off("update");
      control.on("update", function() {
        api.dispatchAction({
          type: "map3DChangeCamera",
          alpha: control.getAlpha(),
          beta: control.getBeta(),
          distance: control.getDistance(),
          from: this.uid,
          map3DId: map3DModel.id
        });
      });
      this._geo3DBuilder.extrudeY = true;
    } else {
      if (this._control) {
        this._control.dispose();
        this._control = null;
      }
      if (this._sceneHelper) {
        this._sceneHelper.dispose();
        this._sceneHelper = null;
      }
      geo3D = map3DModel.getData().getLayout("geo3D");
      this._geo3DBuilder.extrudeY = false;
    }
    this._geo3DBuilder.update(map3DModel, ecModel, api, 0, map3DModel.getData().count());
    var srgbDefineMethod = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
    this._geo3DBuilder.rootNode.traverse(function(mesh) {
      if (mesh.material) {
        mesh.material[srgbDefineMethod]("fragment", "SRGB_DECODE");
      }
    });
  },
  afterRender: function(map3DModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    var coordSys = map3DModel.coordinateSystem;
    if (coordSys && coordSys.type === "geo3D") {
      this._sceneHelper.updateAmbientCubemap(renderer, map3DModel, api);
      this._sceneHelper.updateSkybox(renderer, map3DModel, api);
    }
  },
  dispose: function() {
    this.groupGL.removeAll();
    this._control.dispose();
    this._geo3DBuilder.dispose();
  }
});

// node_modules/echarts-gl/lib/chart/map3D/install.js
function install8(registers) {
  install(registers);
  registers.registerChartView(Map3DView_default);
  registers.registerSeriesModel(Map3DSeries_default);
  registers.registerAction({
    type: "map3DChangeCamera",
    event: "map3dcamerachanged",
    update: "series:updateCamera"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "map3D",
      query: payload
    }, function(componentModel) {
      componentModel.setView(payload);
    });
  });
}

// node_modules/echarts-gl/lib/chart/scatterGL/ScatterGLSeries.js
var ScatterGLSeries_default = Series_default.extend({
  type: "series.scatterGL",
  dependencies: ["grid", "polar", "geo", "singleAxis"],
  visualStyleAccessPath: "itemStyle",
  hasSymbolVisual: true,
  getInitialData: function() {
    return helper_exports.createList(this);
  },
  defaultOption: {
    coordinateSystem: "cartesian2d",
    zlevel: 10,
    progressive: 1e5,
    progressiveThreshold: 1e5,
    // Cartesian coordinate system
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // Polar coordinate system
    // polarIndex: 0,
    // Geo coordinate system
    // geoIndex: 0,
    large: false,
    symbol: "circle",
    symbolSize: 10,
    // symbolSize scale when zooming.
    zoomScale: 0,
    // Support source-over, lighter
    blendMode: "source-over",
    itemStyle: {
      opacity: 0.8
    },
    postEffect: {
      enable: false,
      colorCorrection: {
        exposure: 0,
        brightness: 0,
        contrast: 1,
        saturation: 1,
        enable: true
      }
    }
  }
});

// node_modules/echarts-gl/lib/chart/common/GLViewHelper.js
function GLViewHelper(viewGL) {
  this.viewGL = viewGL;
}
GLViewHelper.prototype.reset = function(seriesModel, api) {
  this._updateCamera(api.getWidth(), api.getHeight(), api.getDevicePixelRatio());
  this._viewTransform = create();
  this.updateTransform(seriesModel, api);
};
GLViewHelper.prototype.updateTransform = function(seriesModel, api) {
  var coordinateSystem = seriesModel.coordinateSystem;
  if (coordinateSystem.getRoamTransform) {
    invert(this._viewTransform, coordinateSystem.getRoamTransform());
    this._setCameraTransform(this._viewTransform);
    api.getZr().refresh();
  }
};
GLViewHelper.prototype.dataToPoint = function(coordSys, data, pt) {
  pt = coordSys.dataToPoint(data, null, pt);
  var viewTransform = this._viewTransform;
  if (viewTransform) {
    applyTransform(pt, pt, viewTransform);
  }
};
GLViewHelper.prototype.removeTransformInPoint = function(pt) {
  if (this._viewTransform) {
    applyTransform(pt, pt, this._viewTransform);
  }
  return pt;
};
GLViewHelper.prototype.getZoom = function() {
  if (this._viewTransform) {
    var m = this._viewTransform;
    return 1 / Math.max(Math.sqrt(m[0] * m[0] + m[1] * m[1]), Math.sqrt(m[2] * m[2] + m[3] * m[3]));
  }
  return 1;
};
GLViewHelper.prototype._setCameraTransform = function(m) {
  var camera = this.viewGL.camera;
  camera.position.set(m[4], m[5], 0);
  camera.scale.set(Math.sqrt(m[0] * m[0] + m[1] * m[1]), Math.sqrt(m[2] * m[2] + m[3] * m[3]), 1);
};
GLViewHelper.prototype._updateCamera = function(width, height, dpr) {
  this.viewGL.setViewport(0, 0, width, height, dpr);
  var camera = this.viewGL.camera;
  camera.left = camera.top = 0;
  camera.bottom = height;
  camera.right = width;
  camera.near = 0;
  camera.far = 100;
};
var GLViewHelper_default = GLViewHelper;

// node_modules/echarts-gl/lib/chart/scatterGL/ScatterGLView.js
var ScatterGLView_default = Chart_default.extend({
  type: "scatterGL",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL_default.Node();
    this.viewGL = new ViewGL_default("orthographic");
    this.viewGL.add(this.groupGL);
    this._pointsBuilderList = [];
    this._currentStep = 0;
    this._sizeScale = 1;
    this._glViewHelper = new GLViewHelper_default(this.viewGL);
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    this._glViewHelper.reset(seriesModel, api);
    if (!seriesModel.getData().count()) {
      return;
    }
    var pointsBuilder = this._pointsBuilderList[0];
    if (!pointsBuilder) {
      pointsBuilder = this._pointsBuilderList[0] = new PointsBuilder_default(true, api);
    }
    this._pointsBuilderList.length = 1;
    this.groupGL.add(pointsBuilder.rootNode);
    this._removeTransformInPoints(seriesModel.getData().getLayout("points"));
    pointsBuilder.update(seriesModel, ecModel, api);
    this.viewGL.setPostEffect(seriesModel.getModel("postEffect"), api);
  },
  incrementalPrepareRender: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    this._glViewHelper.reset(seriesModel, api);
    this._currentStep = 0;
    this.viewGL.setPostEffect(seriesModel.getModel("postEffect"), api);
  },
  incrementalRender: function(params, seriesModel, ecModel, api) {
    if (params.end <= params.start) {
      return;
    }
    var pointsBuilder = this._pointsBuilderList[this._currentStep];
    if (!pointsBuilder) {
      pointsBuilder = new PointsBuilder_default(true, api);
      this._pointsBuilderList[this._currentStep] = pointsBuilder;
    }
    this.groupGL.add(pointsBuilder.rootNode);
    this._removeTransformInPoints(seriesModel.getData().getLayout("points"));
    pointsBuilder.setSizeScale(this._sizeScale);
    pointsBuilder.update(seriesModel, ecModel, api, params.start, params.end);
    api.getZr().refresh();
    this._currentStep++;
  },
  updateTransform: function(seriesModel, ecModel, api) {
    if (seriesModel.coordinateSystem.getRoamTransform) {
      this._glViewHelper.updateTransform(seriesModel, api);
      var zoom = this._glViewHelper.getZoom();
      var sizeScale = Math.max((seriesModel.get("zoomScale") || 0) * (zoom - 1) + 1, 0);
      this._sizeScale = sizeScale;
      this._pointsBuilderList.forEach(function(pointsBuilder) {
        pointsBuilder.setSizeScale(sizeScale);
      });
    }
  },
  _removeTransformInPoints: function(points) {
    if (!points) {
      return;
    }
    var pt = [];
    for (var i = 0; i < points.length; i += 2) {
      pt[0] = points[i];
      pt[1] = points[i + 1];
      this._glViewHelper.removeTransformInPoint(pt);
      points[i] = pt[0];
      points[i + 1] = pt[1];
    }
  },
  dispose: function() {
    this.groupGL.removeAll();
    this._pointsBuilderList.forEach(function(pointsBuilder) {
      pointsBuilder.dispose();
    });
  },
  remove: function() {
    this.groupGL.removeAll();
  }
});

// node_modules/echarts-gl/lib/chart/scatterGL/install.js
function install9(registers) {
  registers.registerChartView(ScatterGLView_default);
  registers.registerSeriesModel(ScatterGLSeries_default);
  registers.registerLayout({
    seriesType: "scatterGL",
    reset: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var data = seriesModel.getData();
      var progress;
      if (coordSys) {
        var dims = coordSys.dimensions.map(function(dim) {
          return data.mapDimension(dim);
        }).slice(0, 2);
        var pt = [];
        if (dims.length === 1) {
          progress = function(params) {
            var points = new Float32Array((params.end - params.start) * 2);
            for (var idx = params.start; idx < params.end; idx++) {
              var offset = (idx - params.start) * 2;
              var x = data.get(dims[0], idx);
              var pt2 = coordSys.dataToPoint(x);
              points[offset] = pt2[0];
              points[offset + 1] = pt2[1];
            }
            data.setLayout("points", points);
          };
        } else if (dims.length === 2) {
          progress = function(params) {
            var points = new Float32Array((params.end - params.start) * 2);
            for (var idx = params.start; idx < params.end; idx++) {
              var offset = (idx - params.start) * 2;
              var x = data.get(dims[0], idx);
              var y = data.get(dims[1], idx);
              pt[0] = x;
              pt[1] = y;
              pt = coordSys.dataToPoint(pt);
              points[offset] = pt[0];
              points[offset + 1] = pt[1];
            }
            data.setLayout("points", points);
          };
        }
      }
      return {
        progress
      };
    }
  });
}

// node_modules/echarts/lib/data/helper/linkList.js
var linkList_default = linkSeriesData_default;

// node_modules/echarts-gl/lib/chart/graphGL/createGraphFromNodeEdge.js
function createGraphFromNodeEdge_default(nodes, edges, hostModel, directed, beforeLink) {
  var graph = new Graph_default(directed);
  for (var i = 0; i < nodes.length; i++) {
    graph.addNode(retrieve_default.firstNotNull(
      // Id, name, dataIndex
      nodes[i].id,
      nodes[i].name,
      i
    ), i);
  }
  var linkNameList = [];
  var validEdges = [];
  var linkCount = 0;
  for (var i = 0; i < edges.length; i++) {
    var link = edges[i];
    var source = link.source;
    var target = link.target;
    if (graph.addEdge(source, target, linkCount)) {
      validEdges.push(link);
      linkNameList.push(retrieve_default.firstNotNull(link.id, source + " > " + target));
      linkCount++;
    }
  }
  var nodeData;
  var dimensionNames = helper_exports.createDimensions(nodes, {
    coordDimensions: ["value"]
  });
  nodeData = new SeriesData_default(dimensionNames, hostModel);
  nodeData.initData(nodes);
  var edgeData = new SeriesData_default(["value"], hostModel);
  edgeData.initData(validEdges, linkNameList);
  beforeLink && beforeLink(nodeData, edgeData);
  linkList_default({
    mainData: nodeData,
    struct: graph,
    structAttr: "graph",
    datas: {
      node: nodeData,
      edge: edgeData
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  });
  graph.update();
  return graph;
}

// node_modules/echarts-gl/lib/chart/graphGL/GraphGLSeries.js
var GraphSeries = Series_default.extend({
  type: "series.graphGL",
  visualStyleAccessPath: "itemStyle",
  hasSymbolVisual: true,
  init: function(option) {
    GraphSeries.superApply(this, "init", arguments);
    this.legendDataProvider = function() {
      return this._categoriesData;
    };
    this._updateCategoriesData();
  },
  mergeOption: function(option) {
    GraphSeries.superApply(this, "mergeOption", arguments);
    this._updateCategoriesData();
  },
  getFormattedLabel: function(dataIndex, status, dataType, dimIndex) {
    var text = format_default.getFormattedLabel(this, dataIndex, status, dataType, dimIndex);
    if (text == null) {
      var data = this.getData();
      var lastDim = data.dimensions[data.dimensions.length - 1];
      text = data.get(lastDim, dataIndex);
    }
    return text;
  },
  getInitialData: function(option, ecModel) {
    var edges = option.edges || option.links || [];
    var nodes = option.data || option.nodes || [];
    var self2 = this;
    if (nodes && edges) {
      return createGraphFromNodeEdge_default(nodes, edges, this, true, beforeLink).data;
    }
    function beforeLink(nodeData, edgeData) {
      nodeData.wrapMethod("getItemModel", function(model) {
        const categoriesModels = self2._categoriesModels;
        const categoryIdx = model.getShallow("category");
        const categoryModel = categoriesModels[categoryIdx];
        if (categoryModel) {
          categoryModel.parentModel = model.parentModel;
          model.parentModel = categoryModel;
        }
        return model;
      });
      const oldGetModel = ecModel.getModel([]).getModel;
      function newGetModel(path, parentModel) {
        const model = oldGetModel.call(this, path, parentModel);
        model.resolveParentPath = resolveParentPath;
        return model;
      }
      edgeData.wrapMethod("getItemModel", function(model) {
        model.resolveParentPath = resolveParentPath;
        model.getModel = newGetModel;
        return model;
      });
      function resolveParentPath(pathArr) {
        if (pathArr && (pathArr[0] === "label" || pathArr[1] === "label")) {
          const newPathArr = pathArr.slice();
          if (pathArr[0] === "label") {
            newPathArr[0] = "edgeLabel";
          } else if (pathArr[1] === "label") {
            newPathArr[1] = "edgeLabel";
          }
          return newPathArr;
        }
        return pathArr;
      }
    }
  },
  /**
   * @return {module:echarts/data/Graph}
   */
  getGraph: function() {
    return this.getData().graph;
  },
  /**
   * @return {module:echarts/data/List}
   */
  getEdgeData: function() {
    return this.getGraph().edgeData;
  },
  /**
   * @return {module:echarts/data/List}
   */
  getCategoriesData: function() {
    return this._categoriesData;
  },
  /**
   * @override
   */
  formatTooltip: function(dataIndex, multipleSeries, dataType) {
    if (dataType === "edge") {
      var nodeData = this.getData();
      var params = this.getDataParams(dataIndex, dataType);
      var edge = nodeData.graph.getEdgeByIndex(dataIndex);
      var sourceName = nodeData.getName(edge.node1.dataIndex);
      var targetName = nodeData.getName(edge.node2.dataIndex);
      var html = [];
      sourceName != null && html.push(sourceName);
      targetName != null && html.push(targetName);
      html = format_exports.encodeHTML(html.join(" > "));
      if (params.value) {
        html += " : " + format_exports.encodeHTML(params.value);
      }
      return html;
    } else {
      return GraphSeries.superApply(this, "formatTooltip", arguments);
    }
  },
  _updateCategoriesData: function() {
    var categories = (this.option.categories || []).map(function(category) {
      return category.value != null ? category : Object.assign({
        value: 0
      }, category);
    });
    var categoriesData = new SeriesData_default(["value"], this);
    categoriesData.initData(categories);
    this._categoriesData = categoriesData;
    this._categoriesModels = categoriesData.mapArray(function(idx) {
      return categoriesData.getItemModel(idx, true);
    });
  },
  setView: function(payload) {
    if (payload.zoom != null) {
      this.option.zoom = payload.zoom;
    }
    if (payload.offset != null) {
      this.option.offset = payload.offset;
    }
  },
  setNodePosition: function(points) {
    for (var i = 0; i < points.length / 2; i++) {
      var x = points[i * 2];
      var y = points[i * 2 + 1];
      var opt = this.getData().getRawDataItem(i);
      opt.x = x;
      opt.y = y;
    }
  },
  isAnimationEnabled: function() {
    return GraphSeries.superCall(this, "isAnimationEnabled") && !(this.get("layout") === "force" && this.get("force.layoutAnimation"));
  },
  defaultOption: {
    zlevel: 10,
    z: 2,
    legendHoverLink: true,
    // Only support forceAtlas2
    layout: "forceAtlas2",
    // Configuration of force directed layout
    forceAtlas2: {
      initLayout: null,
      GPU: true,
      steps: 1,
      // barnesHutOptimize
      // Maxp layout steps.
      maxSteps: 1e3,
      repulsionByDegree: true,
      linLogMode: false,
      strongGravityMode: false,
      gravity: 1,
      // scaling: 1.0,
      edgeWeightInfluence: 1,
      // Edge weight range.
      edgeWeight: [1, 4],
      // Node weight range.
      nodeWeight: [1, 4],
      // jitterTolerence: 0.1,
      preventOverlap: false,
      gravityCenter: null
    },
    focusNodeAdjacency: true,
    focusNodeAdjacencyOn: "mouseover",
    left: "center",
    top: "center",
    // right: null,
    // bottom: null,
    // width: '80%',
    // height: '80%',
    symbol: "circle",
    symbolSize: 5,
    roam: false,
    // Default on center of graph
    center: null,
    zoom: 1,
    // categories: [],
    // data: []
    // Or
    // nodes: []
    //
    // links: []
    // Or
    // edges: []
    label: {
      show: false,
      formatter: "{b}",
      position: "right",
      distance: 5,
      textStyle: {
        fontSize: 14
      }
    },
    itemStyle: {},
    lineStyle: {
      color: "#aaa",
      width: 1,
      opacity: 0.5
    },
    emphasis: {
      label: {
        show: true
      }
    },
    animation: false
  }
});
var GraphGLSeries_default = GraphSeries;

// node_modules/echarts-gl/lib/util/geometry/Lines2D.js
var vec22 = glmatrix_default.vec2;
var sampleLinePoints = [[0, 0], [1, 1]];
var LinesGeometry = Geometry_default.extend(
  function() {
    return {
      segmentScale: 4,
      dynamic: true,
      /**
       * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH
       */
      useNativeLine: true,
      attributes: {
        position: new Geometry_default.Attribute("position", "float", 2, "POSITION"),
        normal: new Geometry_default.Attribute("normal", "float", 2),
        offset: new Geometry_default.Attribute("offset", "float", 1),
        color: new Geometry_default.Attribute("color", "float", 4, "COLOR")
      }
    };
  },
  /** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */
  {
    /**
     * Reset offset
     */
    resetOffset: function() {
      this._vertexOffset = 0;
      this._faceOffset = 0;
      this._itemVertexOffsets = [];
    },
    /**
     * @param {number} nVertex
     */
    setVertexCount: function(nVertex) {
      var attributes = this.attributes;
      if (this.vertexCount !== nVertex) {
        attributes.position.init(nVertex);
        attributes.color.init(nVertex);
        if (!this.useNativeLine) {
          attributes.offset.init(nVertex);
          attributes.normal.init(nVertex);
        }
        if (nVertex > 65535) {
          if (this.indices instanceof Uint16Array) {
            this.indices = new Uint32Array(this.indices);
          }
        } else {
          if (this.indices instanceof Uint32Array) {
            this.indices = new Uint16Array(this.indices);
          }
        }
      }
    },
    /**
     * @param {number} nTriangle
     */
    setTriangleCount: function(nTriangle) {
      if (this.triangleCount !== nTriangle) {
        if (nTriangle === 0) {
          this.indices = null;
        } else {
          this.indices = this.vertexCount > 65535 ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);
        }
      }
    },
    _getCubicCurveApproxStep: function(p0, p1, p2, p3) {
      var len = vec22.dist(p0, p1) + vec22.dist(p2, p1) + vec22.dist(p3, p2);
      var step = 1 / (len + 1) * this.segmentScale;
      return step;
    },
    /**
     * Get vertex count of cubic curve
     * @param {Array.<number>} p0
     * @param {Array.<number>} p1
     * @param {Array.<number>} p2
     * @param {Array.<number>} p3
     * @return number
     */
    getCubicCurveVertexCount: function(p0, p1, p2, p3) {
      var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);
      var segCount = Math.ceil(1 / step);
      if (!this.useNativeLine) {
        return segCount * 2 + 2;
      } else {
        return segCount * 2;
      }
    },
    /**
     * Get face count of cubic curve
     * @param {Array.<number>} p0
     * @param {Array.<number>} p1
     * @param {Array.<number>} p2
     * @param {Array.<number>} p3
     * @return number
     */
    getCubicCurveTriangleCount: function(p0, p1, p2, p3) {
      var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);
      var segCount = Math.ceil(1 / step);
      if (!this.useNativeLine) {
        return segCount * 2;
      } else {
        return 0;
      }
    },
    /**
     * Get vertex count of line
     * @return {number}
     */
    getLineVertexCount: function() {
      return this.getPolylineVertexCount(sampleLinePoints);
    },
    /**
     * Get face count of line
     * @return {number}
     */
    getLineTriangleCount: function() {
      return this.getPolylineTriangleCount(sampleLinePoints);
    },
    /**
     * Get how many vertices will polyline take.
     * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.
     * @return {number}
     */
    getPolylineVertexCount: function(points) {
      var pointsLen;
      if (typeof points === "number") {
        pointsLen = points;
      } else {
        var is2DArray = typeof points[0] !== "number";
        pointsLen = is2DArray ? points.length : points.length / 2;
      }
      return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;
    },
    /**
     * Get how many triangles will polyline take.
     * @type {number|Array} points Can be a 1d/2d list of points, or a number of points amount.
     * @return {number}
     */
    getPolylineTriangleCount: function(points) {
      var pointsLen;
      if (typeof points === "number") {
        pointsLen = points;
      } else {
        var is2DArray = typeof points[0] !== "number";
        pointsLen = is2DArray ? points.length : points.length / 2;
      }
      return !this.useNativeLine ? (pointsLen - 1) * 2 : 0;
    },
    /**
     * Add a cubic curve
     * @param {Array.<number>} p0
     * @param {Array.<number>} p1
     * @param {Array.<number>} p2
     * @param {Array.<number>} p3
     * @param {Array.<number>} color
     * @param {number} [lineWidth=1]
     */
    addCubicCurve: function(p0, p1, p2, p3, color, lineWidth) {
      if (lineWidth == null) {
        lineWidth = 1;
      }
      var x0 = p0[0], y0 = p0[1];
      var x1 = p1[0], y1 = p1[1];
      var x2 = p2[0], y2 = p2[1];
      var x3 = p3[0], y3 = p3[1];
      var step = this._getCubicCurveApproxStep(p0, p1, p2, p3);
      var step2 = step * step;
      var step3 = step2 * step;
      var pre1 = 3 * step;
      var pre2 = 3 * step2;
      var pre4 = 6 * step2;
      var pre5 = 6 * step3;
      var tmp1x = x0 - x1 * 2 + x2;
      var tmp1y = y0 - y1 * 2 + y2;
      var tmp2x = (x1 - x2) * 3 - x0 + x3;
      var tmp2y = (y1 - y2) * 3 - y0 + y3;
      var fx = x0;
      var fy = y0;
      var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;
      var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;
      var ddfx = tmp1x * pre4 + tmp2x * pre5;
      var ddfy = tmp1y * pre4 + tmp2y * pre5;
      var dddfx = tmp2x * pre5;
      var dddfy = tmp2y * pre5;
      var t = 0;
      var k = 0;
      var segCount = Math.ceil(1 / step);
      var points = new Float32Array((segCount + 1) * 3);
      var points = [];
      var offset = 0;
      for (var k = 0; k < segCount + 1; k++) {
        points[offset++] = fx;
        points[offset++] = fy;
        fx += dfx;
        fy += dfy;
        dfx += ddfx;
        dfy += ddfy;
        ddfx += dddfx;
        ddfy += dddfy;
        t += step;
        if (t > 1) {
          fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);
          fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);
        }
      }
      this.addPolyline(points, color, lineWidth);
    },
    /**
     * Add a straight line
     * @param {Array.<number>} p0
     * @param {Array.<number>} p1
     * @param {Array.<number>} color
     * @param {number} [lineWidth=1]
     */
    addLine: function(p0, p1, color, lineWidth) {
      this.addPolyline([p0, p1], color, lineWidth);
    },
    /**
     * Add a straight line
     * @param {Array.<Array> | Array.<number>} points
     * @param {Array.<number> | Array.<Array>} color
     * @param {number} [lineWidth=1]
     * @param {number} [arrayOffset=0]
     * @param {number} [pointsCount] Default to be amount of points in the first argument
     */
    addPolyline: function() {
      var dirA = vec22.create();
      var dirB = vec22.create();
      var normal2 = vec22.create();
      var tangent2 = vec22.create();
      var point = [], nextPoint = [], prevPoint = [];
      return function(points, color, lineWidth, arrayOffset, pointsCount) {
        if (!points.length) {
          return;
        }
        var is2DArray = typeof points[0] !== "number";
        if (pointsCount == null) {
          pointsCount = is2DArray ? points.length : points.length / 2;
        }
        if (pointsCount < 2) {
          return;
        }
        if (arrayOffset == null) {
          arrayOffset = 0;
        }
        if (lineWidth == null) {
          lineWidth = 1;
        }
        this._itemVertexOffsets.push(this._vertexOffset);
        var notSharingColor = is2DArray ? typeof color[0] !== "number" : color.length / 4 === pointsCount;
        var positionAttr = this.attributes.position;
        var colorAttr = this.attributes.color;
        var offsetAttr = this.attributes.offset;
        var normalAttr = this.attributes.normal;
        var indices = this.indices;
        var vertexOffset = this._vertexOffset;
        var pointColor;
        for (var k = 0; k < pointsCount; k++) {
          if (is2DArray) {
            point = points[k + arrayOffset];
            if (notSharingColor) {
              pointColor = color[k + arrayOffset];
            } else {
              pointColor = color;
            }
          } else {
            var k2 = k * 2 + arrayOffset;
            point = point || [];
            point[0] = points[k2];
            point[1] = points[k2 + 1];
            if (notSharingColor) {
              var k4 = k * 4 + arrayOffset;
              pointColor = pointColor || [];
              pointColor[0] = color[k4];
              pointColor[1] = color[k4 + 1];
              pointColor[2] = color[k4 + 2];
              pointColor[3] = color[k4 + 3];
            } else {
              pointColor = color;
            }
          }
          if (!this.useNativeLine) {
            var offset;
            if (k < pointsCount - 1) {
              if (is2DArray) {
                vec22.copy(nextPoint, points[k + 1]);
              } else {
                var k2 = (k + 1) * 2 + arrayOffset;
                nextPoint = nextPoint || [];
                nextPoint[0] = points[k2];
                nextPoint[1] = points[k2 + 1];
              }
              if (k > 0) {
                vec22.sub(dirA, point, prevPoint);
                vec22.sub(dirB, nextPoint, point);
                vec22.normalize(dirA, dirA);
                vec22.normalize(dirB, dirB);
                vec22.add(tangent2, dirA, dirB);
                vec22.normalize(tangent2, tangent2);
                var miter = lineWidth / 2 * Math.min(1 / vec22.dot(dirA, tangent2), 2);
                normal2[0] = -tangent2[1];
                normal2[1] = tangent2[0];
                offset = miter;
              } else {
                vec22.sub(dirA, nextPoint, point);
                vec22.normalize(dirA, dirA);
                normal2[0] = -dirA[1];
                normal2[1] = dirA[0];
                offset = lineWidth / 2;
              }
            } else {
              vec22.sub(dirA, point, prevPoint);
              vec22.normalize(dirA, dirA);
              normal2[0] = -dirA[1];
              normal2[1] = dirA[0];
              offset = lineWidth / 2;
            }
            normalAttr.set(vertexOffset, normal2);
            normalAttr.set(vertexOffset + 1, normal2);
            offsetAttr.set(vertexOffset, offset);
            offsetAttr.set(vertexOffset + 1, -offset);
            vec22.copy(prevPoint, point);
            positionAttr.set(vertexOffset, point);
            positionAttr.set(vertexOffset + 1, point);
            colorAttr.set(vertexOffset, pointColor);
            colorAttr.set(vertexOffset + 1, pointColor);
            vertexOffset += 2;
          } else {
            if (k > 1) {
              positionAttr.copy(vertexOffset, vertexOffset - 1);
              colorAttr.copy(vertexOffset, vertexOffset - 1);
              vertexOffset++;
            }
          }
          if (!this.useNativeLine) {
            if (k > 0) {
              var idx3 = this._faceOffset * 3;
              var indices = this.indices;
              indices[idx3] = vertexOffset - 4;
              indices[idx3 + 1] = vertexOffset - 3;
              indices[idx3 + 2] = vertexOffset - 2;
              indices[idx3 + 3] = vertexOffset - 3;
              indices[idx3 + 4] = vertexOffset - 1;
              indices[idx3 + 5] = vertexOffset - 2;
              this._faceOffset += 2;
            }
          } else {
            colorAttr.set(vertexOffset, pointColor);
            positionAttr.set(vertexOffset, point);
            vertexOffset++;
          }
        }
        this._vertexOffset = vertexOffset;
      };
    }(),
    /**
     * Set color of single line.
     */
    setItemColor: function(idx, color) {
      var startOffset = this._itemVertexOffsets[idx];
      var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;
      for (var i = startOffset; i < endOffset; i++) {
        this.attributes.color.set(i, color);
      }
      this.dirty("color");
    }
  }
);
util_exports.defaults(LinesGeometry.prototype, dynamicConvertMixin_default);
var Lines2D_default = LinesGeometry;

// node_modules/echarts-gl/lib/chart/graphGL/forceAtlas2.glsl.js
var forceAtlas2_glsl_default = "@export ecgl.forceAtlas2.updateNodeRepulsion\n\n#define NODE_COUNT 0\n\nuniform sampler2D positionTex;\n\nuniform vec2 textureSize;\nuniform float gravity;\nuniform float scaling;\nuniform vec2 gravityCenter;\n\nuniform bool strongGravityMode;\nuniform bool preventOverlap;\n\nvarying vec2 v_Texcoord;\n\nvoid main() {\n\n vec4 n0 = texture2D(positionTex, v_Texcoord);\n\n vec2 force = vec2(0.0);\n for (int i = 0; i < NODE_COUNT; i++) {\n vec2 uv = vec2(\n mod(float(i), textureSize.x) / (textureSize.x - 1.0),\n floor(float(i) / textureSize.x) / (textureSize.y - 1.0)\n );\n vec4 n1 = texture2D(positionTex, uv);\n\n vec2 dir = n0.xy - n1.xy;\n float d2 = dot(dir, dir);\n\n if (d2 > 0.0) {\n float factor = 0.0;\n if (preventOverlap) {\n float d = sqrt(d2);\n d = d - n0.w - n1.w;\n if (d > 0.0) {\n factor = scaling * n0.z * n1.z / (d * d);\n }\n else if (d < 0.0) {\n factor = scaling * 100.0 * n0.z * n1.z;\n }\n }\n else {\n factor = scaling * n0.z * n1.z / d2;\n }\n force += dir * factor;\n }\n }\n\n vec2 dir = gravityCenter - n0.xy;\n float d = 1.0;\n if (!strongGravityMode) {\n d = length(dir);\n }\n\n force += dir * n0.z * gravity / (d + 1.0);\n\n gl_FragColor = vec4(force, 0.0, 1.0);\n}\n@end\n\n@export ecgl.forceAtlas2.updateEdgeAttraction.vertex\n\nattribute vec2 node1;\nattribute vec2 node2;\nattribute float weight;\n\nuniform sampler2D positionTex;\nuniform float edgeWeightInfluence;\nuniform bool preventOverlap;\nuniform bool linLogMode;\n\nuniform vec2 windowSize: WINDOW_SIZE;\n\nvarying vec2 v_Force;\n\nvoid main() {\n\n vec4 n0 = texture2D(positionTex, node1);\n vec4 n1 = texture2D(positionTex, node2);\n\n vec2 dir = n1.xy - n0.xy;\n float d = length(dir);\n float w;\n if (edgeWeightInfluence == 0.0) {\n w = 1.0;\n }\n else if (edgeWeightInfluence == 1.0) {\n w = weight;\n }\n else {\n w = pow(weight, edgeWeightInfluence);\n }\n vec2 offset = vec2(1.0 / windowSize.x, 1.0 / windowSize.y);\n vec2 scale = vec2((windowSize.x - 1.0) / windowSize.x, (windowSize.y - 1.0) / windowSize.y);\n vec2 pos = node1 * scale * 2.0 - 1.0;\n gl_Position = vec4(pos + offset, 0.0, 1.0);\n gl_PointSize = 1.0;\n\n float factor;\n if (preventOverlap) {\n d = d - n1.w - n0.w;\n }\n if (d <= 0.0) {\n v_Force = vec2(0.0);\n return;\n }\n\n if (linLogMode) {\n factor = w * log(d) / d;\n }\n else {\n factor = w;\n }\n v_Force = dir * factor;\n}\n@end\n\n@export ecgl.forceAtlas2.updateEdgeAttraction.fragment\n\nvarying vec2 v_Force;\n\nvoid main() {\n gl_FragColor = vec4(v_Force, 0.0, 0.0);\n}\n@end\n\n@export ecgl.forceAtlas2.calcWeightedSum.vertex\n\nattribute vec2 node;\n\nvarying vec2 v_NodeUv;\n\nvoid main() {\n\n v_NodeUv = node;\n gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n gl_PointSize = 1.0;\n}\n@end\n\n@export ecgl.forceAtlas2.calcWeightedSum.fragment\n\nvarying vec2 v_NodeUv;\n\nuniform sampler2D positionTex;\nuniform sampler2D forceTex;\nuniform sampler2D forcePrevTex;\n\nvoid main() {\n vec2 force = texture2D(forceTex, v_NodeUv).rg;\n vec2 forcePrev = texture2D(forcePrevTex, v_NodeUv).rg;\n\n float mass = texture2D(positionTex, v_NodeUv).z;\n float swing = length(force - forcePrev) * mass;\n float traction = length(force + forcePrev) * 0.5 * mass;\n\n gl_FragColor = vec4(swing, traction, 0.0, 0.0);\n}\n@end\n\n@export ecgl.forceAtlas2.calcGlobalSpeed\n\nuniform sampler2D globalSpeedPrevTex;\nuniform sampler2D weightedSumTex;\nuniform float jitterTolerence;\n\nvoid main() {\n vec2 weightedSum = texture2D(weightedSumTex, vec2(0.5)).xy;\n float prevGlobalSpeed = texture2D(globalSpeedPrevTex, vec2(0.5)).x;\n float globalSpeed = jitterTolerence * jitterTolerence\n * weightedSum.y / weightedSum.x;\n if (prevGlobalSpeed > 0.0) {\n globalSpeed = min(globalSpeed / prevGlobalSpeed, 1.5) * prevGlobalSpeed;\n }\n gl_FragColor = vec4(globalSpeed, 0.0, 0.0, 1.0);\n}\n@end\n\n@export ecgl.forceAtlas2.updatePosition\n\nuniform sampler2D forceTex;\nuniform sampler2D forcePrevTex;\nuniform sampler2D positionTex;\nuniform sampler2D globalSpeedTex;\n\nvarying vec2 v_Texcoord;\n\nvoid main() {\n vec2 force = texture2D(forceTex, v_Texcoord).xy;\n vec2 forcePrev = texture2D(forcePrevTex, v_Texcoord).xy;\n vec4 node = texture2D(positionTex, v_Texcoord);\n\n float globalSpeed = texture2D(globalSpeedTex, vec2(0.5)).r;\n float swing = length(force - forcePrev);\n float speed = 0.1 * globalSpeed / (0.1 + globalSpeed * sqrt(swing));\n\n float df = length(force);\n if (df > 0.0) {\n speed = min(df * speed, 10.0) / df;\n\n gl_FragColor = vec4(node.xy + speed * force, node.zw);\n }\n else {\n gl_FragColor = node;\n }\n}\n@end\n\n@export ecgl.forceAtlas2.edges.vertex\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec2 node;\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n\nuniform sampler2D positionTex;\n\nvoid main()\n{\n gl_Position = worldViewProjection * vec4(\n texture2D(positionTex, node).xy, -10.0, 1.0\n );\n v_Color = a_Color;\n}\n@end\n\n@export ecgl.forceAtlas2.edges.fragment\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nvarying vec4 v_Color;\nvoid main() {\n gl_FragColor = color * v_Color;\n}\n@end";

// node_modules/echarts-gl/lib/chart/graphGL/ForceAtlas2GPU.js
graphicGL_default.Shader.import(forceAtlas2_glsl_default);
var defaultConfigs = {
  repulsionByDegree: true,
  linLogMode: false,
  strongGravityMode: false,
  gravity: 1,
  scaling: 1,
  edgeWeightInfluence: 1,
  jitterTolerence: 0.1,
  preventOverlap: false,
  dissuadeHubs: false,
  gravityCenter: null
};
function ForceAtlas2GPU(options) {
  var textureOpt = {
    type: graphicGL_default.Texture.FLOAT,
    minFilter: graphicGL_default.Texture.NEAREST,
    magFilter: graphicGL_default.Texture.NEAREST
  };
  this._positionSourceTex = new graphicGL_default.Texture2D(textureOpt);
  this._positionSourceTex.flipY = false;
  this._positionTex = new graphicGL_default.Texture2D(textureOpt);
  this._positionPrevTex = new graphicGL_default.Texture2D(textureOpt);
  this._forceTex = new graphicGL_default.Texture2D(textureOpt);
  this._forcePrevTex = new graphicGL_default.Texture2D(textureOpt);
  this._weightedSumTex = new graphicGL_default.Texture2D(textureOpt);
  this._weightedSumTex.width = this._weightedSumTex.height = 1;
  this._globalSpeedTex = new graphicGL_default.Texture2D(textureOpt);
  this._globalSpeedPrevTex = new graphicGL_default.Texture2D(textureOpt);
  this._globalSpeedTex.width = this._globalSpeedTex.height = 1;
  this._globalSpeedPrevTex.width = this._globalSpeedPrevTex.height = 1;
  this._nodeRepulsionPass = new Pass_default({
    fragment: graphicGL_default.Shader.source("ecgl.forceAtlas2.updateNodeRepulsion")
  });
  this._positionPass = new Pass_default({
    fragment: graphicGL_default.Shader.source("ecgl.forceAtlas2.updatePosition")
  });
  this._globalSpeedPass = new Pass_default({
    fragment: graphicGL_default.Shader.source("ecgl.forceAtlas2.calcGlobalSpeed")
  });
  this._copyPass = new Pass_default({
    fragment: graphicGL_default.Shader.source("clay.compositor.output")
  });
  var additiveBlend = function(gl) {
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ONE);
  };
  this._edgeForceMesh = new graphicGL_default.Mesh({
    geometry: new graphicGL_default.Geometry({
      attributes: {
        node1: new graphicGL_default.Geometry.Attribute("node1", "float", 2),
        node2: new graphicGL_default.Geometry.Attribute("node2", "float", 2),
        weight: new graphicGL_default.Geometry.Attribute("weight", "float", 1)
      },
      dynamic: true,
      mainAttribute: "node1"
    }),
    material: new graphicGL_default.Material({
      transparent: true,
      shader: graphicGL_default.createShader("ecgl.forceAtlas2.updateEdgeAttraction"),
      blend: additiveBlend,
      depthMask: false,
      depthText: false
    }),
    mode: graphicGL_default.Mesh.POINTS
  });
  this._weightedSumMesh = new graphicGL_default.Mesh({
    geometry: new graphicGL_default.Geometry({
      attributes: {
        node: new graphicGL_default.Geometry.Attribute("node", "float", 2)
      },
      dynamic: true,
      mainAttribute: "node"
    }),
    material: new graphicGL_default.Material({
      transparent: true,
      shader: graphicGL_default.createShader("ecgl.forceAtlas2.calcWeightedSum"),
      blend: additiveBlend,
      depthMask: false,
      depthText: false
    }),
    mode: graphicGL_default.Mesh.POINTS
  });
  this._framebuffer = new FrameBuffer_default({
    depthBuffer: false
  });
  this._dummyCamera = new graphicGL_default.OrthographicCamera({
    left: -1,
    right: 1,
    top: 1,
    bottom: -1,
    near: 0,
    far: 100
  });
  this._globalSpeed = 0;
}
ForceAtlas2GPU.prototype.updateOption = function(options) {
  for (var name in defaultConfigs) {
    this[name] = defaultConfigs[name];
  }
  var nNodes = this._nodes.length;
  if (nNodes > 5e4) {
    this.jitterTolerence = 10;
  } else if (nNodes > 5e3) {
    this.jitterTolerence = 1;
  } else {
    this.jitterTolerence = 0.1;
  }
  if (nNodes > 100) {
    this.scaling = 2;
  } else {
    this.scaling = 10;
  }
  if (options) {
    for (var name in defaultConfigs) {
      if (options[name] != null) {
        this[name] = options[name];
      }
    }
  }
  if (this.repulsionByDegree) {
    var positionBuffer = this._positionSourceTex.pixels;
    for (var i = 0; i < this._nodes.length; i++) {
      positionBuffer[i * 4 + 2] = (this._nodes[i].degree || 0) + 1;
    }
  }
};
ForceAtlas2GPU.prototype._updateGravityCenter = function(options) {
  var nodes = this._nodes;
  var edges = this._edges;
  if (!this.gravityCenter) {
    var min = [Infinity, Infinity];
    var max = [-Infinity, -Infinity];
    for (var i = 0; i < nodes.length; i++) {
      min[0] = Math.min(nodes[i].x, min[0]);
      min[1] = Math.min(nodes[i].y, min[1]);
      max[0] = Math.max(nodes[i].x, max[0]);
      max[1] = Math.max(nodes[i].y, max[1]);
    }
    this._gravityCenter = [(min[0] + max[0]) * 0.5, (min[1] + max[1]) * 0.5];
  } else {
    this._gravityCenter = this.gravityCenter;
  }
  for (var i = 0; i < edges.length; i++) {
    var node1 = edges[i].node1;
    var node2 = edges[i].node2;
    nodes[node1].degree = (nodes[node1].degree || 0) + 1;
    nodes[node2].degree = (nodes[node2].degree || 0) + 1;
  }
};
ForceAtlas2GPU.prototype.initData = function(nodes, edges) {
  this._nodes = nodes;
  this._edges = edges;
  this._updateGravityCenter();
  var textureWidth = Math.ceil(Math.sqrt(nodes.length));
  var textureHeight = textureWidth;
  var positionBuffer = new Float32Array(textureWidth * textureHeight * 4);
  this._resize(textureWidth, textureHeight);
  var offset = 0;
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    positionBuffer[offset++] = node.x || 0;
    positionBuffer[offset++] = node.y || 0;
    positionBuffer[offset++] = node.mass || 1;
    positionBuffer[offset++] = node.size || 1;
  }
  this._positionSourceTex.pixels = positionBuffer;
  var edgeGeometry = this._edgeForceMesh.geometry;
  var edgeLen = edges.length;
  edgeGeometry.attributes.node1.init(edgeLen * 2);
  edgeGeometry.attributes.node2.init(edgeLen * 2);
  edgeGeometry.attributes.weight.init(edgeLen * 2);
  var uv = [];
  for (var i = 0; i < edges.length; i++) {
    var attributes = edgeGeometry.attributes;
    var weight = edges[i].weight;
    if (weight == null) {
      weight = 1;
    }
    attributes.node1.set(i, this.getNodeUV(edges[i].node1, uv));
    attributes.node2.set(i, this.getNodeUV(edges[i].node2, uv));
    attributes.weight.set(i, weight);
    attributes.node1.set(i + edgeLen, this.getNodeUV(edges[i].node2, uv));
    attributes.node2.set(i + edgeLen, this.getNodeUV(edges[i].node1, uv));
    attributes.weight.set(i + edgeLen, weight);
  }
  var weigtedSumGeo = this._weightedSumMesh.geometry;
  weigtedSumGeo.attributes.node.init(nodes.length);
  for (var i = 0; i < nodes.length; i++) {
    weigtedSumGeo.attributes.node.set(i, this.getNodeUV(i, uv));
  }
  edgeGeometry.dirty();
  weigtedSumGeo.dirty();
  this._nodeRepulsionPass.material.define("fragment", "NODE_COUNT", nodes.length);
  this._nodeRepulsionPass.material.setUniform("textureSize", [textureWidth, textureHeight]);
  this._inited = false;
  this._frame = 0;
};
ForceAtlas2GPU.prototype.getNodes = function() {
  return this._nodes;
};
ForceAtlas2GPU.prototype.getEdges = function() {
  return this._edges;
};
ForceAtlas2GPU.prototype.step = function(renderer) {
  if (!this._inited) {
    this._initFromSource(renderer);
    this._inited = true;
  }
  this._frame++;
  this._framebuffer.attach(this._forceTex);
  this._framebuffer.bind(renderer);
  var nodeRepulsionPass = this._nodeRepulsionPass;
  nodeRepulsionPass.setUniform("strongGravityMode", this.strongGravityMode);
  nodeRepulsionPass.setUniform("gravity", this.gravity);
  nodeRepulsionPass.setUniform("gravityCenter", this._gravityCenter);
  nodeRepulsionPass.setUniform("scaling", this.scaling);
  nodeRepulsionPass.setUniform("preventOverlap", this.preventOverlap);
  nodeRepulsionPass.setUniform("positionTex", this._positionPrevTex);
  nodeRepulsionPass.render(renderer);
  var edgeForceMesh = this._edgeForceMesh;
  edgeForceMesh.material.set("linLogMode", this.linLogMode);
  edgeForceMesh.material.set("edgeWeightInfluence", this.edgeWeightInfluence);
  edgeForceMesh.material.set("preventOverlap", this.preventOverlap);
  edgeForceMesh.material.set("positionTex", this._positionPrevTex);
  renderer.gl.enable(renderer.gl.BLEND);
  renderer.renderPass([edgeForceMesh], this._dummyCamera);
  this._framebuffer.attach(this._weightedSumTex);
  renderer.gl.clearColor(0, 0, 0, 0);
  renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT);
  renderer.gl.enable(renderer.gl.BLEND);
  var weightedSumMesh = this._weightedSumMesh;
  weightedSumMesh.material.set("positionTex", this._positionPrevTex);
  weightedSumMesh.material.set("forceTex", this._forceTex);
  weightedSumMesh.material.set("forcePrevTex", this._forcePrevTex);
  renderer.renderPass([weightedSumMesh], this._dummyCamera);
  this._framebuffer.attach(this._globalSpeedTex);
  var globalSpeedPass = this._globalSpeedPass;
  globalSpeedPass.setUniform("globalSpeedPrevTex", this._globalSpeedPrevTex);
  globalSpeedPass.setUniform("weightedSumTex", this._weightedSumTex);
  globalSpeedPass.setUniform("jitterTolerence", this.jitterTolerence);
  renderer.gl.disable(renderer.gl.BLEND);
  globalSpeedPass.render(renderer);
  var positionPass = this._positionPass;
  this._framebuffer.attach(this._positionTex);
  positionPass.setUniform("globalSpeedTex", this._globalSpeedTex);
  positionPass.setUniform("positionTex", this._positionPrevTex);
  positionPass.setUniform("forceTex", this._forceTex);
  positionPass.setUniform("forcePrevTex", this._forcePrevTex);
  positionPass.render(renderer);
  this._framebuffer.unbind(renderer);
  this._swapTexture();
};
ForceAtlas2GPU.prototype.update = function(renderer, steps, cb) {
  if (steps == null) {
    steps = 1;
  }
  steps = Math.max(steps, 1);
  for (var i = 0; i < steps; i++) {
    this.step(renderer);
  }
  cb && cb();
};
ForceAtlas2GPU.prototype.getNodePositionTexture = function() {
  return this._inited ? this._positionPrevTex : this._positionSourceTex;
};
ForceAtlas2GPU.prototype.getNodeUV = function(nodeIndex, uv) {
  uv = uv || [];
  var textureWidth = this._positionTex.width;
  var textureHeight = this._positionTex.height;
  uv[0] = nodeIndex % textureWidth / (textureWidth - 1);
  uv[1] = Math.floor(nodeIndex / textureWidth) / (textureHeight - 1) || 0;
  return uv;
};
ForceAtlas2GPU.prototype.getNodePosition = function(renderer, out) {
  var positionArr = this._positionArr;
  var width = this._positionTex.width;
  var height = this._positionTex.height;
  var size = width * height;
  if (!positionArr || positionArr.length !== size * 4) {
    positionArr = this._positionArr = new Float32Array(size * 4);
  }
  this._framebuffer.bind(renderer);
  this._framebuffer.attach(this._positionPrevTex);
  renderer.gl.readPixels(0, 0, width, height, renderer.gl.RGBA, renderer.gl.FLOAT, positionArr);
  this._framebuffer.unbind(renderer);
  if (!out) {
    out = new Float32Array(this._nodes.length * 2);
  }
  for (var i = 0; i < this._nodes.length; i++) {
    out[i * 2] = positionArr[i * 4];
    out[i * 2 + 1] = positionArr[i * 4 + 1];
  }
  return out;
};
ForceAtlas2GPU.prototype.getTextureData = function(renderer, textureName) {
  var tex = this["_" + textureName + "Tex"];
  var width = tex.width;
  var height = tex.height;
  this._framebuffer.bind(renderer);
  this._framebuffer.attach(tex);
  var arr = new Float32Array(width * height * 4);
  renderer.gl.readPixels(0, 0, width, height, renderer.gl.RGBA, renderer.gl.FLOAT, arr);
  this._framebuffer.unbind(renderer);
  return arr;
};
ForceAtlas2GPU.prototype.getTextureSize = function() {
  return {
    width: this._positionTex.width,
    height: this._positionTex.height
  };
};
ForceAtlas2GPU.prototype.isFinished = function(maxSteps) {
  return this._frame > maxSteps;
};
ForceAtlas2GPU.prototype._swapTexture = function() {
  var tmp = this._positionPrevTex;
  this._positionPrevTex = this._positionTex;
  this._positionTex = tmp;
  var tmp = this._forcePrevTex;
  this._forcePrevTex = this._forceTex;
  this._forceTex = tmp;
  var tmp = this._globalSpeedPrevTex;
  this._globalSpeedPrevTex = this._globalSpeedTex;
  this._globalSpeedTex = tmp;
};
ForceAtlas2GPU.prototype._initFromSource = function(renderer) {
  this._framebuffer.attach(this._positionPrevTex);
  this._framebuffer.bind(renderer);
  this._copyPass.setUniform("texture", this._positionSourceTex);
  this._copyPass.render(renderer);
  renderer.gl.clearColor(0, 0, 0, 0);
  this._framebuffer.attach(this._forcePrevTex);
  renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT);
  this._framebuffer.attach(this._globalSpeedPrevTex);
  renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT);
  this._framebuffer.unbind(renderer);
};
ForceAtlas2GPU.prototype._resize = function(width, height) {
  ["_positionSourceTex", "_positionTex", "_positionPrevTex", "_forceTex", "_forcePrevTex"].forEach(function(texName) {
    this[texName].width = width;
    this[texName].height = height;
    this[texName].dirty();
  }, this);
};
ForceAtlas2GPU.prototype.dispose = function(renderer) {
  this._framebuffer.dispose(renderer);
  this._copyPass.dispose(renderer);
  this._nodeRepulsionPass.dispose(renderer);
  this._positionPass.dispose(renderer);
  this._globalSpeedPass.dispose(renderer);
  this._edgeForceMesh.geometry.dispose(renderer);
  this._weightedSumMesh.geometry.dispose(renderer);
  this._positionSourceTex.dispose(renderer);
  this._positionTex.dispose(renderer);
  this._positionPrevTex.dispose(renderer);
  this._forceTex.dispose(renderer);
  this._forcePrevTex.dispose(renderer);
  this._weightedSumTex.dispose(renderer);
  this._globalSpeedTex.dispose(renderer);
  this._globalSpeedPrevTex.dispose(renderer);
};
var ForceAtlas2GPU_default = ForceAtlas2GPU;

// node_modules/echarts-gl/lib/chart/graphGL/forceAtlas2Worker.js
function forceAtlas2Worker() {
  var vec24 = {
    create: function() {
      return new Float32Array(2);
    },
    dist: function(a, b) {
      var x = b[0] - a[0];
      var y = b[1] - a[1];
      return Math.sqrt(x * x + y * y);
    },
    len: function(a) {
      var x = a[0];
      var y = a[1];
      return Math.sqrt(x * x + y * y);
    },
    scaleAndAdd: function(out, a, b, scale) {
      out[0] = a[0] + b[0] * scale;
      out[1] = a[1] + b[1] * scale;
      return out;
    },
    scale: function(out, a, b) {
      out[0] = a[0] * b;
      out[1] = a[1] * b;
      return out;
    },
    add: function(out, a, b) {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
      return out;
    },
    sub: function(out, a, b) {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      return out;
    },
    normalize: function(out, a) {
      var x = a[0];
      var y = a[1];
      var len = x * x + y * y;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
      }
      return out;
    },
    negate: function(out, a) {
      out[0] = -a[0];
      out[1] = -a[1];
      return out;
    },
    copy: function(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      return out;
    },
    set: function(out, x, y) {
      out[0] = x;
      out[1] = y;
      return out;
    }
  };
  function Region() {
    this.subRegions = [];
    this.nSubRegions = 0;
    this.node = null;
    this.mass = 0;
    this.centerOfMass = null;
    this.bbox = new Float32Array(4);
    this.size = 0;
  }
  var regionProto = Region.prototype;
  regionProto.beforeUpdate = function() {
    for (var i = 0; i < this.nSubRegions; i++) {
      this.subRegions[i].beforeUpdate();
    }
    this.mass = 0;
    if (this.centerOfMass) {
      this.centerOfMass[0] = 0;
      this.centerOfMass[1] = 0;
    }
    this.nSubRegions = 0;
    this.node = null;
  };
  regionProto.afterUpdate = function() {
    this.subRegions.length = this.nSubRegions;
    for (var i = 0; i < this.nSubRegions; i++) {
      this.subRegions[i].afterUpdate();
    }
  };
  regionProto.addNode = function(node) {
    if (this.nSubRegions === 0) {
      if (this.node == null) {
        this.node = node;
        return;
      } else {
        this._addNodeToSubRegion(this.node);
        this.node = null;
      }
    }
    this._addNodeToSubRegion(node);
    this._updateCenterOfMass(node);
  };
  regionProto.findSubRegion = function(x, y) {
    for (var i = 0; i < this.nSubRegions; i++) {
      var region = this.subRegions[i];
      if (region.contain(x, y)) {
        return region;
      }
    }
  };
  regionProto.contain = function(x, y) {
    return this.bbox[0] <= x && this.bbox[2] >= x && this.bbox[1] <= y && this.bbox[3] >= y;
  };
  regionProto.setBBox = function(minX, minY, maxX, maxY) {
    this.bbox[0] = minX;
    this.bbox[1] = minY;
    this.bbox[2] = maxX;
    this.bbox[3] = maxY;
    this.size = (maxX - minX + maxY - minY) / 2;
  };
  regionProto._newSubRegion = function() {
    var subRegion = this.subRegions[this.nSubRegions];
    if (!subRegion) {
      subRegion = new Region();
      this.subRegions[this.nSubRegions] = subRegion;
    }
    this.nSubRegions++;
    return subRegion;
  };
  regionProto._addNodeToSubRegion = function(node) {
    var subRegion = this.findSubRegion(node.position[0], node.position[1]);
    var bbox = this.bbox;
    if (!subRegion) {
      var cx = (bbox[0] + bbox[2]) / 2;
      var cy = (bbox[1] + bbox[3]) / 2;
      var w = (bbox[2] - bbox[0]) / 2;
      var h = (bbox[3] - bbox[1]) / 2;
      var xi = node.position[0] >= cx ? 1 : 0;
      var yi = node.position[1] >= cy ? 1 : 0;
      var subRegion = this._newSubRegion();
      subRegion.setBBox(
        // Min
        xi * w + bbox[0],
        yi * h + bbox[1],
        // Max
        (xi + 1) * w + bbox[0],
        (yi + 1) * h + bbox[1]
      );
    }
    subRegion.addNode(node);
  };
  regionProto._updateCenterOfMass = function(node) {
    if (this.centerOfMass == null) {
      this.centerOfMass = new Float32Array(2);
    }
    var x = this.centerOfMass[0] * this.mass;
    var y = this.centerOfMass[1] * this.mass;
    x += node.position[0] * node.mass;
    y += node.position[1] * node.mass;
    this.mass += node.mass;
    this.centerOfMass[0] = x / this.mass;
    this.centerOfMass[1] = y / this.mass;
  };
  function GraphNode() {
    this.position = new Float32Array(2);
    this.force = vec24.create();
    this.forcePrev = vec24.create();
    this.mass = 1;
    this.inDegree = 0;
    this.outDegree = 0;
  }
  function GraphEdge(source, target) {
    this.source = source;
    this.target = target;
    this.weight = 1;
  }
  function ForceAtlas22() {
    this.autoSettings = true;
    this.barnesHutOptimize = true;
    this.barnesHutTheta = 1.5;
    this.repulsionByDegree = true;
    this.linLogMode = false;
    this.strongGravityMode = false;
    this.gravity = 1;
    this.scaling = 1;
    this.edgeWeightInfluence = 1;
    this.jitterTolerence = 0.1;
    this.preventOverlap = false;
    this.dissuadeHubs = false;
    this.rootRegion = new Region();
    this.rootRegion.centerOfMass = vec24.create();
    this.nodes = [];
    this.edges = [];
    this.bbox = new Float32Array(4);
    this.gravityCenter = null;
    this._massArr = null;
    this._swingingArr = null;
    this._sizeArr = null;
    this._globalSpeed = 0;
  }
  var forceAtlas2Proto = ForceAtlas22.prototype;
  forceAtlas2Proto.initNodes = function(positionArr, massArr, sizeArr) {
    var nNodes = massArr.length;
    this.nodes.length = 0;
    var haveSize = typeof sizeArr != "undefined";
    for (var i = 0; i < nNodes; i++) {
      var node = new GraphNode();
      node.position[0] = positionArr[i * 2];
      node.position[1] = positionArr[i * 2 + 1];
      node.mass = massArr[i];
      if (haveSize) {
        node.size = sizeArr[i];
      }
      this.nodes.push(node);
    }
    this._massArr = massArr;
    this._swingingArr = new Float32Array(nNodes);
    if (haveSize) {
      this._sizeArr = sizeArr;
    }
  };
  forceAtlas2Proto.initEdges = function(edgeArr, edgeWeightArr) {
    var nEdges = edgeArr.length / 2;
    this.edges.length = 0;
    for (var i = 0; i < nEdges; i++) {
      var sIdx = edgeArr[i * 2];
      var tIdx = edgeArr[i * 2 + 1];
      var sNode = this.nodes[sIdx];
      var tNode = this.nodes[tIdx];
      if (!sNode || !tNode) {
        console.error("Node not exists, try initNodes before initEdges");
        return;
      }
      sNode.outDegree++;
      tNode.inDegree++;
      var edge = new GraphEdge(sNode, tNode);
      if (edgeWeightArr) {
        edge.weight = edgeWeightArr[i];
      }
      this.edges.push(edge);
    }
  };
  forceAtlas2Proto.updateSettings = function() {
    if (this.repulsionByDegree) {
      for (var i = 0; i < this.nodes.length; i++) {
        var node = this.nodes[i];
        node.mass = node.inDegree + node.outDegree + 1;
      }
    } else {
      for (var i = 0; i < this.nodes.length; i++) {
        var node = this.nodes[i];
        node.mass = this._massArr[i];
      }
    }
  };
  forceAtlas2Proto.update = function() {
    var nNodes = this.nodes.length;
    this.updateSettings();
    this.updateBBox();
    if (this.barnesHutOptimize) {
      this.rootRegion.setBBox(this.bbox[0], this.bbox[1], this.bbox[2], this.bbox[3]);
      this.rootRegion.beforeUpdate();
      for (var i = 0; i < nNodes; i++) {
        this.rootRegion.addNode(this.nodes[i]);
      }
      this.rootRegion.afterUpdate();
    }
    for (var i = 0; i < nNodes; i++) {
      var node = this.nodes[i];
      vec24.copy(node.forcePrev, node.force);
      vec24.set(node.force, 0, 0);
    }
    for (var i = 0; i < nNodes; i++) {
      var na = this.nodes[i];
      if (this.barnesHutOptimize) {
        this.applyRegionToNodeRepulsion(this.rootRegion, na);
      } else {
        for (var j = i + 1; j < nNodes; j++) {
          var nb = this.nodes[j];
          this.applyNodeToNodeRepulsion(na, nb, false);
        }
      }
      if (this.gravity > 0) {
        if (this.strongGravityMode) {
          this.applyNodeStrongGravity(na);
        } else {
          this.applyNodeGravity(na);
        }
      }
    }
    for (var i = 0; i < this.edges.length; i++) {
      this.applyEdgeAttraction(this.edges[i]);
    }
    var swingWeightedSum = 0;
    var tractionWeightedSum = 0;
    var tmp = vec24.create();
    for (var i = 0; i < nNodes; i++) {
      var node = this.nodes[i];
      var swing = vec24.dist(node.force, node.forcePrev);
      swingWeightedSum += swing * node.mass;
      vec24.add(tmp, node.force, node.forcePrev);
      var traction = vec24.len(tmp) * 0.5;
      tractionWeightedSum += traction * node.mass;
      this._swingingArr[i] = swing;
    }
    var globalSpeed = this.jitterTolerence * this.jitterTolerence * tractionWeightedSum / swingWeightedSum;
    if (this._globalSpeed > 0) {
      globalSpeed = Math.min(globalSpeed / this._globalSpeed, 1.5) * this._globalSpeed;
    }
    this._globalSpeed = globalSpeed;
    for (var i = 0; i < nNodes; i++) {
      var node = this.nodes[i];
      var swing = this._swingingArr[i];
      var speed = 0.1 * globalSpeed / (1 + globalSpeed * Math.sqrt(swing));
      var df = vec24.len(node.force);
      if (df > 0) {
        speed = Math.min(df * speed, 10) / df;
        vec24.scaleAndAdd(node.position, node.position, node.force, speed);
      }
    }
  };
  forceAtlas2Proto.applyRegionToNodeRepulsion = function() {
    var v = vec24.create();
    return function applyRegionToNodeRepulsion(region, node) {
      if (region.node) {
        this.applyNodeToNodeRepulsion(region.node, node, true);
      } else {
        vec24.sub(v, node.position, region.centerOfMass);
        var d2 = v[0] * v[0] + v[1] * v[1];
        if (d2 > this.barnesHutTheta * region.size * region.size) {
          var factor = this.scaling * node.mass * region.mass / d2;
          vec24.scaleAndAdd(node.force, node.force, v, factor);
        } else {
          for (var i = 0; i < region.nSubRegions; i++) {
            this.applyRegionToNodeRepulsion(region.subRegions[i], node);
          }
        }
      }
    };
  }();
  forceAtlas2Proto.applyNodeToNodeRepulsion = function() {
    var v = vec24.create();
    return function applyNodeToNodeRepulsion(na, nb, oneWay) {
      if (na == nb) {
        return;
      }
      vec24.sub(v, na.position, nb.position);
      var d2 = v[0] * v[0] + v[1] * v[1];
      if (d2 === 0) {
        return;
      }
      var factor;
      if (this.preventOverlap) {
        var d = Math.sqrt(d2);
        d = d - na.size - nb.size;
        if (d > 0) {
          factor = this.scaling * na.mass * nb.mass / (d * d);
        } else if (d < 0) {
          factor = this.scaling * 100 * na.mass * nb.mass;
        } else {
          return;
        }
      } else {
        factor = this.scaling * na.mass * nb.mass / d2;
      }
      vec24.scaleAndAdd(na.force, na.force, v, factor);
      vec24.scaleAndAdd(nb.force, nb.force, v, -factor);
    };
  }();
  forceAtlas2Proto.applyEdgeAttraction = function() {
    var v = vec24.create();
    return function applyEdgeAttraction(edge) {
      var na = edge.source;
      var nb = edge.target;
      vec24.sub(v, na.position, nb.position);
      var d = vec24.len(v);
      var w;
      if (this.edgeWeightInfluence === 0) {
        w = 1;
      } else if (this.edgeWeightInfluence === 1) {
        w = edge.weight;
      } else {
        w = Math.pow(edge.weight, this.edgeWeightInfluence);
      }
      var factor;
      if (this.preventOverlap) {
        d = d - na.size - nb.size;
        if (d <= 0) {
          return;
        }
      }
      if (this.linLogMode) {
        factor = -w * Math.log(d + 1) / (d + 1);
      } else {
        factor = -w;
      }
      vec24.scaleAndAdd(na.force, na.force, v, factor);
      vec24.scaleAndAdd(nb.force, nb.force, v, -factor);
    };
  }();
  forceAtlas2Proto.applyNodeGravity = function() {
    var v = vec24.create();
    return function(node) {
      vec24.sub(v, this.gravityCenter, node.position);
      var d = vec24.len(v);
      vec24.scaleAndAdd(node.force, node.force, v, this.gravity * node.mass / (d + 1));
    };
  }();
  forceAtlas2Proto.applyNodeStrongGravity = function() {
    var v = vec24.create();
    return function(node) {
      vec24.sub(v, this.gravityCenter, node.position);
      vec24.scaleAndAdd(node.force, node.force, v, this.gravity * node.mass);
    };
  }();
  forceAtlas2Proto.updateBBox = function() {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    for (var i = 0; i < this.nodes.length; i++) {
      var pos = this.nodes[i].position;
      minX = Math.min(minX, pos[0]);
      minY = Math.min(minY, pos[1]);
      maxX = Math.max(maxX, pos[0]);
      maxY = Math.max(maxY, pos[1]);
    }
    this.bbox[0] = minX;
    this.bbox[1] = minY;
    this.bbox[2] = maxX;
    this.bbox[3] = maxY;
  };
  forceAtlas2Proto.getGlobalSpeed = function() {
    return this._globalSpeed;
  };
  var forceAtlas2 = null;
  self.onmessage = function(e) {
    switch (e.data.cmd) {
      case "init":
        forceAtlas2 = new ForceAtlas22();
        forceAtlas2.initNodes(e.data.nodesPosition, e.data.nodesMass, e.data.nodesSize);
        forceAtlas2.initEdges(e.data.edges, e.data.edgesWeight);
        break;
      case "updateConfig":
        if (forceAtlas2) {
          for (var name in e.data.config) {
            forceAtlas2[name] = e.data.config[name];
          }
        }
        break;
      case "update":
        var steps = e.data.steps;
        if (forceAtlas2) {
          for (var i = 0; i < steps; i++) {
            forceAtlas2.update();
          }
          var nNodes = forceAtlas2.nodes.length;
          var positionArr = new Float32Array(nNodes * 2);
          for (var i = 0; i < nNodes; i++) {
            var node = forceAtlas2.nodes[i];
            positionArr[i * 2] = node.position[0];
            positionArr[i * 2 + 1] = node.position[1];
          }
          self.postMessage({
            buffer: positionArr.buffer,
            globalSpeed: forceAtlas2.getGlobalSpeed()
          }, [positionArr.buffer]);
        } else {
          var emptyArr = new Float32Array();
          self.postMessage({
            buffer: emptyArr.buffer,
            globalSpeed: forceAtlas2.getGlobalSpeed()
          }, [emptyArr.buffer]);
        }
        break;
    }
  };
}
var forceAtlas2Worker_default = forceAtlas2Worker;

// node_modules/echarts-gl/lib/chart/graphGL/ForceAtlas2.js
var workerUrl = forceAtlas2Worker_default.toString();
workerUrl = workerUrl.slice(workerUrl.indexOf("{") + 1, workerUrl.lastIndexOf("}"));
var defaultConfigs2 = {
  barnesHutOptimize: true,
  barnesHutTheta: 1.5,
  repulsionByDegree: true,
  linLogMode: false,
  strongGravityMode: false,
  gravity: 1,
  scaling: 1,
  edgeWeightInfluence: 1,
  jitterTolerence: 0.1,
  preventOverlap: false,
  dissuadeHubs: false,
  gravityCenter: null
};
var ForceAtlas2 = function(options) {
  for (var name in defaultConfigs2) {
    this[name] = defaultConfigs2[name];
  }
  if (options) {
    for (var name in options) {
      this[name] = options[name];
    }
  }
  this._nodes = [];
  this._edges = [];
  this._disposed = false;
  this._positionTex = new Texture2D_default({
    type: Texture_default.FLOAT,
    flipY: false,
    minFilter: Texture_default.NEAREST,
    magFilter: Texture_default.NEAREST
  });
};
ForceAtlas2.prototype.initData = function(nodes, edges) {
  var bb = new Blob([workerUrl]);
  var blobURL = window.URL.createObjectURL(bb);
  this._worker = new Worker(blobURL);
  this._worker.onmessage = this._$onupdate.bind(this);
  this._nodes = nodes;
  this._edges = edges;
  this._frame = 0;
  var nNodes = nodes.length;
  var nEdges = edges.length;
  var positionArr = new Float32Array(nNodes * 2);
  var massArr = new Float32Array(nNodes);
  var sizeArr = new Float32Array(nNodes);
  var edgeArr = new Float32Array(nEdges * 2);
  var edgeWeightArr = new Float32Array(nEdges);
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    positionArr[i * 2] = node.x;
    positionArr[i * 2 + 1] = node.y;
    massArr[i] = node.mass == null ? 1 : node.mass;
    sizeArr[i] = node.size == null ? 1 : node.size;
  }
  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var source = edge.node1;
    var target = edge.node2;
    edgeArr[i * 2] = source;
    edgeArr[i * 2 + 1] = target;
    edgeWeightArr[i] = edge.weight == null ? 1 : edge.weight;
  }
  var textureWidth = Math.ceil(Math.sqrt(nodes.length));
  var textureHeight = textureWidth;
  var pixels = new Float32Array(textureWidth * textureHeight * 4);
  var positionTex = this._positionTex;
  positionTex.width = textureWidth;
  positionTex.height = textureHeight;
  positionTex.pixels = pixels;
  this._worker.postMessage({
    cmd: "init",
    nodesPosition: positionArr,
    nodesMass: massArr,
    nodesSize: sizeArr,
    edges: edgeArr,
    edgesWeight: edgeWeightArr
  });
  this._globalSpeed = Infinity;
};
ForceAtlas2.prototype.updateOption = function(options) {
  var config = {};
  for (var name in defaultConfigs2) {
    config[name] = defaultConfigs2[name];
  }
  var nodes = this._nodes;
  var edges = this._edges;
  var nNodes = nodes.length;
  if (nNodes > 5e4) {
    config.jitterTolerence = 10;
  } else if (nNodes > 5e3) {
    config.jitterTolerence = 1;
  } else {
    config.jitterTolerence = 0.1;
  }
  if (nNodes > 100) {
    config.scaling = 2;
  } else {
    config.scaling = 10;
  }
  if (nNodes > 1e3) {
    config.barnesHutOptimize = true;
  } else {
    config.barnesHutOptimize = false;
  }
  if (options) {
    for (var name in defaultConfigs2) {
      if (options[name] != null) {
        config[name] = options[name];
      }
    }
  }
  if (!config.gravityCenter) {
    var min = [Infinity, Infinity];
    var max = [-Infinity, -Infinity];
    for (var i = 0; i < nodes.length; i++) {
      min[0] = Math.min(nodes[i].x, min[0]);
      min[1] = Math.min(nodes[i].y, min[1]);
      max[0] = Math.max(nodes[i].x, max[0]);
      max[1] = Math.max(nodes[i].y, max[1]);
    }
    config.gravityCenter = [(min[0] + max[0]) * 0.5, (min[1] + max[1]) * 0.5];
  }
  for (var i = 0; i < edges.length; i++) {
    var node1 = edges[i].node1;
    var node2 = edges[i].node2;
    nodes[node1].degree = (nodes[node1].degree || 0) + 1;
    nodes[node2].degree = (nodes[node2].degree || 0) + 1;
  }
  if (this._worker) {
    this._worker.postMessage({
      cmd: "updateConfig",
      config
    });
  }
};
ForceAtlas2.prototype.update = function(renderer, steps, cb) {
  if (steps == null) {
    steps = 1;
  }
  steps = Math.max(steps, 1);
  this._frame += steps;
  this._onupdate = cb;
  if (this._worker) {
    this._worker.postMessage({
      cmd: "update",
      steps: Math.round(steps)
    });
  }
};
ForceAtlas2.prototype._$onupdate = function(e) {
  if (this._disposed) {
    return;
  }
  var positionArr = new Float32Array(e.data.buffer);
  this._globalSpeed = e.data.globalSpeed;
  this._positionArr = positionArr;
  this._updateTexture(positionArr);
  this._onupdate && this._onupdate();
};
ForceAtlas2.prototype.getNodePositionTexture = function() {
  return this._positionTex;
};
ForceAtlas2.prototype.getNodeUV = function(nodeIndex, uv) {
  uv = uv || [];
  var textureWidth = this._positionTex.width;
  var textureHeight = this._positionTex.height;
  uv[0] = nodeIndex % textureWidth / (textureWidth - 1);
  uv[1] = Math.floor(nodeIndex / textureWidth) / (textureHeight - 1);
  return uv;
};
ForceAtlas2.prototype.getNodes = function() {
  return this._nodes;
};
ForceAtlas2.prototype.getEdges = function() {
  return this._edges;
};
ForceAtlas2.prototype.isFinished = function(maxSteps) {
  return this._frame > maxSteps;
};
ForceAtlas2.prototype.getNodePosition = function(renderer, out) {
  if (!out) {
    out = new Float32Array(this._nodes.length * 2);
  }
  if (this._positionArr) {
    for (var i = 0; i < this._positionArr.length; i++) {
      out[i] = this._positionArr[i];
    }
  }
  return out;
};
ForceAtlas2.prototype._updateTexture = function(positionArr) {
  var pixels = this._positionTex.pixels;
  var offset = 0;
  for (var i = 0; i < positionArr.length; ) {
    pixels[offset++] = positionArr[i++];
    pixels[offset++] = positionArr[i++];
    pixels[offset++] = 1;
    pixels[offset++] = 1;
  }
  this._positionTex.dirty();
};
ForceAtlas2.prototype.dispose = function(renderer) {
  this._disposed = true;
  this._worker = null;
};
var ForceAtlas2_default = ForceAtlas2;

// node_modules/echarts-gl/lib/util/Roam2DControl.js
var Roam2DControl = Base_default.extend(function() {
  return {
    /**
     * @type {module:zrender~ZRender}
     */
    zr: null,
    /**
     * @type {module:echarts-gl/core/ViewGL}
     */
    viewGL: null,
    minZoom: 0.2,
    maxZoom: 5,
    _needsUpdate: false,
    _dx: 0,
    _dy: 0,
    _zoom: 1
  };
}, function() {
  this._mouseDownHandler = this._mouseDownHandler.bind(this);
  this._mouseWheelHandler = this._mouseWheelHandler.bind(this);
  this._mouseMoveHandler = this._mouseMoveHandler.bind(this);
  this._mouseUpHandler = this._mouseUpHandler.bind(this);
  this._update = this._update.bind(this);
}, {
  init: function() {
    var zr = this.zr;
    zr.on("mousedown", this._mouseDownHandler);
    zr.on("mousewheel", this._mouseWheelHandler);
    zr.on("globalout", this._mouseUpHandler);
    zr.animation.on("frame", this._update);
  },
  setTarget: function(target) {
    this._target = target;
  },
  setZoom: function(zoom) {
    this._zoom = Math.max(Math.min(zoom, this.maxZoom), this.minZoom);
    this._needsUpdate = true;
  },
  setOffset: function(offset) {
    this._dx = offset[0];
    this._dy = offset[1];
    this._needsUpdate = true;
  },
  getZoom: function() {
    return this._zoom;
  },
  getOffset: function() {
    return [this._dx, this._dy];
  },
  _update: function() {
    if (!this._target) {
      return;
    }
    if (!this._needsUpdate) {
      return;
    }
    var target = this._target;
    var scale = this._zoom;
    target.position.x = this._dx;
    target.position.y = this._dy;
    target.scale.set(scale, scale, scale);
    this.zr.refresh();
    this._needsUpdate = false;
    this.trigger("update");
  },
  _mouseDownHandler: function(e) {
    if (e.target) {
      return;
    }
    var x = e.offsetX;
    var y = e.offsetY;
    if (this.viewGL && !this.viewGL.containPoint(x, y)) {
      return;
    }
    this.zr.on("mousemove", this._mouseMoveHandler);
    this.zr.on("mouseup", this._mouseUpHandler);
    var pos = this._convertPos(x, y);
    this._x = pos.x;
    this._y = pos.y;
  },
  // Convert pos from screen space to viewspace.
  _convertPos: function(x, y) {
    var camera = this.viewGL.camera;
    var viewport = this.viewGL.viewport;
    return {
      x: (x - viewport.x) / viewport.width * (camera.right - camera.left) + camera.left,
      y: (y - viewport.y) / viewport.height * (camera.bottom - camera.top) + camera.top
    };
  },
  _mouseMoveHandler: function(e) {
    var pos = this._convertPos(e.offsetX, e.offsetY);
    this._dx += pos.x - this._x;
    this._dy += pos.y - this._y;
    this._x = pos.x;
    this._y = pos.y;
    this._needsUpdate = true;
  },
  _mouseUpHandler: function(e) {
    this.zr.off("mousemove", this._mouseMoveHandler);
    this.zr.off("mouseup", this._mouseUpHandler);
  },
  _mouseWheelHandler: function(e) {
    e = e.event;
    var delta = e.wheelDelta || -e.detail;
    if (delta === 0) {
      return;
    }
    var x = e.offsetX;
    var y = e.offsetY;
    if (this.viewGL && !this.viewGL.containPoint(x, y)) {
      return;
    }
    var zoomScale = delta > 0 ? 1.1 : 0.9;
    var newZoom = Math.max(Math.min(this._zoom * zoomScale, this.maxZoom), this.minZoom);
    zoomScale = newZoom / this._zoom;
    var pos = this._convertPos(x, y);
    var fixX = (pos.x - this._dx) * (zoomScale - 1);
    var fixY = (pos.y - this._dy) * (zoomScale - 1);
    this._dx -= fixX;
    this._dy -= fixY;
    this._zoom = newZoom;
    this._needsUpdate = true;
  },
  dispose: function() {
    var zr = this.zr;
    zr.off("mousedown", this._mouseDownHandler);
    zr.off("mousemove", this._mouseMoveHandler);
    zr.off("mouseup", this._mouseUpHandler);
    zr.off("mousewheel", this._mouseWheelHandler);
    zr.off("globalout", this._mouseUpHandler);
    zr.animation.off("frame", this._update);
  }
});
var Roam2DControl_default = Roam2DControl;

// node_modules/echarts-gl/lib/util/shader/lines2D.glsl.js
var lines2D_glsl_default = "@export ecgl.lines2D.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec2 position: POSITION;\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n\n#ifdef POSITIONTEXTURE_ENABLED\nuniform sampler2D positionTexture;\n#endif\n\nvoid main()\n{\n gl_Position = worldViewProjection * vec4(position, -10.0, 1.0);\n\n v_Color = a_Color;\n}\n\n@end\n\n@export ecgl.lines2D.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nvarying vec4 v_Color;\n\nvoid main()\n{\n gl_FragColor = color * v_Color;\n}\n@end\n\n\n@export ecgl.meshLines2D.vertex\n\nattribute vec2 position: POSITION;\nattribute vec2 normal;\nattribute float offset;\nattribute vec4 a_Color : COLOR;\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform vec4 viewport : VIEWPORT;\n\nvarying vec4 v_Color;\nvarying float v_Miter;\n\nvoid main()\n{\n vec4 p2 = worldViewProjection * vec4(position + normal, -10.0, 1.0);\n gl_Position = worldViewProjection * vec4(position, -10.0, 1.0);\n\n p2.xy /= p2.w;\n gl_Position.xy /= gl_Position.w;\n\n vec2 N = normalize(p2.xy - gl_Position.xy);\n gl_Position.xy += N * offset / viewport.zw * 2.0;\n\n gl_Position.xy *= gl_Position.w;\n\n v_Color = a_Color;\n}\n@end\n\n\n@export ecgl.meshLines2D.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nvarying vec4 v_Color;\nvarying float v_Miter;\n\nvoid main()\n{\n gl_FragColor = color * v_Color;\n}\n\n@end";

// node_modules/echarts-gl/lib/chart/graphGL/GraphGLView.js
var vec23 = glmatrix_default.vec2;
graphicGL_default.Shader.import(lines2D_glsl_default);
var globalLayoutId = 1;
var GraphGLView_default = Chart_default.extend({
  type: "graphGL",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL_default.Node();
    this.viewGL = new ViewGL_default("orthographic");
    this.viewGL.camera.left = this.viewGL.camera.right = 0;
    this.viewGL.add(this.groupGL);
    this._pointsBuilder = new PointsBuilder_default(true, api);
    this._forceEdgesMesh = new graphicGL_default.Mesh({
      material: new graphicGL_default.Material({
        shader: graphicGL_default.createShader("ecgl.forceAtlas2.edges"),
        transparent: true,
        depthMask: false,
        depthTest: false
      }),
      $ignorePicking: true,
      geometry: new graphicGL_default.Geometry({
        attributes: {
          node: new graphicGL_default.Geometry.Attribute("node", "float", 2),
          color: new graphicGL_default.Geometry.Attribute("color", "float", 4, "COLOR")
        },
        dynamic: true,
        mainAttribute: "node"
      }),
      renderOrder: -1,
      mode: graphicGL_default.Mesh.LINES
    });
    this._edgesMesh = new graphicGL_default.Mesh({
      material: new graphicGL_default.Material({
        shader: graphicGL_default.createShader("ecgl.meshLines2D"),
        transparent: true,
        depthMask: false,
        depthTest: false
      }),
      $ignorePicking: true,
      geometry: new Lines2D_default({
        useNativeLine: false,
        dynamic: true
      }),
      renderOrder: -1,
      culling: false
    });
    this._layoutId = 0;
    this._control = new Roam2DControl_default({
      zr: api.getZr(),
      viewGL: this.viewGL
    });
    this._control.setTarget(this.groupGL);
    this._control.init();
    this._clickHandler = this._clickHandler.bind(this);
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.add(this._pointsBuilder.rootNode);
    this._model = seriesModel;
    this._api = api;
    this._initLayout(seriesModel, ecModel, api);
    this._pointsBuilder.update(seriesModel, ecModel, api);
    if (!(this._forceLayoutInstance instanceof ForceAtlas2GPU_default)) {
      this.groupGL.remove(this._forceEdgesMesh);
    }
    this._updateCamera(seriesModel, api);
    this._control.off("update");
    this._control.on("update", function() {
      api.dispatchAction({
        type: "graphGLRoam",
        seriesId: seriesModel.id,
        zoom: this._control.getZoom(),
        offset: this._control.getOffset()
      });
      this._pointsBuilder.updateView(this.viewGL.camera);
    }, this);
    this._control.setZoom(retrieve_default.firstNotNull(seriesModel.get("zoom"), 1));
    this._control.setOffset(seriesModel.get("offset") || [0, 0]);
    var mesh = this._pointsBuilder.getPointsMesh();
    mesh.off("mousemove", this._mousemoveHandler);
    mesh.off("mouseout", this._mouseOutHandler, this);
    api.getZr().off("click", this._clickHandler);
    this._pointsBuilder.highlightOnMouseover = true;
    if (seriesModel.get("focusNodeAdjacency")) {
      var focusNodeAdjacencyOn = seriesModel.get("focusNodeAdjacencyOn");
      if (focusNodeAdjacencyOn === "click") {
        api.getZr().on("click", this._clickHandler);
      } else if (focusNodeAdjacencyOn === "mouseover") {
        mesh.on("mousemove", this._mousemoveHandler, this);
        mesh.on("mouseout", this._mouseOutHandler, this);
        this._pointsBuilder.highlightOnMouseover = false;
      } else {
        if (true) {
          console.warn("Unkown focusNodeAdjacencyOn value s" + focusNodeAdjacencyOn);
        }
      }
    }
    this._lastMouseOverDataIndex = -1;
  },
  _clickHandler: function(e) {
    if (this._layouting) {
      return;
    }
    var dataIndex = this._pointsBuilder.getPointsMesh().dataIndex;
    if (dataIndex >= 0) {
      this._api.dispatchAction({
        type: "graphGLFocusNodeAdjacency",
        seriesId: this._model.id,
        dataIndex
      });
    } else {
      this._api.dispatchAction({
        type: "graphGLUnfocusNodeAdjacency",
        seriesId: this._model.id
      });
    }
  },
  _mousemoveHandler: function(e) {
    if (this._layouting) {
      return;
    }
    var dataIndex = this._pointsBuilder.getPointsMesh().dataIndex;
    if (dataIndex >= 0) {
      if (dataIndex !== this._lastMouseOverDataIndex) {
        this._api.dispatchAction({
          type: "graphGLFocusNodeAdjacency",
          seriesId: this._model.id,
          dataIndex
        });
      }
    } else {
      this._mouseOutHandler(e);
    }
    this._lastMouseOverDataIndex = dataIndex;
  },
  _mouseOutHandler: function(e) {
    if (this._layouting) {
      return;
    }
    this._api.dispatchAction({
      type: "graphGLUnfocusNodeAdjacency",
      seriesId: this._model.id
    });
    this._lastMouseOverDataIndex = -1;
  },
  _updateForceEdgesGeometry: function(edges, seriesModel) {
    var geometry = this._forceEdgesMesh.geometry;
    var edgeData = seriesModel.getEdgeData();
    var offset = 0;
    var layoutInstance = this._forceLayoutInstance;
    var vertexCount = edgeData.count() * 2;
    geometry.attributes.node.init(vertexCount);
    geometry.attributes.color.init(vertexCount);
    edgeData.each(function(idx) {
      var edge = edges[idx];
      geometry.attributes.node.set(offset, layoutInstance.getNodeUV(edge.node1));
      geometry.attributes.node.set(offset + 1, layoutInstance.getNodeUV(edge.node2));
      var color = getItemVisualColor(edgeData, edge.dataIndex);
      var colorArr = graphicGL_default.parseColor(color);
      colorArr[3] *= retrieve_default.firstNotNull(getItemVisualOpacity(edgeData, edge.dataIndex), 1);
      geometry.attributes.color.set(offset, colorArr);
      geometry.attributes.color.set(offset + 1, colorArr);
      offset += 2;
    });
    geometry.dirty();
  },
  _updateMeshLinesGeometry: function() {
    var edgeData = this._model.getEdgeData();
    var geometry = this._edgesMesh.geometry;
    var edgeData = this._model.getEdgeData();
    var points = this._model.getData().getLayout("points");
    geometry.resetOffset();
    geometry.setVertexCount(edgeData.count() * geometry.getLineVertexCount());
    geometry.setTriangleCount(edgeData.count() * geometry.getLineTriangleCount());
    var p0 = [];
    var p1 = [];
    var lineWidthQuery = ["lineStyle", "width"];
    this._originalEdgeColors = new Float32Array(edgeData.count() * 4);
    this._edgeIndicesMap = new Float32Array(edgeData.count());
    edgeData.each(function(idx) {
      var edge = edgeData.graph.getEdgeByIndex(idx);
      var idx1 = edge.node1.dataIndex * 2;
      var idx2 = edge.node2.dataIndex * 2;
      p0[0] = points[idx1];
      p0[1] = points[idx1 + 1];
      p1[0] = points[idx2];
      p1[1] = points[idx2 + 1];
      var color = getItemVisualColor(edgeData, edge.dataIndex);
      var colorArr = graphicGL_default.parseColor(color);
      colorArr[3] *= retrieve_default.firstNotNull(getItemVisualOpacity(edgeData, edge.dataIndex), 1);
      var itemModel = edgeData.getItemModel(edge.dataIndex);
      var lineWidth = retrieve_default.firstNotNull(itemModel.get(lineWidthQuery), 1) * this._api.getDevicePixelRatio();
      geometry.addLine(p0, p1, colorArr, lineWidth);
      for (var k = 0; k < 4; k++) {
        this._originalEdgeColors[edge.dataIndex * 4 + k] = colorArr[k];
      }
      this._edgeIndicesMap[edge.dataIndex] = idx;
    }, this);
    geometry.dirty();
  },
  _updateForceNodesGeometry: function(nodeData) {
    var pointsMesh = this._pointsBuilder.getPointsMesh();
    var pos = [];
    for (var i = 0; i < nodeData.count(); i++) {
      this._forceLayoutInstance.getNodeUV(i, pos);
      pointsMesh.geometry.attributes.position.set(i, pos);
    }
    pointsMesh.geometry.dirty("position");
  },
  _initLayout: function(seriesModel, ecModel, api) {
    var layout = seriesModel.get("layout");
    var graph = seriesModel.getGraph();
    var boxLayoutOption = seriesModel.getBoxLayoutParams();
    var viewport = getLayoutRect(boxLayoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    if (layout === "force") {
      if (true) {
        console.warn("Currently only forceAtlas2 layout supported.");
      }
      layout = "forceAtlas2";
    }
    this.stopLayout(seriesModel, ecModel, api, {
      beforeLayout: true
    });
    var nodeData = seriesModel.getData();
    var edgeData = seriesModel.getData();
    if (layout === "forceAtlas2") {
      var layoutModel = seriesModel.getModel("forceAtlas2");
      var layoutInstance = this._forceLayoutInstance;
      var nodes = [];
      var edges = [];
      var nodeDataExtent = nodeData.getDataExtent("value");
      var edgeDataExtent = edgeData.getDataExtent("value");
      var edgeWeightRange = retrieve_default.firstNotNull(layoutModel.get("edgeWeight"), 1);
      var nodeWeightRange = retrieve_default.firstNotNull(layoutModel.get("nodeWeight"), 1);
      if (typeof edgeWeightRange === "number") {
        edgeWeightRange = [edgeWeightRange, edgeWeightRange];
      }
      if (typeof nodeWeightRange === "number") {
        nodeWeightRange = [nodeWeightRange, nodeWeightRange];
      }
      var offset = 0;
      var nodesIndicesMap = {};
      var layoutPoints = new Float32Array(nodeData.count() * 2);
      graph.eachNode(function(node) {
        var dataIndex = node.dataIndex;
        var value = nodeData.get("value", dataIndex);
        var x;
        var y;
        if (nodeData.hasItemOption) {
          var itemModel = nodeData.getItemModel(dataIndex);
          x = itemModel.get("x");
          y = itemModel.get("y");
        }
        if (x == null) {
          x = viewport.x + Math.random() * viewport.width;
          y = viewport.y + Math.random() * viewport.height;
        }
        layoutPoints[offset * 2] = x;
        layoutPoints[offset * 2 + 1] = y;
        nodesIndicesMap[node.id] = offset++;
        var mass = number_exports.linearMap(value, nodeDataExtent, nodeWeightRange);
        if (isNaN(mass)) {
          if (!isNaN(nodeWeightRange[0])) {
            mass = nodeWeightRange[0];
          } else {
            mass = 1;
          }
        }
        nodes.push({
          x,
          y,
          mass,
          size: nodeData.getItemVisual(dataIndex, "symbolSize")
        });
      });
      nodeData.setLayout("points", layoutPoints);
      graph.eachEdge(function(edge) {
        var dataIndex = edge.dataIndex;
        var value = nodeData.get("value", dataIndex);
        var weight = number_exports.linearMap(value, edgeDataExtent, edgeWeightRange);
        if (isNaN(weight)) {
          if (!isNaN(edgeWeightRange[0])) {
            weight = edgeWeightRange[0];
          } else {
            weight = 1;
          }
        }
        edges.push({
          node1: nodesIndicesMap[edge.node1.id],
          node2: nodesIndicesMap[edge.node2.id],
          weight,
          dataIndex
        });
      });
      if (!layoutInstance) {
        var isGPU = layoutModel.get("GPU");
        if (this._forceLayoutInstance) {
          if (isGPU && !(this._forceLayoutInstance instanceof ForceAtlas2GPU_default) || !isGPU && !(this._forceLayoutInstance instanceof ForceAtlas2_default)) {
            this._forceLayoutInstanceToDispose = this._forceLayoutInstance;
          }
        }
        layoutInstance = this._forceLayoutInstance = isGPU ? new ForceAtlas2GPU_default() : new ForceAtlas2_default();
      }
      layoutInstance.initData(nodes, edges);
      layoutInstance.updateOption(layoutModel.option);
      this._updateForceEdgesGeometry(layoutInstance.getEdges(), seriesModel);
      this._updatePositionTexture();
      api.dispatchAction({
        type: "graphGLStartLayout",
        from: this.uid
      });
    } else {
      var layoutPoints = new Float32Array(nodeData.count() * 2);
      var offset = 0;
      graph.eachNode(function(node) {
        var dataIndex = node.dataIndex;
        var x;
        var y;
        if (nodeData.hasItemOption) {
          var itemModel = nodeData.getItemModel(dataIndex);
          x = itemModel.get("x");
          y = itemModel.get("y");
        }
        layoutPoints[offset++] = x;
        layoutPoints[offset++] = y;
      });
      nodeData.setLayout("points", layoutPoints);
      this._updateAfterLayout(seriesModel, ecModel, api);
    }
  },
  _updatePositionTexture: function() {
    var positionTex = this._forceLayoutInstance.getNodePositionTexture();
    this._pointsBuilder.setPositionTexture(positionTex);
    this._forceEdgesMesh.material.set("positionTex", positionTex);
  },
  startLayout: function(seriesModel, ecModel, api, payload) {
    if (payload && payload.from != null && payload.from !== this.uid) {
      return;
    }
    var viewGL = this.viewGL;
    var api = this._api;
    var layoutInstance = this._forceLayoutInstance;
    var data = this._model.getData();
    var layoutModel = this._model.getModel("forceAtlas2");
    if (!layoutInstance) {
      if (true) {
        console.error("None layout don't have startLayout action");
      }
      return;
    }
    this.groupGL.remove(this._edgesMesh);
    this.groupGL.add(this._forceEdgesMesh);
    if (!this._forceLayoutInstance) {
      return;
    }
    this._updateForceNodesGeometry(seriesModel.getData());
    this._pointsBuilder.hideLabels();
    var self2 = this;
    var layoutId = this._layoutId = globalLayoutId++;
    var maxSteps = layoutModel.getShallow("maxSteps");
    var steps = layoutModel.getShallow("steps");
    var stepsCount = 0;
    var syncStepCount = Math.max(steps * 2, 20);
    var doLayout = function(layoutId2) {
      if (layoutId2 !== self2._layoutId) {
        return;
      }
      if (layoutInstance.isFinished(maxSteps)) {
        api.dispatchAction({
          type: "graphGLStopLayout",
          from: self2.uid
        });
        api.dispatchAction({
          type: "graphGLFinishLayout",
          points: data.getLayout("points"),
          from: self2.uid
        });
        return;
      }
      layoutInstance.update(viewGL.layer.renderer, steps, function() {
        self2._updatePositionTexture();
        stepsCount += steps;
        if (stepsCount >= syncStepCount) {
          self2._syncNodePosition(seriesModel);
          stepsCount = 0;
        }
        api.getZr().refresh();
        requestAnimationFrame_default(function() {
          doLayout(layoutId2);
        });
      });
    };
    requestAnimationFrame_default(function() {
      if (self2._forceLayoutInstanceToDispose) {
        self2._forceLayoutInstanceToDispose.dispose(viewGL.layer.renderer);
        self2._forceLayoutInstanceToDispose = null;
      }
      doLayout(layoutId);
    });
    this._layouting = true;
  },
  stopLayout: function(seriesModel, ecModel, api, payload) {
    if (payload && payload.from != null && payload.from !== this.uid) {
      return;
    }
    this._layoutId = 0;
    this.groupGL.remove(this._forceEdgesMesh);
    this.groupGL.add(this._edgesMesh);
    if (!this._forceLayoutInstance) {
      return;
    }
    if (!this.viewGL.layer) {
      return;
    }
    if (!(payload && payload.beforeLayout)) {
      this._syncNodePosition(seriesModel);
      this._updateAfterLayout(seriesModel, ecModel, api);
    }
    this._api.getZr().refresh();
    this._layouting = false;
  },
  _syncNodePosition: function(seriesModel) {
    var points = this._forceLayoutInstance.getNodePosition(this.viewGL.layer.renderer);
    seriesModel.getData().setLayout("points", points);
    seriesModel.setNodePosition(points);
  },
  _updateAfterLayout: function(seriesModel, ecModel, api) {
    this._updateMeshLinesGeometry();
    this._pointsBuilder.removePositionTexture();
    this._pointsBuilder.updateLayout(seriesModel, ecModel, api);
    this._pointsBuilder.updateView(this.viewGL.camera);
    this._pointsBuilder.updateLabels();
    this._pointsBuilder.showLabels();
  },
  focusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
    var data = this._model.getData();
    this._downplayAll();
    var dataIndex = payload.dataIndex;
    var graph = data.graph;
    var focusNodes = [];
    var node = graph.getNodeByIndex(dataIndex);
    focusNodes.push(node);
    node.edges.forEach(function(edge) {
      if (edge.dataIndex < 0) {
        return;
      }
      edge.node1 !== node && focusNodes.push(edge.node1);
      edge.node2 !== node && focusNodes.push(edge.node2);
    }, this);
    this._pointsBuilder.fadeOutAll(0.05);
    this._fadeOutEdgesAll(0.05);
    focusNodes.forEach(function(node2) {
      this._pointsBuilder.highlight(data, node2.dataIndex);
    }, this);
    this._pointsBuilder.updateLabels(focusNodes.map(function(node2) {
      return node2.dataIndex;
    }));
    var focusEdges = [];
    node.edges.forEach(function(edge) {
      if (edge.dataIndex >= 0) {
        this._highlightEdge(edge.dataIndex);
        focusEdges.push(edge);
      }
    }, this);
    this._focusNodes = focusNodes;
    this._focusEdges = focusEdges;
  },
  unfocusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
    this._downplayAll();
    this._pointsBuilder.fadeInAll();
    this._fadeInEdgesAll();
    this._pointsBuilder.updateLabels();
  },
  _highlightEdge: function(dataIndex) {
    var itemModel = this._model.getEdgeData().getItemModel(dataIndex);
    var emphasisColor = graphicGL_default.parseColor(itemModel.get("emphasis.lineStyle.color") || itemModel.get("lineStyle.color"));
    var emphasisOpacity = retrieve_default.firstNotNull(itemModel.get("emphasis.lineStyle.opacity"), itemModel.get("lineStyle.opacity"), 1);
    emphasisColor[3] *= emphasisOpacity;
    this._edgesMesh.geometry.setItemColor(this._edgeIndicesMap[dataIndex], emphasisColor);
  },
  _downplayAll: function() {
    if (this._focusNodes) {
      this._focusNodes.forEach(function(node) {
        this._pointsBuilder.downplay(this._model.getData(), node.dataIndex);
      }, this);
    }
    if (this._focusEdges) {
      this._focusEdges.forEach(function(edge) {
        this._downplayEdge(edge.dataIndex);
      }, this);
    }
  },
  _downplayEdge: function(dataIndex) {
    var color = this._getColor(dataIndex, []);
    this._edgesMesh.geometry.setItemColor(this._edgeIndicesMap[dataIndex], color);
  },
  _setEdgeFade: function() {
    var color = [];
    return function(dataIndex, percent) {
      this._getColor(dataIndex, color);
      color[3] *= percent;
      this._edgesMesh.geometry.setItemColor(this._edgeIndicesMap[dataIndex], color);
    };
  }(),
  _getColor: function(dataIndex, out) {
    for (var i = 0; i < 4; i++) {
      out[i] = this._originalEdgeColors[dataIndex * 4 + i];
    }
    return out;
  },
  _fadeOutEdgesAll: function(percent) {
    var graph = this._model.getData().graph;
    graph.eachEdge(function(edge) {
      this._setEdgeFade(edge.dataIndex, percent);
    }, this);
  },
  _fadeInEdgesAll: function() {
    this._fadeOutEdgesAll(1);
  },
  _updateCamera: function(seriesModel, api) {
    this.viewGL.setViewport(0, 0, api.getWidth(), api.getHeight(), api.getDevicePixelRatio());
    var camera = this.viewGL.camera;
    var nodeData = seriesModel.getData();
    var points = nodeData.getLayout("points");
    var min = vec23.create(Infinity, Infinity);
    var max = vec23.create(-Infinity, -Infinity);
    var pt = [];
    for (var i = 0; i < points.length; ) {
      pt[0] = points[i++];
      pt[1] = points[i++];
      vec23.min(min, min, pt);
      vec23.max(max, max, pt);
    }
    var cy = (max[1] + min[1]) / 2;
    var cx = (max[0] + min[0]) / 2;
    if (cx > camera.left && cx < camera.right && cy < camera.bottom && cy > camera.top) {
      return;
    }
    var width = Math.max(max[0] - min[0], 10);
    var height = width / api.getWidth() * api.getHeight();
    width *= 1.4;
    height *= 1.4;
    min[0] -= width * 0.2;
    camera.left = min[0];
    camera.top = cy - height / 2;
    camera.bottom = cy + height / 2;
    camera.right = width + min[0];
    camera.near = 0;
    camera.far = 100;
  },
  dispose: function() {
    var renderer = this.viewGL.layer.renderer;
    if (this._forceLayoutInstance) {
      this._forceLayoutInstance.dispose(renderer);
    }
    this.groupGL.removeAll();
    this._layoutId = -1;
    this._pointsBuilder.dispose();
  },
  remove: function() {
    this.groupGL.removeAll();
    this._control.dispose();
  }
});

// node_modules/echarts-gl/lib/chart/graphGL/install.js
function normalize2(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }
  return a;
}
function install10(registers) {
  registers.registerChartView(GraphGLView_default);
  registers.registerSeriesModel(GraphGLSeries_default);
  registers.registerVisual(function(ecModel) {
    const paletteScope = {};
    ecModel.eachSeriesByType("graphGL", function(seriesModel) {
      var categoriesData = seriesModel.getCategoriesData();
      var data = seriesModel.getData();
      var categoryNameIdxMap = {};
      categoriesData.each(function(idx) {
        var name = categoriesData.getName(idx);
        categoryNameIdxMap["ec-" + name] = idx;
        var itemModel = categoriesData.getItemModel(idx);
        var style = itemModel.getModel("itemStyle").getItemStyle();
        if (!style.fill) {
          style.fill = seriesModel.getColorFromPalette(name, paletteScope);
        }
        categoriesData.setItemVisual(idx, "style", style);
        var symbolVisualList = ["symbol", "symbolSize", "symbolKeepAspect"];
        for (let i = 0; i < symbolVisualList.length; i++) {
          var symbolVisual = itemModel.getShallow(symbolVisualList[i], true);
          if (symbolVisual != null) {
            categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual);
          }
        }
      });
      if (categoriesData.count()) {
        data.each(function(idx) {
          var model = data.getItemModel(idx);
          let categoryIdx = model.getShallow("category");
          if (categoryIdx != null) {
            if (typeof categoryIdx === "string") {
              categoryIdx = categoryNameIdxMap["ec-" + categoryIdx];
            }
            var categoryStyle = categoriesData.getItemVisual(categoryIdx, "style");
            var style = data.ensureUniqueItemVisual(idx, "style");
            util_exports.extend(style, categoryStyle);
            var visualList = ["symbol", "symbolSize", "symbolKeepAspect"];
            for (let i = 0; i < visualList.length; i++) {
              data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]));
            }
          }
        });
      }
    });
  });
  registers.registerVisual(function(ecModel) {
    ecModel.eachSeriesByType("graphGL", function(seriesModel) {
      var graph = seriesModel.getGraph();
      var edgeData = seriesModel.getEdgeData();
      var symbolType = normalize2(seriesModel.get("edgeSymbol"));
      var symbolSize = normalize2(seriesModel.get("edgeSymbolSize"));
      edgeData.setVisual("drawType", "stroke");
      edgeData.setVisual("fromSymbol", symbolType && symbolType[0]);
      edgeData.setVisual("toSymbol", symbolType && symbolType[1]);
      edgeData.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
      edgeData.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
      edgeData.setVisual("style", seriesModel.getModel("lineStyle").getLineStyle());
      edgeData.each(function(idx) {
        var itemModel = edgeData.getItemModel(idx);
        var edge = graph.getEdgeByIndex(idx);
        var symbolType2 = normalize2(itemModel.getShallow("symbol", true));
        var symbolSize2 = normalize2(itemModel.getShallow("symbolSize", true));
        var style = itemModel.getModel("lineStyle").getLineStyle();
        var existsStyle = edgeData.ensureUniqueItemVisual(idx, "style");
        util_exports.extend(existsStyle, style);
        switch (existsStyle.stroke) {
          case "source": {
            var nodeStyle = edge.node1.getVisual("style");
            existsStyle.stroke = nodeStyle && nodeStyle.fill;
            break;
          }
          case "target": {
            var nodeStyle = edge.node2.getVisual("style");
            existsStyle.stroke = nodeStyle && nodeStyle.fill;
            break;
          }
        }
        symbolType2[0] && edge.setVisual("fromSymbol", symbolType2[0]);
        symbolType2[1] && edge.setVisual("toSymbol", symbolType2[1]);
        symbolSize2[0] && edge.setVisual("fromSymbolSize", symbolSize2[0]);
        symbolSize2[1] && edge.setVisual("toSymbolSize", symbolSize2[1]);
      });
    });
  });
  registers.registerAction({
    type: "graphGLRoam",
    event: "graphglroam",
    update: "series.graphGL:roam"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      query: payload
    }, function(componentModel) {
      componentModel.setView(payload);
    });
  });
  function noop() {
  }
  registers.registerAction({
    type: "graphGLStartLayout",
    event: "graphgllayoutstarted",
    update: "series.graphGL:startLayout"
  }, noop);
  registers.registerAction({
    type: "graphGLStopLayout",
    event: "graphgllayoutstopped",
    update: "series.graphGL:stopLayout"
  }, noop);
  registers.registerAction({
    type: "graphGLFocusNodeAdjacency",
    event: "graphGLFocusNodeAdjacency",
    update: "series.graphGL:focusNodeAdjacency"
  }, noop);
  registers.registerAction({
    type: "graphGLUnfocusNodeAdjacency",
    event: "graphGLUnfocusNodeAdjacency",
    update: "series.graphGL:unfocusNodeAdjacency"
  }, noop);
}

// node_modules/echarts-gl/lib/chart/flowGL/FlowGLSeries.js
var FlowGLSeries_default = Series_default.extend({
  type: "series.flowGL",
  dependencies: ["geo", "grid", "bmap"],
  visualStyleAccessPath: "itemStyle",
  getInitialData: function(option, ecModel) {
    var coordType = this.get("coordinateSystem");
    var coordSysDimensions = coordType === "geo" ? ["lng", "lat"] : getCoordinateSystemDimensions(coordType) || ["x", "y"];
    if (true) {
      if (coordSysDimensions.length > 2) {
        throw new Error("flowGL can only be used on 2d coordinate systems.");
      }
    }
    coordSysDimensions.push("vx", "vy");
    var dimensions = helper_exports.createDimensions(this.getSource(), {
      coordDimensions: coordSysDimensions,
      encodeDefine: this.get("encode"),
      dimensionsDefine: this.get("dimensions")
    });
    var data = new SeriesData_default(dimensions, this);
    data.initData(this.getSource());
    return data;
  },
  defaultOption: {
    coordinateSystem: "cartesian2d",
    zlevel: 10,
    supersampling: 1,
    // 128x128 particles
    particleType: "point",
    particleDensity: 128,
    particleSize: 1,
    particleSpeed: 1,
    particleTrail: 2,
    colorTexture: null,
    gridWidth: "auto",
    gridHeight: "auto",
    itemStyle: {
      color: "#fff",
      opacity: 0.8
    }
  }
});

// node_modules/echarts-gl/lib/chart/flowGL/Line2D.js
var LinesGeometry2 = Geometry_default.extend(
  function() {
    return {
      dynamic: true,
      attributes: {
        position: new Geometry_default.Attribute("position", "float", 3, "POSITION")
      }
    };
  },
  /** @lends module: echarts-gl/util/geometry/LinesGeometry.prototype */
  {
    /**
     * Reset offset
     */
    resetOffset: function() {
      this._vertexOffset = 0;
      this._faceOffset = 0;
    },
    /**
     * @param {number} nVertex
     */
    setLineCount: function(nLine) {
      var attributes = this.attributes;
      var nVertex = 4 * nLine;
      var nTriangle = 2 * nLine;
      if (this.vertexCount !== nVertex) {
        attributes.position.init(nVertex);
      }
      if (this.triangleCount !== nTriangle) {
        if (nTriangle === 0) {
          this.indices = null;
        } else {
          this.indices = this.vertexCount > 65535 ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);
        }
      }
    },
    addLine: function(p) {
      var vertexOffset = this._vertexOffset;
      this.attributes.position.set(vertexOffset, [p[0], p[1], 1]);
      this.attributes.position.set(vertexOffset + 1, [p[0], p[1], -1]);
      this.attributes.position.set(vertexOffset + 2, [p[0], p[1], 2]);
      this.attributes.position.set(vertexOffset + 3, [p[0], p[1], -2]);
      this.setTriangleIndices(this._faceOffset++, [vertexOffset, vertexOffset + 1, vertexOffset + 2]);
      this.setTriangleIndices(this._faceOffset++, [vertexOffset + 1, vertexOffset + 2, vertexOffset + 3]);
      this._vertexOffset += 4;
    }
  }
);
var Line2D_default = LinesGeometry2;

// node_modules/echarts-gl/lib/chart/flowGL/vectorFieldParticle.glsl.js
var vectorFieldParticle_glsl_default = "@export ecgl.vfParticle.particle.fragment\n\nuniform sampler2D particleTexture;\nuniform sampler2D spawnTexture;\nuniform sampler2D velocityTexture;\n\nuniform float deltaTime;\nuniform float elapsedTime;\n\nuniform float speedScaling : 1.0;\n\nuniform vec2 textureSize;\nuniform vec4 region : [0, 0, 1, 1];\nuniform float firstFrameTime;\n\nvarying vec2 v_Texcoord;\n\n\nvoid main()\n{\n vec4 p = texture2D(particleTexture, v_Texcoord);\n bool spawn = false;\n if (p.w <= 0.0) {\n p = texture2D(spawnTexture, fract(v_Texcoord + elapsedTime / 10.0));\n p.w -= firstFrameTime;\n spawn = true;\n }\n vec2 v = texture2D(velocityTexture, fract(p.xy * region.zw + region.xy)).xy;\n v = (v - 0.5) * 2.0;\n p.z = length(v);\n p.xy += v * deltaTime / 10.0 * speedScaling;\n p.w -= deltaTime;\n\n if (spawn || p.xy != fract(p.xy)) {\n p.z = 0.0;\n }\n p.xy = fract(p.xy);\n\n gl_FragColor = p;\n}\n@end\n\n@export ecgl.vfParticle.renderPoints.vertex\n\n#define PI 3.1415926\n\nattribute vec2 texcoord : TEXCOORD_0;\n\nuniform sampler2D particleTexture;\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nuniform float size : 1.0;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\nvoid main()\n{\n vec4 p = texture2D(particleTexture, texcoord);\n\n if (p.w > 0.0 && p.z > 1e-5) {\n gl_Position = worldViewProjection * vec4(p.xy * 2.0 - 1.0, 0.0, 1.0);\n }\n else {\n gl_Position = vec4(100000.0, 100000.0, 100000.0, 1.0);\n }\n\n v_Mag = p.z;\n v_Uv = p.xy;\n\n gl_PointSize = size;\n}\n\n@end\n\n@export ecgl.vfParticle.renderPoints.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nuniform sampler2D gradientTexture;\nuniform sampler2D colorTexture;\nuniform sampler2D spriteTexture;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\nvoid main()\n{\n gl_FragColor = color;\n#ifdef SPRITETEXTURE_ENABLED\n gl_FragColor *= texture2D(spriteTexture, gl_PointCoord);\n if (color.a == 0.0) {\n discard;\n }\n#endif\n#ifdef GRADIENTTEXTURE_ENABLED\n gl_FragColor *= texture2D(gradientTexture, vec2(v_Mag, 0.5));\n#endif\n#ifdef COLORTEXTURE_ENABLED\n gl_FragColor *= texture2D(colorTexture, v_Uv);\n#endif\n}\n\n@end\n\n@export ecgl.vfParticle.renderLines.vertex\n\n#define PI 3.1415926\n\nattribute vec3 position : POSITION;\n\nuniform sampler2D particleTexture;\nuniform sampler2D prevParticleTexture;\n\nuniform float size : 1.0;\nuniform vec4 vp: VIEWPORT;\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\n@import clay.util.rand\n\nvoid main()\n{\n vec4 p = texture2D(particleTexture, position.xy);\n vec4 p2 = texture2D(prevParticleTexture, position.xy);\n\n p.xy = p.xy * 2.0 - 1.0;\n p2.xy = p2.xy * 2.0 - 1.0;\n\n if (p.w > 0.0 && p.z > 1e-5) {\n vec2 dir = normalize(p.xy - p2.xy);\n vec2 norm = vec2(dir.y / vp.z, -dir.x / vp.w) * sign(position.z) * size;\n if (abs(position.z) == 2.0) {\n gl_Position = vec4(p.xy + norm, 0.0, 1.0);\n v_Uv = p.xy;\n v_Mag = p.z;\n }\n else {\n gl_Position = vec4(p2.xy + norm, 0.0, 1.0);\n v_Mag = p2.z;\n v_Uv = p2.xy;\n }\n gl_Position = worldViewProjection * gl_Position;\n }\n else {\n gl_Position = vec4(100000.0, 100000.0, 100000.0, 1.0);\n }\n}\n\n@end\n\n@export ecgl.vfParticle.renderLines.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nuniform sampler2D gradientTexture;\nuniform sampler2D colorTexture;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\nvoid main()\n{\n gl_FragColor = color;\n #ifdef GRADIENTTEXTURE_ENABLED\n gl_FragColor *= texture2D(gradientTexture, vec2(v_Mag, 0.5));\n#endif\n#ifdef COLORTEXTURE_ENABLED\n gl_FragColor *= texture2D(colorTexture, v_Uv);\n#endif\n}\n\n@end\n";

// node_modules/echarts-gl/lib/chart/flowGL/VectorFieldParticleSurface.js
Shader_default["import"](vectorFieldParticle_glsl_default);
function createSpriteCanvas(size) {
  var canvas = document.createElement("canvas");
  canvas.width = canvas.height = size;
  var ctx = canvas.getContext("2d");
  ctx.fillStyle = "#fff";
  ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
  ctx.fill();
  return canvas;
}
var VectorFieldParticleSurface = function() {
  this.motionBlurFactor = 0.99;
  this.vectorFieldTexture = new Texture2D_default({
    type: Texture_default.FLOAT,
    // minFilter: Texture.NEAREST,
    // magFilter: Texture.NEAREST,
    flipY: false
  });
  this.particleLife = [5, 20];
  this._particleType = "point";
  this._particleSize = 1;
  this.particleColor = [1, 1, 1, 1];
  this.particleSpeedScaling = 1;
  this._thisFrameTexture = null;
  this._particlePass = null;
  this._spawnTexture = null;
  this._particleTexture0 = null;
  this._particleTexture1 = null;
  this._particlePointsMesh = null;
  this._surfaceFrameBuffer = null;
  this._elapsedTime = 0;
  this._scene = null;
  this._camera = null;
  this._lastFrameTexture = null;
  this._supersampling = 1;
  this._downsampleTextures = [];
  this._width = 512;
  this._height = 512;
  this.init();
};
VectorFieldParticleSurface.prototype = {
  constructor: VectorFieldParticleSurface,
  init: function() {
    var parameters = {
      type: Texture_default.FLOAT,
      minFilter: Texture_default.NEAREST,
      magFilter: Texture_default.NEAREST,
      useMipmap: false
    };
    this._spawnTexture = new Texture2D_default(parameters);
    this._particleTexture0 = new Texture2D_default(parameters);
    this._particleTexture1 = new Texture2D_default(parameters);
    this._frameBuffer = new FrameBuffer_default({
      depthBuffer: false
    });
    this._particlePass = new Pass_default({
      fragment: Shader_default.source("ecgl.vfParticle.particle.fragment")
    });
    this._particlePass.setUniform("velocityTexture", this.vectorFieldTexture);
    this._particlePass.setUniform("spawnTexture", this._spawnTexture);
    this._downsamplePass = new Pass_default({
      fragment: Shader_default.source("clay.compositor.downsample")
    });
    var particlePointsMesh = new Mesh_default({
      // Render after last frame full quad
      renderOrder: 10,
      material: new Material_default({
        shader: new Shader_default(Shader_default.source("ecgl.vfParticle.renderPoints.vertex"), Shader_default.source("ecgl.vfParticle.renderPoints.fragment"))
      }),
      mode: Mesh_default.POINTS,
      geometry: new Geometry_default({
        dynamic: true,
        mainAttribute: "texcoord0"
      })
    });
    var particleLinesMesh = new Mesh_default({
      // Render after last frame full quad
      renderOrder: 10,
      material: new Material_default({
        shader: new Shader_default(Shader_default.source("ecgl.vfParticle.renderLines.vertex"), Shader_default.source("ecgl.vfParticle.renderLines.fragment"))
      }),
      geometry: new Line2D_default(),
      culling: false
    });
    var lastFrameFullQuad = new Mesh_default({
      material: new Material_default({
        shader: new Shader_default(Shader_default.source("ecgl.color.vertex"), Shader_default.source("ecgl.color.fragment"))
        // DO NOT BLEND Blend will multiply alpha
        // transparent: true
      }),
      geometry: new Plane_default()
    });
    lastFrameFullQuad.material.enableTexture("diffuseMap");
    this._particlePointsMesh = particlePointsMesh;
    this._particleLinesMesh = particleLinesMesh;
    this._lastFrameFullQuadMesh = lastFrameFullQuad;
    this._camera = new Orthographic_default();
    this._thisFrameTexture = new Texture2D_default();
    this._lastFrameTexture = new Texture2D_default();
  },
  setParticleDensity: function(width, height) {
    var nVertex = width * height;
    var spawnTextureData = new Float32Array(nVertex * 4);
    var off = 0;
    var lifeRange = this.particleLife;
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++, off++) {
        spawnTextureData[off * 4] = Math.random();
        spawnTextureData[off * 4 + 1] = Math.random();
        spawnTextureData[off * 4 + 2] = Math.random();
        var life = (lifeRange[1] - lifeRange[0]) * Math.random() + lifeRange[0];
        spawnTextureData[off * 4 + 3] = life;
      }
    }
    if (this._particleType === "line") {
      this._setLineGeometry(width, height);
    } else {
      this._setPointsGeometry(width, height);
    }
    this._spawnTexture.width = width;
    this._spawnTexture.height = height;
    this._spawnTexture.pixels = spawnTextureData;
    this._particleTexture0.width = this._particleTexture1.width = width;
    this._particleTexture0.height = this._particleTexture1.height = height;
    this._particlePass.setUniform("textureSize", [width, height]);
  },
  _setPointsGeometry: function(width, height) {
    var nVertex = width * height;
    var geometry = this._particlePointsMesh.geometry;
    var attributes = geometry.attributes;
    attributes.texcoord0.init(nVertex);
    var off = 0;
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++, off++) {
        attributes.texcoord0.value[off * 2] = i / width;
        attributes.texcoord0.value[off * 2 + 1] = j / height;
      }
    }
    geometry.dirty();
  },
  _setLineGeometry: function(width, height) {
    var nLine = width * height;
    var geometry = this._getParticleMesh().geometry;
    geometry.setLineCount(nLine);
    geometry.resetOffset();
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++) {
        geometry.addLine([i / width, j / height]);
      }
    }
    geometry.dirty();
  },
  _getParticleMesh: function() {
    return this._particleType === "line" ? this._particleLinesMesh : this._particlePointsMesh;
  },
  update: function(renderer, api, deltaTime, firstFrame) {
    var particleMesh = this._getParticleMesh();
    var frameBuffer = this._frameBuffer;
    var particlePass = this._particlePass;
    if (firstFrame) {
      this._updateDownsampleTextures(renderer, api);
    }
    particleMesh.material.set("size", this._particleSize * this._supersampling);
    particleMesh.material.set("color", this.particleColor);
    particlePass.setUniform("speedScaling", this.particleSpeedScaling);
    frameBuffer.attach(this._particleTexture1);
    particlePass.setUniform("firstFrameTime", firstFrame ? (this.particleLife[1] + this.particleLife[0]) / 2 : 0);
    particlePass.setUniform("particleTexture", this._particleTexture0);
    particlePass.setUniform("deltaTime", deltaTime);
    particlePass.setUniform("elapsedTime", this._elapsedTime);
    particlePass.render(renderer, frameBuffer);
    particleMesh.material.set("particleTexture", this._particleTexture1);
    particleMesh.material.set("prevParticleTexture", this._particleTexture0);
    frameBuffer.attach(this._thisFrameTexture);
    frameBuffer.bind(renderer);
    renderer.gl.clear(renderer.gl.DEPTH_BUFFER_BIT | renderer.gl.COLOR_BUFFER_BIT);
    var lastFrameFullQuad = this._lastFrameFullQuadMesh;
    lastFrameFullQuad.material.set("diffuseMap", this._lastFrameTexture);
    lastFrameFullQuad.material.set("color", [1, 1, 1, this.motionBlurFactor]);
    this._camera.update(true);
    renderer.renderPass([lastFrameFullQuad, particleMesh], this._camera);
    frameBuffer.unbind(renderer);
    this._downsample(renderer);
    this._swapTexture();
    this._elapsedTime += deltaTime;
  },
  _downsample: function(renderer) {
    var downsampleTextures = this._downsampleTextures;
    if (downsampleTextures.length === 0) {
      return;
    }
    var current = 0;
    var sourceTexture = this._thisFrameTexture;
    var targetTexture = downsampleTextures[current];
    while (targetTexture) {
      this._frameBuffer.attach(targetTexture);
      this._downsamplePass.setUniform("texture", sourceTexture);
      this._downsamplePass.setUniform("textureSize", [sourceTexture.width, sourceTexture.height]);
      this._downsamplePass.render(renderer, this._frameBuffer);
      sourceTexture = targetTexture;
      targetTexture = downsampleTextures[++current];
    }
  },
  getSurfaceTexture: function() {
    var downsampleTextures = this._downsampleTextures;
    return downsampleTextures.length > 0 ? downsampleTextures[downsampleTextures.length - 1] : this._lastFrameTexture;
  },
  setRegion: function(region) {
    this._particlePass.setUniform("region", region);
  },
  resize: function(width, height) {
    this._lastFrameTexture.width = width * this._supersampling;
    this._lastFrameTexture.height = height * this._supersampling;
    this._thisFrameTexture.width = width * this._supersampling;
    this._thisFrameTexture.height = height * this._supersampling;
    this._width = width;
    this._height = height;
  },
  setParticleSize: function(size) {
    var particleMesh = this._getParticleMesh();
    if (size <= 2) {
      particleMesh.material.disableTexture("spriteTexture");
      particleMesh.material.transparent = false;
      return;
    }
    if (!this._spriteTexture) {
      this._spriteTexture = new Texture2D_default();
    }
    if (!this._spriteTexture.image || this._spriteTexture.image.width !== size) {
      this._spriteTexture.image = createSpriteCanvas(size);
      this._spriteTexture.dirty();
    }
    particleMesh.material.transparent = true;
    particleMesh.material.enableTexture("spriteTexture");
    particleMesh.material.set("spriteTexture", this._spriteTexture);
    this._particleSize = size;
  },
  setGradientTexture: function(gradientTexture) {
    var material = this._getParticleMesh().material;
    material[gradientTexture ? "enableTexture" : "disableTexture"]("gradientTexture");
    material.setUniform("gradientTexture", gradientTexture);
  },
  setColorTextureImage: function(colorTextureImg, api) {
    var material = this._getParticleMesh().material;
    material.setTextureImage("colorTexture", colorTextureImg, api, {
      flipY: true
    });
  },
  setParticleType: function(type) {
    this._particleType = type;
  },
  clearFrame: function(renderer) {
    var frameBuffer = this._frameBuffer;
    frameBuffer.attach(this._lastFrameTexture);
    frameBuffer.bind(renderer);
    renderer.gl.clear(renderer.gl.DEPTH_BUFFER_BIT | renderer.gl.COLOR_BUFFER_BIT);
    frameBuffer.unbind(renderer);
  },
  setSupersampling: function(supersampling) {
    this._supersampling = supersampling;
    this.resize(this._width, this._height);
  },
  _updateDownsampleTextures: function(renderer, api) {
    var downsampleTextures = this._downsampleTextures;
    var upScale = Math.max(Math.floor(Math.log(this._supersampling / api.getDevicePixelRatio()) / Math.log(2)), 0);
    var scale = 2;
    var width = this._width * this._supersampling;
    var height = this._height * this._supersampling;
    for (var i = 0; i < upScale; i++) {
      downsampleTextures[i] = downsampleTextures[i] || new Texture2D_default();
      downsampleTextures[i].width = width / scale;
      downsampleTextures[i].height = height / scale;
      scale *= 2;
    }
    for (; i < downsampleTextures.length; i++) {
      downsampleTextures[i].dispose(renderer);
    }
    downsampleTextures.length = upScale;
  },
  _swapTexture: function() {
    var tmp = this._particleTexture0;
    this._particleTexture0 = this._particleTexture1;
    this._particleTexture1 = tmp;
    var tmp = this._thisFrameTexture;
    this._thisFrameTexture = this._lastFrameTexture;
    this._lastFrameTexture = tmp;
  },
  dispose: function(renderer) {
    renderer.disposeFrameBuffer(this._frameBuffer);
    renderer.disposeTexture(this.vectorFieldTexture);
    renderer.disposeTexture(this._spawnTexture);
    renderer.disposeTexture(this._particleTexture0);
    renderer.disposeTexture(this._particleTexture1);
    renderer.disposeTexture(this._thisFrameTexture);
    renderer.disposeTexture(this._lastFrameTexture);
    renderer.disposeGeometry(this._particleLinesMesh.geometry);
    renderer.disposeGeometry(this._particlePointsMesh.geometry);
    renderer.disposeGeometry(this._lastFrameFullQuadMesh.geometry);
    if (this._spriteTexture) {
      renderer.disposeTexture(this._spriteTexture);
    }
    this._particlePass.dispose(renderer);
    this._downsamplePass.dispose(renderer);
    this._downsampleTextures.forEach(function(texture) {
      texture.dispose(renderer);
    });
  }
};
var VectorFieldParticleSurface_default = VectorFieldParticleSurface;

// node_modules/echarts-gl/lib/chart/flowGL/FlowGLView.js
var FlowGLView_default = Chart_default.extend({
  type: "flowGL",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.viewGL = new ViewGL_default("orthographic");
    this.groupGL = new graphicGL_default.Node();
    this.viewGL.add(this.groupGL);
    this._particleSurface = new VectorFieldParticleSurface_default();
    var planeMesh = new graphicGL_default.Mesh({
      geometry: new graphicGL_default.PlaneGeometry(),
      material: new graphicGL_default.Material({
        shader: new graphicGL_default.Shader({
          vertex: graphicGL_default.Shader.source("ecgl.color.vertex"),
          fragment: graphicGL_default.Shader.source("ecgl.color.fragment")
        }),
        // Must enable blending and multiply alpha.
        // Or premultipliedAlpha will let the alpha useless.
        transparent: true
      })
    });
    planeMesh.material.enableTexture("diffuseMap");
    this.groupGL.add(planeMesh);
    this._planeMesh = planeMesh;
  },
  render: function(seriesModel, ecModel, api) {
    var particleSurface = this._particleSurface;
    particleSurface.setParticleType(seriesModel.get("particleType"));
    particleSurface.setSupersampling(seriesModel.get("supersampling"));
    this._updateData(seriesModel, api);
    this._updateCamera(api.getWidth(), api.getHeight(), api.getDevicePixelRatio());
    var particleDensity = retrieve_default.firstNotNull(seriesModel.get("particleDensity"), 128);
    particleSurface.setParticleDensity(particleDensity, particleDensity);
    var planeMesh = this._planeMesh;
    var time = +/* @__PURE__ */ new Date();
    var self2 = this;
    var firstFrame = true;
    planeMesh.__percent = 0;
    planeMesh.stopAnimation();
    planeMesh.animate("", {
      loop: true
    }).when(1e5, {
      __percent: 1
    }).during(function() {
      var timeNow = +/* @__PURE__ */ new Date();
      var dTime = Math.min(timeNow - time, 20);
      time = time + dTime;
      if (self2._renderer) {
        particleSurface.update(self2._renderer, api, dTime / 1e3, firstFrame);
        planeMesh.material.set("diffuseMap", particleSurface.getSurfaceTexture());
      }
      firstFrame = false;
    }).start();
    var itemStyleModel = seriesModel.getModel("itemStyle");
    var color = graphicGL_default.parseColor(itemStyleModel.get("color"));
    color[3] *= retrieve_default.firstNotNull(itemStyleModel.get("opacity"), 1);
    planeMesh.material.set("color", color);
    particleSurface.setColorTextureImage(seriesModel.get("colorTexture"), api);
    particleSurface.setParticleSize(seriesModel.get("particleSize"));
    particleSurface.particleSpeedScaling = seriesModel.get("particleSpeed");
    particleSurface.motionBlurFactor = 1 - Math.pow(0.1, seriesModel.get("particleTrail"));
  },
  updateTransform: function(seriesModel, ecModel, api) {
    this._updateData(seriesModel, api);
  },
  afterRender: function(globeModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    this._renderer = renderer;
  },
  _updateData: function(seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var dims = coordSys.dimensions.map(function(coordDim) {
      return seriesModel.coordDimToDataDim(coordDim)[0];
    });
    var data = seriesModel.getData();
    var xExtent = data.getDataExtent(dims[0]);
    var yExtent = data.getDataExtent(dims[1]);
    var gridWidth = seriesModel.get("gridWidth");
    var gridHeight = seriesModel.get("gridHeight");
    if (gridWidth == null || gridWidth === "auto") {
      var aspect = (xExtent[1] - xExtent[0]) / (yExtent[1] - yExtent[0]);
      gridWidth = Math.round(Math.sqrt(aspect * data.count()));
    }
    if (gridHeight == null || gridHeight === "auto") {
      gridHeight = Math.ceil(data.count() / gridWidth);
    }
    var vectorFieldTexture = this._particleSurface.vectorFieldTexture;
    var pixels = vectorFieldTexture.pixels;
    if (!pixels || pixels.length !== gridHeight * gridWidth * 4) {
      pixels = vectorFieldTexture.pixels = new Float32Array(gridWidth * gridHeight * 4);
    } else {
      for (var i = 0; i < pixels.length; i++) {
        pixels[i] = 0;
      }
    }
    var maxMag = 0;
    var minMag = Infinity;
    var points = new Float32Array(data.count() * 2);
    var offset = 0;
    var bbox = [[Infinity, Infinity], [-Infinity, -Infinity]];
    data.each([dims[0], dims[1], "vx", "vy"], function(x, y, vx, vy) {
      var pt = coordSys.dataToPoint([x, y]);
      points[offset++] = pt[0];
      points[offset++] = pt[1];
      bbox[0][0] = Math.min(pt[0], bbox[0][0]);
      bbox[0][1] = Math.min(pt[1], bbox[0][1]);
      bbox[1][0] = Math.max(pt[0], bbox[1][0]);
      bbox[1][1] = Math.max(pt[1], bbox[1][1]);
      var mag = Math.sqrt(vx * vx + vy * vy);
      maxMag = Math.max(maxMag, mag);
      minMag = Math.min(minMag, mag);
    });
    data.each(["vx", "vy"], function(vx, vy, i2) {
      var xPix = Math.round((points[i2 * 2] - bbox[0][0]) / (bbox[1][0] - bbox[0][0]) * (gridWidth - 1));
      var yPix = gridHeight - 1 - Math.round((points[i2 * 2 + 1] - bbox[0][1]) / (bbox[1][1] - bbox[0][1]) * (gridHeight - 1));
      var idx = (yPix * gridWidth + xPix) * 4;
      pixels[idx] = vx / maxMag * 0.5 + 0.5;
      pixels[idx + 1] = vy / maxMag * 0.5 + 0.5;
      pixels[idx + 3] = 1;
    });
    vectorFieldTexture.width = gridWidth;
    vectorFieldTexture.height = gridHeight;
    if (seriesModel.get("coordinateSystem") === "bmap") {
      this._fillEmptyPixels(vectorFieldTexture);
    }
    vectorFieldTexture.dirty();
    this._updatePlanePosition(bbox[0], bbox[1], seriesModel, api);
    this._updateGradientTexture(data.getVisual("visualMeta"), [minMag, maxMag]);
  },
  // PENDING Use grid mesh ? or delaunay triangulation?
  _fillEmptyPixels: function(texture) {
    var pixels = texture.pixels;
    var width = texture.width;
    var height = texture.height;
    function fetchPixel(x2, y2, rg) {
      x2 = Math.max(Math.min(x2, width - 1), 0);
      y2 = Math.max(Math.min(y2, height - 1), 0);
      var idx2 = (y2 * (width - 1) + x2) * 4;
      if (pixels[idx2 + 3] === 0) {
        return false;
      }
      rg[0] = pixels[idx2];
      rg[1] = pixels[idx2 + 1];
      return true;
    }
    function addPixel(a, b, out) {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
    }
    var center = [], left = [], right = [], top = [], bottom = [];
    var weight = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var idx = (y * (width - 1) + x) * 4;
        if (pixels[idx + 3] === 0) {
          weight = center[0] = center[1] = 0;
          if (fetchPixel(x - 1, y, left)) {
            weight++;
            addPixel(left, center, center);
          }
          if (fetchPixel(x + 1, y, right)) {
            weight++;
            addPixel(right, center, center);
          }
          if (fetchPixel(x, y - 1, top)) {
            weight++;
            addPixel(top, center, center);
          }
          if (fetchPixel(x, y + 1, bottom)) {
            weight++;
            addPixel(bottom, center, center);
          }
          center[0] /= weight;
          center[1] /= weight;
          pixels[idx] = center[0];
          pixels[idx + 1] = center[1];
        }
        pixels[idx + 3] = 1;
      }
    }
  },
  _updateGradientTexture: function(visualMeta, magExtent) {
    if (!visualMeta || !visualMeta.length) {
      this._particleSurface.setGradientTexture(null);
      return;
    }
    this._gradientTexture = this._gradientTexture || new graphicGL_default.Texture2D({
      image: document.createElement("canvas")
    });
    var gradientTexture = this._gradientTexture;
    var canvas = gradientTexture.image;
    canvas.width = 200;
    canvas.height = 1;
    var ctx = canvas.getContext("2d");
    var gradient = ctx.createLinearGradient(0, 0.5, canvas.width, 0.5);
    visualMeta[0].stops.forEach(function(stop) {
      var offset;
      if (magExtent[1] === magExtent[0]) {
        offset = 0;
      } else {
        offset = stop.value / magExtent[1];
        offset = Math.min(Math.max(offset, 0), 1);
      }
      gradient.addColorStop(offset, stop.color);
    });
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    gradientTexture.dirty();
    this._particleSurface.setGradientTexture(this._gradientTexture);
  },
  _updatePlanePosition: function(leftTop, rightBottom, seriesModel, api) {
    var limitedResult = this._limitInViewportAndFullFill(leftTop, rightBottom, seriesModel, api);
    leftTop = limitedResult.leftTop;
    rightBottom = limitedResult.rightBottom;
    this._particleSurface.setRegion(limitedResult.region);
    this._planeMesh.position.set((leftTop[0] + rightBottom[0]) / 2, api.getHeight() - (leftTop[1] + rightBottom[1]) / 2, 0);
    var width = rightBottom[0] - leftTop[0];
    var height = rightBottom[1] - leftTop[1];
    this._planeMesh.scale.set(width / 2, height / 2, 1);
    this._particleSurface.resize(Math.max(Math.min(width, 2048), 1), Math.max(Math.min(height, 2048), 1));
    if (this._renderer) {
      this._particleSurface.clearFrame(this._renderer);
    }
  },
  _limitInViewportAndFullFill: function(leftTop, rightBottom, seriesModel, api) {
    var newLeftTop = [Math.max(leftTop[0], 0), Math.max(leftTop[1], 0)];
    var newRightBottom = [Math.min(rightBottom[0], api.getWidth()), Math.min(rightBottom[1], api.getHeight())];
    if (seriesModel.get("coordinateSystem") === "bmap") {
      var lngRange = seriesModel.getData().getDataExtent(seriesModel.coordDimToDataDim("lng")[0]);
      var isContinuous = Math.floor(lngRange[1] - lngRange[0]) >= 359;
      if (isContinuous) {
        if (newLeftTop[0] > 0) {
          newLeftTop[0] = 0;
        }
        if (newRightBottom[0] < api.getWidth()) {
          newRightBottom[0] = api.getWidth();
        }
      }
    }
    var width = rightBottom[0] - leftTop[0];
    var height = rightBottom[1] - leftTop[1];
    var newWidth = newRightBottom[0] - newLeftTop[0];
    var newHeight = newRightBottom[1] - newLeftTop[1];
    var region = [(newLeftTop[0] - leftTop[0]) / width, 1 - newHeight / height - (newLeftTop[1] - leftTop[1]) / height, newWidth / width, newHeight / height];
    return {
      leftTop: newLeftTop,
      rightBottom: newRightBottom,
      region
    };
  },
  _updateCamera: function(width, height, dpr) {
    this.viewGL.setViewport(0, 0, width, height, dpr);
    var camera = this.viewGL.camera;
    camera.left = camera.bottom = 0;
    camera.top = height;
    camera.right = width;
    camera.near = 0;
    camera.far = 100;
    camera.position.z = 10;
  },
  remove: function() {
    this._planeMesh.stopAnimation();
    this.groupGL.removeAll();
  },
  dispose: function() {
    if (this._renderer) {
      this._particleSurface.dispose(this._renderer);
    }
    this.groupGL.removeAll();
  }
});

// node_modules/echarts-gl/lib/chart/flowGL/install.js
function install11(registers) {
  registers.registerChartView(FlowGLView_default);
  registers.registerSeriesModel(FlowGLSeries_default);
}

// node_modules/echarts-gl/lib/chart/linesGL/LinesGLSeries.js
var LinesGLSeries = Series_default.extend({
  type: "series.linesGL",
  dependencies: ["grid", "geo"],
  visualStyleAccessPath: "lineStyle",
  visualDrawType: "stroke",
  streamEnabled: true,
  init: function(option) {
    var result = this._processFlatCoordsArray(option.data);
    this._flatCoords = result.flatCoords;
    this._flatCoordsOffset = result.flatCoordsOffset;
    if (result.flatCoords) {
      option.data = new Float32Array(result.count);
    }
    LinesGLSeries.superApply(this, "init", arguments);
  },
  mergeOption: function(option) {
    var result = this._processFlatCoordsArray(option.data);
    this._flatCoords = result.flatCoords;
    this._flatCoordsOffset = result.flatCoordsOffset;
    if (result.flatCoords) {
      option.data = new Float32Array(result.count);
    }
    LinesGLSeries.superApply(this, "mergeOption", arguments);
  },
  appendData: function(params) {
    var result = this._processFlatCoordsArray(params.data);
    if (result.flatCoords) {
      if (!this._flatCoords) {
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
      } else {
        this._flatCoords = concatArray(this._flatCoords, result.flatCoords);
        this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);
      }
      params.data = new Float32Array(result.count);
    }
    this.getRawData().appendData(params.data);
  },
  _getCoordsFromItemModel: function(idx) {
    var itemModel = this.getData().getItemModel(idx);
    var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
    if (true) {
      if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {
        throw new Error("Invalid coords " + JSON.stringify(coords) + ". Lines must have 2d coords array in data item.");
      }
    }
    return coords;
  },
  getLineCoordsCount: function(idx) {
    if (this._flatCoordsOffset) {
      return this._flatCoordsOffset[idx * 2 + 1];
    } else {
      return this._getCoordsFromItemModel(idx).length;
    }
  },
  getLineCoords: function(idx, out) {
    if (this._flatCoordsOffset) {
      var offset = this._flatCoordsOffset[idx * 2];
      var len = this._flatCoordsOffset[idx * 2 + 1];
      for (var i = 0; i < len; i++) {
        out[i] = out[i] || [];
        out[i][0] = this._flatCoords[offset + i * 2];
        out[i][1] = this._flatCoords[offset + i * 2 + 1];
      }
      return len;
    } else {
      var coords = this._getCoordsFromItemModel(idx);
      for (var i = 0; i < coords.length; i++) {
        out[i] = out[i] || [];
        out[i][0] = coords[i][0];
        out[i][1] = coords[i][1];
      }
      return coords.length;
    }
  },
  _processFlatCoordsArray: function(data) {
    var startOffset = 0;
    if (this._flatCoords) {
      startOffset = this._flatCoords.length;
    }
    if (typeof data[0] === "number") {
      var len = data.length;
      var coordsOffsetAndLenStorage = new Uint32Array(len);
      var coordsStorage = new Float64Array(len);
      var coordsCursor = 0;
      var offsetCursor = 0;
      var dataCount = 0;
      for (var i = 0; i < len; ) {
        dataCount++;
        var count = data[i++];
        coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;
        coordsOffsetAndLenStorage[offsetCursor++] = count;
        for (var k = 0; k < count; k++) {
          var x = data[i++];
          var y = data[i++];
          coordsStorage[coordsCursor++] = x;
          coordsStorage[coordsCursor++] = y;
          if (i > len) {
            if (true) {
              throw new Error("Invalid data format.");
            }
          }
        }
      }
      return {
        flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
        flatCoords: coordsStorage,
        count: dataCount
      };
    }
    return {
      flatCoordsOffset: null,
      flatCoords: null,
      count: data.length
    };
  },
  getInitialData: function(option, ecModel) {
    var lineData = new SeriesData_default(["value"], this);
    lineData.hasItemOption = false;
    lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
      if (dataItem instanceof Array) {
        return NaN;
      } else {
        lineData.hasItemOption = true;
        var value = dataItem.value;
        if (value != null) {
          return value instanceof Array ? value[dimIndex] : value;
        }
      }
    });
    return lineData;
  },
  defaultOption: {
    coordinateSystem: "geo",
    zlevel: 10,
    progressive: 1e4,
    progressiveThreshold: 5e4,
    // Cartesian coordinate system
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // Geo coordinate system
    // geoIndex: 0,
    // Support source-over, lighter
    blendMode: "source-over",
    lineStyle: {
      opacity: 0.8
    },
    postEffect: {
      enable: false,
      colorCorrection: {
        exposure: 0,
        brightness: 0,
        contrast: 1,
        saturation: 1,
        enable: true
      }
    }
  }
});
var LinesGLSeries_default = LinesGLSeries;

// node_modules/echarts-gl/lib/chart/linesGL/LinesGLView.js
var LinesGLView_default = Chart_default.extend({
  type: "linesGL",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL_default.Node();
    this.viewGL = new ViewGL_default("orthographic");
    this.viewGL.add(this.groupGL);
    this._glViewHelper = new GLViewHelper_default(this.viewGL);
    this._nativeLinesShader = graphicGL_default.createShader("ecgl.lines3D");
    this._meshLinesShader = graphicGL_default.createShader("ecgl.meshLines3D");
    this._linesMeshes = [];
    this._currentStep = 0;
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    this._glViewHelper.reset(seriesModel, api);
    var linesMesh = this._linesMeshes[0];
    if (!linesMesh) {
      linesMesh = this._linesMeshes[0] = this._createLinesMesh(seriesModel);
    }
    this._linesMeshes.length = 1;
    this.groupGL.add(linesMesh);
    this._updateLinesMesh(seriesModel, linesMesh, 0, seriesModel.getData().count());
    this.viewGL.setPostEffect(seriesModel.getModel("postEffect"), api);
  },
  incrementalPrepareRender: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    this._glViewHelper.reset(seriesModel, api);
    this._currentStep = 0;
    this.viewGL.setPostEffect(seriesModel.getModel("postEffect"), api);
  },
  incrementalRender: function(params, seriesModel, ecModel, api) {
    var linesMesh = this._linesMeshes[this._currentStep];
    if (!linesMesh) {
      linesMesh = this._createLinesMesh(seriesModel);
      this._linesMeshes[this._currentStep] = linesMesh;
    }
    this._updateLinesMesh(seriesModel, linesMesh, params.start, params.end);
    this.groupGL.add(linesMesh);
    api.getZr().refresh();
    this._currentStep++;
  },
  updateTransform: function(seriesModel, ecModel, api) {
    if (seriesModel.coordinateSystem.getRoamTransform) {
      this._glViewHelper.updateTransform(seriesModel, api);
    }
  },
  _createLinesMesh: function(seriesModel) {
    var linesMesh = new graphicGL_default.Mesh({
      $ignorePicking: true,
      material: new graphicGL_default.Material({
        shader: graphicGL_default.createShader("ecgl.lines3D"),
        transparent: true,
        depthMask: false,
        depthTest: false
      }),
      geometry: new Lines2D_default({
        segmentScale: 10,
        useNativeLine: true,
        dynamic: false
      }),
      mode: graphicGL_default.Mesh.LINES,
      culling: false
    });
    return linesMesh;
  },
  _updateLinesMesh: function(seriesModel, linesMesh, start, end) {
    var data = seriesModel.getData();
    linesMesh.material.blend = seriesModel.get("blendMode") === "lighter" ? graphicGL_default.additiveBlend : null;
    var curveness = seriesModel.get("lineStyle.curveness") || 0;
    var isPolyline = seriesModel.get("polyline");
    var geometry = linesMesh.geometry;
    var coordSys = seriesModel.coordinateSystem;
    var lineWidth = retrieve_default.firstNotNull(seriesModel.get("lineStyle.width"), 1);
    if (lineWidth > 1) {
      if (linesMesh.material.shader !== this._meshLinesShader) {
        linesMesh.material.attachShader(this._meshLinesShader);
      }
      linesMesh.mode = graphicGL_default.Mesh.TRIANGLES;
    } else {
      if (linesMesh.material.shader !== this._nativeLinesShader) {
        linesMesh.material.attachShader(this._nativeLinesShader);
      }
      linesMesh.mode = graphicGL_default.Mesh.LINES;
    }
    start = start || 0;
    end = end || data.count();
    geometry.resetOffset();
    var vertexCount = 0;
    var triangleCount = 0;
    var p0 = [];
    var p1 = [];
    var p2 = [];
    var p3 = [];
    var lineCoords = [];
    var t = 0.3;
    var t2 = 0.7;
    function updateBezierControlPoints() {
      p1[0] = p0[0] * t2 + p3[0] * t - (p0[1] - p3[1]) * curveness;
      p1[1] = p0[1] * t2 + p3[1] * t - (p3[0] - p0[0]) * curveness;
      p2[0] = p0[0] * t + p3[0] * t2 - (p0[1] - p3[1]) * curveness;
      p2[1] = p0[1] * t + p3[1] * t2 - (p3[0] - p0[0]) * curveness;
    }
    if (isPolyline || curveness !== 0) {
      for (var idx = start; idx < end; idx++) {
        if (isPolyline) {
          var count = seriesModel.getLineCoordsCount(idx);
          vertexCount += geometry.getPolylineVertexCount(count);
          triangleCount += geometry.getPolylineTriangleCount(count);
        } else {
          seriesModel.getLineCoords(idx, lineCoords);
          this._glViewHelper.dataToPoint(coordSys, lineCoords[0], p0);
          this._glViewHelper.dataToPoint(coordSys, lineCoords[1], p3);
          updateBezierControlPoints();
          vertexCount += geometry.getCubicCurveVertexCount(p0, p1, p2, p3);
          triangleCount += geometry.getCubicCurveTriangleCount(p0, p1, p2, p3);
        }
      }
    } else {
      var lineCount = end - start;
      vertexCount += lineCount * geometry.getLineVertexCount();
      triangleCount += lineCount * geometry.getLineVertexCount();
    }
    geometry.setVertexCount(vertexCount);
    geometry.setTriangleCount(triangleCount);
    var dataIndex = start;
    var colorArr = [];
    for (var idx = start; idx < end; idx++) {
      graphicGL_default.parseColor(getItemVisualColor(data, dataIndex), colorArr);
      var opacity = retrieve_default.firstNotNull(getItemVisualOpacity(data, dataIndex), 1);
      colorArr[3] *= opacity;
      var count = seriesModel.getLineCoords(idx, lineCoords);
      for (var k = 0; k < count; k++) {
        this._glViewHelper.dataToPoint(coordSys, lineCoords[k], lineCoords[k]);
      }
      if (isPolyline) {
        geometry.addPolyline(lineCoords, colorArr, lineWidth, 0, count);
      } else if (curveness !== 0) {
        p0 = lineCoords[0];
        p3 = lineCoords[1];
        updateBezierControlPoints();
        geometry.addCubicCurve(p0, p1, p2, p3, colorArr, lineWidth);
      } else {
        geometry.addPolyline(lineCoords, colorArr, lineWidth, 0, 2);
      }
      dataIndex++;
    }
  },
  dispose: function() {
    this.groupGL.removeAll();
  },
  remove: function() {
    this.groupGL.removeAll();
  }
});

// node_modules/echarts-gl/lib/chart/linesGL/install.js
function install12(registers) {
  registers.registerChartView(LinesGLView_default);
  registers.registerSeriesModel(LinesGLSeries_default);
}
export {
  install2 as Bar3DChart,
  install11 as FlowGLChart,
  install10 as GraphGLChart,
  install3 as Line3DChart,
  install5 as Lines3DChart,
  install12 as LinesGLChart,
  install8 as Map3DChart,
  install6 as Polygons3DChart,
  install4 as Scatter3DChart,
  install9 as ScatterGLChart,
  install7 as SurfaceChart
};
//# sourceMappingURL=echarts-gl_charts.js.map
