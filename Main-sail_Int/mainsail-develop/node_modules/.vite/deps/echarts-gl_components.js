import {
  Cartesian_default
} from "./chunk-ACCQ4WZC.js";
import {
  Geometry_default,
  LabelsMesh_default,
  Lines3D_default,
  OrbitControl_default,
  SceneHelper_default,
  ViewGL_default,
  ZRTextureAtlasSurface_default,
  componentLightMixin_default,
  componentPostEffectMixin_default,
  componentShadingMixin_default,
  componentViewControlMixin_default,
  dynamicConvertMixin_default,
  glmatrix_default,
  graphicGL_default,
  install,
  lines3D_glsl_default,
  retrieve_default,
  util_glsl_default
} from "./chunk-7HYBQCTF.js";
import "./chunk-O7CTSDY3.js";
import {
  graphic_exports,
  helper_exports,
  number_exports,
  util_exports
} from "./chunk-FMOBVGFJ.js";
import "./chunk-WKGB3LPG.js";
import "./chunk-6A7JVADL.js";
import "./chunk-7CAD22Y3.js";
import {
  Axis_default,
  Component_default,
  Component_default2,
  Model_default,
  OrdinalMeta_default,
  createTextStyle,
  getLayoutRect
} from "./chunk-YDTUC6Z2.js";
import "./chunk-ZEDOSNM2.js";
import "./chunk-NE6YQAF4.js";
import "./chunk-ROME4SDB.js";

// node_modules/echarts-gl/lib/component/grid3D/Grid3DModel.js
var Grid3DModel = Component_default.extend({
  type: "grid3D",
  dependencies: ["xAxis3D", "yAxis3D", "zAxis3D"],
  defaultOption: {
    show: true,
    zlevel: -10,
    // Layout used for viewport
    left: 0,
    top: 0,
    width: "100%",
    height: "100%",
    environment: "auto",
    // Dimension of grid3D
    boxWidth: 100,
    boxHeight: 100,
    boxDepth: 100,
    // Common axis options.
    axisPointer: {
      show: true,
      lineStyle: {
        color: "rgba(0, 0, 0, 0.8)",
        width: 1
      },
      label: {
        show: true,
        // (dimValue: number, value: Array) => string
        formatter: null,
        // TODO, Consider boxWidth
        margin: 8,
        // backgroundColor: '#ffbd67',
        // borderColor: '#000',
        // borderWidth: 0,
        textStyle: {
          fontSize: 14,
          color: "#fff",
          backgroundColor: "rgba(0,0,0,0.5)",
          padding: 3,
          borderRadius: 3
        }
      }
    },
    axisLine: {
      show: true,
      lineStyle: {
        color: "#333",
        width: 2,
        type: "solid"
      }
    },
    axisTick: {
      show: true,
      inside: false,
      length: 3,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      inside: false,
      rotate: 0,
      margin: 8,
      textStyle: {
        fontSize: 12
      }
    },
    splitLine: {
      show: true,
      lineStyle: {
        color: ["#ccc"],
        width: 1,
        type: "solid"
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]
      }
    },
    // Light options
    light: {
      main: {
        // Alpha angle for top-down rotation
        // Positive to rotate to top.
        alpha: 30,
        // beta angle for left-right rotation
        // Positive to rotate to right.
        beta: 40
      },
      ambient: {
        intensity: 0.4
      }
    },
    viewControl: {
      // Small damping for precise control.
      // damping: 0.1,
      // Alpha angle for top-down rotation
      // Positive to rotate to top.
      alpha: 20,
      // beta angle for left-right rotation
      // Positive to rotate to right.
      beta: 40,
      autoRotate: false,
      // Distance to the surface of grid3D.
      distance: 200,
      // Min distance to the surface of grid3D
      minDistance: 40,
      // Max distance to the surface of grid3D
      maxDistance: 400
    }
  }
});
util_exports.merge(Grid3DModel.prototype, componentViewControlMixin_default);
util_exports.merge(Grid3DModel.prototype, componentPostEffectMixin_default);
util_exports.merge(Grid3DModel.prototype, componentLightMixin_default);
var Grid3DModel_default = Grid3DModel;

// node_modules/echarts-gl/lib/util/geometry/Quads.js
var vec3 = glmatrix_default.vec3;
var QuadsGeometry = Geometry_default.extend(
  function() {
    return {
      segmentScale: 1,
      /**
       * Need to use mesh to expand lines if lineWidth > MAX_LINE_WIDTH
       */
      useNativeLine: true,
      attributes: {
        position: new Geometry_default.Attribute("position", "float", 3, "POSITION"),
        normal: new Geometry_default.Attribute("normal", "float", 3, "NORMAL"),
        color: new Geometry_default.Attribute("color", "float", 4, "COLOR")
      }
    };
  },
  /** @lends module: echarts-gl/util/geometry/QuadsGeometry.prototype */
  {
    /**
     * Reset offset
     */
    resetOffset: function() {
      this._vertexOffset = 0;
      this._faceOffset = 0;
    },
    /**
     * @param {number} nQuad
     */
    setQuadCount: function(nQuad) {
      var attributes = this.attributes;
      var vertexCount = this.getQuadVertexCount() * nQuad;
      var triangleCount = this.getQuadTriangleCount() * nQuad;
      if (this.vertexCount !== vertexCount) {
        attributes.position.init(vertexCount);
        attributes.normal.init(vertexCount);
        attributes.color.init(vertexCount);
      }
      if (this.triangleCount !== triangleCount) {
        this.indices = vertexCount > 65535 ? new Uint32Array(triangleCount * 3) : new Uint16Array(triangleCount * 3);
      }
    },
    getQuadVertexCount: function() {
      return 4;
    },
    getQuadTriangleCount: function() {
      return 2;
    },
    /**
     * Add a quad, which in following order:
     * 0-----1
     * 3-----2
     */
    addQuad: function() {
      var a = vec3.create();
      var b = vec3.create();
      var normal = vec3.create();
      var indices = [0, 3, 1, 3, 2, 1];
      return function(coords, color) {
        var positionAttr = this.attributes.position;
        var normalAttr = this.attributes.normal;
        var colorAttr = this.attributes.color;
        vec3.sub(a, coords[1], coords[0]);
        vec3.sub(b, coords[2], coords[1]);
        vec3.cross(normal, a, b);
        vec3.normalize(normal, normal);
        for (var i = 0; i < 4; i++) {
          positionAttr.set(this._vertexOffset + i, coords[i]);
          colorAttr.set(this._vertexOffset + i, color);
          normalAttr.set(this._vertexOffset + i, normal);
        }
        var idx = this._faceOffset * 3;
        for (var i = 0; i < 6; i++) {
          this.indices[idx + i] = indices[i] + this._vertexOffset;
        }
        this._vertexOffset += 4;
        this._faceOffset += 2;
      };
    }()
  }
);
util_exports.defaults(QuadsGeometry.prototype, dynamicConvertMixin_default);
var Quads_default = QuadsGeometry;

// node_modules/echarts-gl/lib/component/grid3D/Grid3DFace.js
var firstNotNull = retrieve_default.firstNotNull;
var dimIndicesMap = {
  // Left to right
  x: 0,
  // Far to near
  y: 2,
  // Bottom to up
  z: 1
};
function updateFacePlane(node, plane, otherAxis, dir) {
  var coord = [0, 0, 0];
  var distance = dir < 0 ? otherAxis.getExtentMin() : otherAxis.getExtentMax();
  coord[dimIndicesMap[otherAxis.dim]] = distance;
  node.position.setArray(coord);
  node.rotation.identity();
  plane.distance = -Math.abs(distance);
  plane.normal.set(0, 0, 0);
  if (otherAxis.dim === "x") {
    node.rotation.rotateY(dir * Math.PI / 2);
    plane.normal.x = -dir;
  } else if (otherAxis.dim === "z") {
    node.rotation.rotateX(-dir * Math.PI / 2);
    plane.normal.y = -dir;
  } else {
    if (dir > 0) {
      node.rotation.rotateY(Math.PI);
    }
    plane.normal.z = -dir;
  }
}
function Grid3DFace(faceInfo, linesMaterial, quadsMaterial) {
  this.rootNode = new graphicGL_default.Node();
  var linesMesh = new graphicGL_default.Mesh({
    geometry: new Lines3D_default({
      useNativeLine: false
    }),
    material: linesMaterial,
    castShadow: false,
    ignorePicking: true,
    $ignorePicking: true,
    renderOrder: 1
  });
  var quadsMesh = new graphicGL_default.Mesh({
    geometry: new Quads_default(),
    material: quadsMaterial,
    castShadow: false,
    culling: false,
    ignorePicking: true,
    $ignorePicking: true,
    renderOrder: 0
  });
  this.rootNode.add(quadsMesh);
  this.rootNode.add(linesMesh);
  this.faceInfo = faceInfo;
  this.plane = new graphicGL_default.Plane();
  this.linesMesh = linesMesh;
  this.quadsMesh = quadsMesh;
}
Grid3DFace.prototype.update = function(grid3DModel, ecModel, api) {
  var cartesian = grid3DModel.coordinateSystem;
  var axes = [cartesian.getAxis(this.faceInfo[0]), cartesian.getAxis(this.faceInfo[1])];
  var lineGeometry = this.linesMesh.geometry;
  var quadsGeometry = this.quadsMesh.geometry;
  lineGeometry.convertToDynamicArray(true);
  quadsGeometry.convertToDynamicArray(true);
  this._updateSplitLines(lineGeometry, axes, grid3DModel, api);
  this._udpateSplitAreas(quadsGeometry, axes, grid3DModel, api);
  lineGeometry.convertToTypedArray();
  quadsGeometry.convertToTypedArray();
  var otherAxis = cartesian.getAxis(this.faceInfo[2]);
  updateFacePlane(this.rootNode, this.plane, otherAxis, this.faceInfo[3]);
};
Grid3DFace.prototype._updateSplitLines = function(geometry, axes, grid3DModel, api) {
  var dpr = api.getDevicePixelRatio();
  axes.forEach(function(axis, idx) {
    var axisModel = axis.model;
    var otherExtent = axes[1 - idx].getExtent();
    if (axis.scale.isBlank()) {
      return;
    }
    var splitLineModel = axisModel.getModel("splitLine", grid3DModel.getModel("splitLine"));
    if (splitLineModel.get("show")) {
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineColors = lineStyleModel.get("color");
      var opacity = firstNotNull(lineStyleModel.get("opacity"), 1);
      var lineWidth = firstNotNull(lineStyleModel.get("width"), 1);
      lineColors = util_exports.isArray(lineColors) ? lineColors : [lineColors];
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitLineModel
      });
      var count = 0;
      for (var i = 0; i < ticksCoords.length; i++) {
        var tickCoord = ticksCoords[i].coord;
        var lineColor = graphicGL_default.parseColor(lineColors[count % lineColors.length]);
        lineColor[3] *= opacity;
        var p0 = [0, 0, 0];
        var p1 = [0, 0, 0];
        p0[idx] = p1[idx] = tickCoord;
        p0[1 - idx] = otherExtent[0];
        p1[1 - idx] = otherExtent[1];
        geometry.addLine(p0, p1, lineColor, lineWidth * dpr);
        count++;
      }
    }
  });
};
Grid3DFace.prototype._udpateSplitAreas = function(geometry, axes, grid3DModel, api) {
  axes.forEach(function(axis, idx) {
    var axisModel = axis.model;
    var otherExtent = axes[1 - idx].getExtent();
    if (axis.scale.isBlank()) {
      return;
    }
    var splitAreaModel = axisModel.getModel("splitArea", grid3DModel.getModel("splitArea"));
    if (splitAreaModel.get("show")) {
      var areaStyleModel = splitAreaModel.getModel("areaStyle");
      var colors = areaStyleModel.get("color");
      var opacity = firstNotNull(areaStyleModel.get("opacity"), 1);
      colors = util_exports.isArray(colors) ? colors : [colors];
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitAreaModel,
        clamp: true
      });
      var count = 0;
      var prevP0 = [0, 0, 0];
      var prevP1 = [0, 0, 0];
      for (var i = 0; i < ticksCoords.length; i++) {
        var tickCoord = ticksCoords[i].coord;
        var p0 = [0, 0, 0];
        var p1 = [0, 0, 0];
        p0[idx] = p1[idx] = tickCoord;
        p0[1 - idx] = otherExtent[0];
        p1[1 - idx] = otherExtent[1];
        if (i === 0) {
          prevP0 = p0;
          prevP1 = p1;
          continue;
        }
        var color = graphicGL_default.parseColor(colors[count % colors.length]);
        color[3] *= opacity;
        geometry.addQuad([prevP0, p0, p1, prevP1], color);
        prevP0 = p0;
        prevP1 = p1;
        count++;
      }
    }
  });
};
var Grid3DFace_default = Grid3DFace;

// node_modules/echarts-gl/lib/component/grid3D/Grid3DAxis.js
var firstNotNull2 = retrieve_default.firstNotNull;
var dimIndicesMap2 = {
  // Left to right
  x: 0,
  // Far to near
  y: 2,
  // Bottom to up
  z: 1
};
function Grid3DAxis(dim, linesMaterial) {
  var linesMesh = new graphicGL_default.Mesh({
    geometry: new Lines3D_default({
      useNativeLine: false
    }),
    material: linesMaterial,
    castShadow: false,
    ignorePicking: true,
    renderOrder: 2
  });
  var axisLabelsMesh = new LabelsMesh_default();
  axisLabelsMesh.material.depthMask = false;
  var rootNode = new graphicGL_default.Node();
  rootNode.add(linesMesh);
  rootNode.add(axisLabelsMesh);
  this.rootNode = rootNode;
  this.dim = dim;
  this.linesMesh = linesMesh;
  this.labelsMesh = axisLabelsMesh;
  this.axisLineCoords = null;
  this.labelElements = [];
}
var otherDim = {
  x: "y",
  y: "x",
  z: "y"
};
Grid3DAxis.prototype.update = function(grid3DModel, axisLabelSurface, api) {
  var cartesian = grid3DModel.coordinateSystem;
  var axis = cartesian.getAxis(this.dim);
  var linesGeo = this.linesMesh.geometry;
  var labelsGeo = this.labelsMesh.geometry;
  linesGeo.convertToDynamicArray(true);
  labelsGeo.convertToDynamicArray(true);
  var axisModel = axis.model;
  var extent = axis.getExtent();
  var dpr = api.getDevicePixelRatio();
  var axisLineModel = axisModel.getModel("axisLine", grid3DModel.getModel("axisLine"));
  var axisTickModel = axisModel.getModel("axisTick", grid3DModel.getModel("axisTick"));
  var axisLabelModel = axisModel.getModel("axisLabel", grid3DModel.getModel("axisLabel"));
  var axisLineColor = axisLineModel.get("lineStyle.color");
  if (axisLineModel.get("show")) {
    var axisLineStyleModel = axisLineModel.getModel("lineStyle");
    var p0 = [0, 0, 0];
    var p1 = [0, 0, 0];
    var idx = dimIndicesMap2[axis.dim];
    p0[idx] = extent[0];
    p1[idx] = extent[1];
    this.axisLineCoords = [p0, p1];
    var color = graphicGL_default.parseColor(axisLineColor);
    var lineWidth = firstNotNull2(axisLineStyleModel.get("width"), 1);
    var opacity = firstNotNull2(axisLineStyleModel.get("opacity"), 1);
    color[3] *= opacity;
    linesGeo.addLine(p0, p1, color, lineWidth * dpr);
  }
  if (axisTickModel.get("show")) {
    var lineStyleModel = axisTickModel.getModel("lineStyle");
    var lineColor = graphicGL_default.parseColor(firstNotNull2(lineStyleModel.get("color"), axisLineColor));
    var lineWidth = firstNotNull2(lineStyleModel.get("width"), 1);
    lineColor[3] *= firstNotNull2(lineStyleModel.get("opacity"), 1);
    var ticksCoords = axis.getTicksCoords();
    var tickLength = axisTickModel.get("length");
    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = ticksCoords[i].coord;
      var p0 = [0, 0, 0];
      var p1 = [0, 0, 0];
      var idx = dimIndicesMap2[axis.dim];
      var otherIdx = dimIndicesMap2[otherDim[axis.dim]];
      p0[idx] = p1[idx] = tickCoord;
      p1[otherIdx] = tickLength;
      linesGeo.addLine(p0, p1, lineColor, lineWidth * dpr);
    }
  }
  this.labelElements = [];
  var dpr = api.getDevicePixelRatio();
  if (axisLabelModel.get("show")) {
    var ticksCoords = axis.getTicksCoords();
    var categoryData = axisModel.get("data");
    var labelMargin = axisLabelModel.get("margin");
    var labels = axis.getViewLabels();
    for (var i = 0; i < labels.length; i++) {
      var tickValue = labels[i].tickValue;
      var formattedLabel = labels[i].formattedLabel;
      var rawLabel = labels[i].rawLabel;
      var tickCoord = axis.dataToCoord(tickValue);
      var p = [0, 0, 0];
      var idx = dimIndicesMap2[axis.dim];
      var otherIdx = dimIndicesMap2[otherDim[axis.dim]];
      p[idx] = p[idx] = tickCoord;
      p[otherIdx] = labelMargin;
      var itemTextStyleModel = axisLabelModel;
      if (categoryData && categoryData[tickValue] && categoryData[tickValue].textStyle) {
        itemTextStyleModel = new Model_default(categoryData[tickValue].textStyle, axisLabelModel, axisModel.ecModel);
      }
      var textColor = firstNotNull2(itemTextStyleModel.get("color"), axisLineColor);
      var textEl = new graphic_exports.Text({
        style: createTextStyle(itemTextStyleModel, {
          text: formattedLabel,
          fill: typeof textColor === "function" ? textColor(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always returns labelStr.
            // But in interval scale labelStr is like '223,445', which maked
            // user repalce ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue,
            i
          ) : textColor,
          verticalAlign: "top",
          align: "left"
        })
      });
      var coords = axisLabelSurface.add(textEl);
      var rect = textEl.getBoundingRect();
      labelsGeo.addSprite(p, [rect.width * dpr, rect.height * dpr], coords);
      this.labelElements.push(textEl);
    }
  }
  if (axisModel.get("name")) {
    var nameTextStyleModel = axisModel.getModel("nameTextStyle");
    var p = [0, 0, 0];
    var idx = dimIndicesMap2[axis.dim];
    var otherIdx = dimIndicesMap2[otherDim[axis.dim]];
    var labelColor = firstNotNull2(nameTextStyleModel.get("color"), axisLineColor);
    var strokeColor = nameTextStyleModel.get("borderColor");
    var lineWidth = nameTextStyleModel.get("borderWidth");
    p[idx] = p[idx] = (extent[0] + extent[1]) / 2;
    p[otherIdx] = axisModel.get("nameGap");
    var textEl = new graphic_exports.Text({
      style: createTextStyle(nameTextStyleModel, {
        text: axisModel.get("name"),
        fill: labelColor,
        stroke: strokeColor,
        lineWidth
      })
    });
    var coords = axisLabelSurface.add(textEl);
    var rect = textEl.getBoundingRect();
    labelsGeo.addSprite(p, [rect.width * dpr, rect.height * dpr], coords);
    textEl.__idx = this.labelElements.length;
    this.nameLabelElement = textEl;
  }
  this.labelsMesh.material.set("textureAtlas", axisLabelSurface.getTexture());
  this.labelsMesh.material.set("uvScale", axisLabelSurface.getCoordsScale());
  linesGeo.convertToTypedArray();
  labelsGeo.convertToTypedArray();
};
Grid3DAxis.prototype.setSpriteAlign = function(textAlign, textVerticalAlign, api) {
  var dpr = api.getDevicePixelRatio();
  var labelGeo = this.labelsMesh.geometry;
  for (var i = 0; i < this.labelElements.length; i++) {
    var labelEl = this.labelElements[i];
    var rect = labelEl.getBoundingRect();
    labelGeo.setSpriteAlign(i, [rect.width * dpr, rect.height * dpr], textAlign, textVerticalAlign);
  }
  var nameLabelEl = this.nameLabelElement;
  if (nameLabelEl) {
    var rect = nameLabelEl.getBoundingRect();
    labelGeo.setSpriteAlign(nameLabelEl.__idx, [rect.width * dpr, rect.height * dpr], textAlign, textVerticalAlign);
    labelGeo.dirty();
  }
  this.textAlign = textAlign;
  this.textVerticalAlign = textVerticalAlign;
};
var Grid3DAxis_default = Grid3DAxis;

// node_modules/echarts-gl/lib/component/grid3D/Grid3DView.js
var firstNotNull3 = retrieve_default.firstNotNull;
graphicGL_default.Shader.import(lines3D_glsl_default);
var dimIndicesMap3 = {
  // Left to right
  x: 0,
  // Far to near
  y: 2,
  // Bottom to up
  z: 1
};
var Grid3DView_default = Component_default2.extend({
  type: "grid3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    var FACES = [
      // planeDim0, planeDim1, offsetDim, dir on dim3 axis(gl), plane.
      ["y", "z", "x", -1, "left"],
      ["y", "z", "x", 1, "right"],
      ["x", "y", "z", -1, "bottom"],
      ["x", "y", "z", 1, "top"],
      ["x", "z", "y", -1, "far"],
      ["x", "z", "y", 1, "near"]
    ];
    var DIMS = ["x", "y", "z"];
    var quadsMaterial = new graphicGL_default.Material({
      // transparent: true,
      shader: graphicGL_default.createShader("ecgl.color"),
      depthMask: false,
      transparent: true
    });
    var linesMaterial = new graphicGL_default.Material({
      // transparent: true,
      shader: graphicGL_default.createShader("ecgl.meshLines3D"),
      depthMask: false,
      transparent: true
    });
    quadsMaterial.define("fragment", "DOUBLE_SIDED");
    quadsMaterial.define("both", "VERTEX_COLOR");
    this.groupGL = new graphicGL_default.Node();
    this._control = new OrbitControl_default({
      zr: api.getZr()
    });
    this._control.init();
    this._faces = FACES.map(function(faceInfo) {
      var face = new Grid3DFace_default(faceInfo, linesMaterial, quadsMaterial);
      this.groupGL.add(face.rootNode);
      return face;
    }, this);
    this._axes = DIMS.map(function(dim) {
      var axis = new Grid3DAxis_default(dim, linesMaterial);
      this.groupGL.add(axis.rootNode);
      return axis;
    }, this);
    var dpr = api.getDevicePixelRatio();
    this._axisLabelSurface = new ZRTextureAtlasSurface_default({
      width: 256,
      height: 256,
      devicePixelRatio: dpr
    });
    this._axisLabelSurface.onupdate = function() {
      api.getZr().refresh();
    };
    this._axisPointerLineMesh = new graphicGL_default.Mesh({
      geometry: new Lines3D_default({
        useNativeLine: false
      }),
      material: linesMaterial,
      castShadow: false,
      // PENDING
      ignorePicking: true,
      renderOrder: 3
    });
    this.groupGL.add(this._axisPointerLineMesh);
    this._axisPointerLabelsSurface = new ZRTextureAtlasSurface_default({
      width: 128,
      height: 128,
      devicePixelRatio: dpr
    });
    this._axisPointerLabelsMesh = new LabelsMesh_default({
      ignorePicking: true,
      renderOrder: 4,
      castShadow: false
    });
    this._axisPointerLabelsMesh.material.set("textureAtlas", this._axisPointerLabelsSurface.getTexture());
    this.groupGL.add(this._axisPointerLabelsMesh);
    this._lightRoot = new graphicGL_default.Node();
    this._sceneHelper = new SceneHelper_default();
    this._sceneHelper.initLight(this._lightRoot);
  },
  render: function(grid3DModel, ecModel, api) {
    this._model = grid3DModel;
    this._api = api;
    var cartesian = grid3DModel.coordinateSystem;
    cartesian.viewGL.add(this._lightRoot);
    if (grid3DModel.get("show")) {
      cartesian.viewGL.add(this.groupGL);
    } else {
      cartesian.viewGL.remove(this.groupGL);
    }
    var control = this._control;
    control.setViewGL(cartesian.viewGL);
    var viewControlModel = grid3DModel.getModel("viewControl");
    control.setFromViewControlModel(viewControlModel, 0);
    this._axisLabelSurface.clear();
    control.off("update");
    if (grid3DModel.get("show")) {
      this._faces.forEach(function(face) {
        face.update(grid3DModel, ecModel, api);
      }, this);
      this._axes.forEach(function(axis) {
        axis.update(grid3DModel, this._axisLabelSurface, api);
      }, this);
    }
    control.on("update", this._onCameraChange.bind(this, grid3DModel, api), this);
    this._sceneHelper.setScene(cartesian.viewGL.scene);
    this._sceneHelper.updateLight(grid3DModel);
    cartesian.viewGL.setPostEffect(grid3DModel.getModel("postEffect"), api);
    cartesian.viewGL.setTemporalSuperSampling(grid3DModel.getModel("temporalSuperSampling"));
    this._initMouseHandler(grid3DModel);
  },
  afterRender: function(grid3DModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    this._sceneHelper.updateAmbientCubemap(renderer, grid3DModel, api);
    this._sceneHelper.updateSkybox(renderer, grid3DModel, api);
  },
  /**
   * showAxisPointer will be triggered by action.
   */
  showAxisPointer: function(grid3dModel, ecModel, api, payload) {
    this._doShowAxisPointer();
    this._updateAxisPointer(payload.value);
  },
  /**
   * hideAxisPointer will be triggered by action.
   */
  hideAxisPointer: function(grid3dModel, ecModel, api, payload) {
    this._doHideAxisPointer();
  },
  _initMouseHandler: function(grid3DModel) {
    var cartesian = grid3DModel.coordinateSystem;
    var viewGL = cartesian.viewGL;
    if (grid3DModel.get("show") && grid3DModel.get("axisPointer.show")) {
      viewGL.on("mousemove", this._updateAxisPointerOnMousePosition, this);
    } else {
      viewGL.off("mousemove", this._updateAxisPointerOnMousePosition);
    }
  },
  /**
   * Try find and show axisPointer on the intersect point
   * of mouse ray with grid plane.
   */
  _updateAxisPointerOnMousePosition: function(e2) {
    if (e2.target) {
      return;
    }
    var grid3DModel = this._model;
    var cartesian = grid3DModel.coordinateSystem;
    var viewGL = cartesian.viewGL;
    var ray = viewGL.castRay(e2.offsetX, e2.offsetY, new graphicGL_default.Ray());
    var nearestIntersectPoint;
    for (var i = 0; i < this._faces.length; i++) {
      var face = this._faces[i];
      if (face.rootNode.invisible) {
        continue;
      }
      if (face.plane.normal.dot(viewGL.camera.worldTransform.z) < 0) {
        face.plane.normal.negate();
      }
      var point = ray.intersectPlane(face.plane);
      if (!point) {
        continue;
      }
      var axis0 = cartesian.getAxis(face.faceInfo[0]);
      var axis1 = cartesian.getAxis(face.faceInfo[1]);
      var idx0 = dimIndicesMap3[face.faceInfo[0]];
      var idx1 = dimIndicesMap3[face.faceInfo[1]];
      if (axis0.contain(point.array[idx0]) && axis1.contain(point.array[idx1])) {
        nearestIntersectPoint = point;
      }
    }
    if (nearestIntersectPoint) {
      var data = cartesian.pointToData(nearestIntersectPoint.array, [], true);
      this._updateAxisPointer(data);
      this._doShowAxisPointer();
    } else {
      this._doHideAxisPointer();
    }
  },
  _onCameraChange: function(grid3DModel, api) {
    if (grid3DModel.get("show")) {
      this._updateFaceVisibility();
      this._updateAxisLinePosition();
    }
    var control = this._control;
    api.dispatchAction({
      type: "grid3DChangeCamera",
      alpha: control.getAlpha(),
      beta: control.getBeta(),
      distance: control.getDistance(),
      center: control.getCenter(),
      from: this.uid,
      grid3DId: grid3DModel.id
    });
  },
  /**
   * Update visibility of each face when camera view changed, front face will be invisible.
   * @private
   */
  _updateFaceVisibility: function() {
    var camera = this._control.getCamera();
    var viewSpacePos = new graphicGL_default.Vector3();
    camera.update();
    for (var idx = 0; idx < this._faces.length / 2; idx++) {
      var depths = [];
      for (var k = 0; k < 2; k++) {
        var face = this._faces[idx * 2 + k];
        face.rootNode.getWorldPosition(viewSpacePos);
        viewSpacePos.transformMat4(camera.viewMatrix);
        depths[k] = viewSpacePos.z;
      }
      var frontIndex = depths[0] > depths[1] ? 0 : 1;
      var frontFace = this._faces[idx * 2 + frontIndex];
      var backFace = this._faces[idx * 2 + 1 - frontIndex];
      frontFace.rootNode.invisible = true;
      backFace.rootNode.invisible = false;
    }
  },
  /**
   * Update axis line position when camera view changed.
   * @private
   */
  _updateAxisLinePosition: function() {
    var cartesian = this._model.coordinateSystem;
    var xAxis = cartesian.getAxis("x");
    var yAxis = cartesian.getAxis("y");
    var zAxis = cartesian.getAxis("z");
    var top = zAxis.getExtentMax();
    var bottom = zAxis.getExtentMin();
    var left = xAxis.getExtentMin();
    var right = xAxis.getExtentMax();
    var near = yAxis.getExtentMax();
    var far = yAxis.getExtentMin();
    var xAxisNode = this._axes[0].rootNode;
    var yAxisNode = this._axes[1].rootNode;
    var zAxisNode = this._axes[2].rootNode;
    var faces = this._faces;
    var xAxisZOffset = faces[4].rootNode.invisible ? far : near;
    var xAxisYOffset = faces[2].rootNode.invisible ? top : bottom;
    var yAxisXOffset = faces[0].rootNode.invisible ? left : right;
    var yAxisYOffset = faces[2].rootNode.invisible ? top : bottom;
    var zAxisXOffset = faces[0].rootNode.invisible ? right : left;
    var zAxisZOffset = faces[4].rootNode.invisible ? far : near;
    xAxisNode.rotation.identity();
    yAxisNode.rotation.identity();
    zAxisNode.rotation.identity();
    if (faces[4].rootNode.invisible) {
      this._axes[0].flipped = true;
      xAxisNode.rotation.rotateX(Math.PI);
    }
    if (faces[0].rootNode.invisible) {
      this._axes[1].flipped = true;
      yAxisNode.rotation.rotateZ(Math.PI);
    }
    if (faces[4].rootNode.invisible) {
      this._axes[2].flipped = true;
      zAxisNode.rotation.rotateY(Math.PI);
    }
    xAxisNode.position.set(0, xAxisYOffset, xAxisZOffset);
    yAxisNode.position.set(yAxisXOffset, yAxisYOffset, 0);
    zAxisNode.position.set(zAxisXOffset, 0, zAxisZOffset);
    xAxisNode.update();
    yAxisNode.update();
    zAxisNode.update();
    this._updateAxisLabelAlign();
  },
  /**
   * Update label align on axis when axisLine position changed.
   * @private
   */
  _updateAxisLabelAlign: function() {
    var camera = this._control.getCamera();
    var coords = [new graphicGL_default.Vector4(), new graphicGL_default.Vector4()];
    var center = new graphicGL_default.Vector4();
    this.groupGL.getWorldPosition(center);
    center.w = 1;
    center.transformMat4(camera.viewMatrix).transformMat4(camera.projectionMatrix);
    center.x /= center.w;
    center.y /= center.w;
    this._axes.forEach(function(axisInfo) {
      var lineCoords = axisInfo.axisLineCoords;
      var labelGeo = axisInfo.labelsMesh.geometry;
      for (var i = 0; i < coords.length; i++) {
        coords[i].setArray(lineCoords[i]);
        coords[i].w = 1;
        coords[i].transformMat4(axisInfo.rootNode.worldTransform).transformMat4(camera.viewMatrix).transformMat4(camera.projectionMatrix);
        coords[i].x /= coords[i].w;
        coords[i].y /= coords[i].w;
      }
      var dx = coords[1].x - coords[0].x;
      var dy = coords[1].y - coords[0].y;
      var cx = (coords[1].x + coords[0].x) / 2;
      var cy = (coords[1].y + coords[0].y) / 2;
      var textAlign;
      var verticalAlign;
      if (Math.abs(dy / dx) < 0.5) {
        textAlign = "center";
        verticalAlign = cy > center.y ? "bottom" : "top";
      } else {
        verticalAlign = "middle";
        textAlign = cx > center.x ? "left" : "right";
      }
      axisInfo.setSpriteAlign(textAlign, verticalAlign, this._api);
    }, this);
  },
  _doShowAxisPointer: function() {
    if (!this._axisPointerLineMesh.invisible) {
      return;
    }
    this._axisPointerLineMesh.invisible = false;
    this._axisPointerLabelsMesh.invisible = false;
    this._api.getZr().refresh();
  },
  _doHideAxisPointer: function() {
    if (this._axisPointerLineMesh.invisible) {
      return;
    }
    this._axisPointerLineMesh.invisible = true;
    this._axisPointerLabelsMesh.invisible = true;
    this._api.getZr().refresh();
  },
  /**
   * @private updateAxisPointer.
   */
  _updateAxisPointer: function(data) {
    var cartesian = this._model.coordinateSystem;
    var point = cartesian.dataToPoint(data);
    var axisPointerLineMesh = this._axisPointerLineMesh;
    var linesGeo = axisPointerLineMesh.geometry;
    var axisPointerParentModel = this._model.getModel("axisPointer");
    var dpr = this._api.getDevicePixelRatio();
    linesGeo.convertToDynamicArray(true);
    function ifShowAxisPointer(axis2) {
      return retrieve_default.firstNotNull(axis2.model.get("axisPointer.show"), axisPointerParentModel.get("show"));
    }
    function getAxisColorAndLineWidth(axis2) {
      var axisPointerModel = axis2.model.getModel("axisPointer", axisPointerParentModel);
      var lineStyleModel = axisPointerModel.getModel("lineStyle");
      var color = graphicGL_default.parseColor(lineStyleModel.get("color"));
      var lineWidth = firstNotNull3(lineStyleModel.get("width"), 1);
      var opacity = firstNotNull3(lineStyleModel.get("opacity"), 1);
      color[3] *= opacity;
      return {
        color,
        lineWidth
      };
    }
    for (var k = 0; k < this._faces.length; k++) {
      var face = this._faces[k];
      if (face.rootNode.invisible) {
        continue;
      }
      var faceInfo = face.faceInfo;
      var otherCoord = faceInfo[3] < 0 ? cartesian.getAxis(faceInfo[2]).getExtentMin() : cartesian.getAxis(faceInfo[2]).getExtentMax();
      var otherDimIdx = dimIndicesMap3[faceInfo[2]];
      for (var i = 0; i < 2; i++) {
        var dim = faceInfo[i];
        var faceOtherDim = faceInfo[1 - i];
        var axis = cartesian.getAxis(dim);
        var faceOtherAxis = cartesian.getAxis(faceOtherDim);
        if (!ifShowAxisPointer(axis)) {
          continue;
        }
        var p0 = [0, 0, 0];
        var p1 = [0, 0, 0];
        var dimIdx = dimIndicesMap3[dim];
        var faceOtherDimIdx = dimIndicesMap3[faceOtherDim];
        p0[dimIdx] = p1[dimIdx] = point[dimIdx];
        p0[otherDimIdx] = p1[otherDimIdx] = otherCoord;
        p0[faceOtherDimIdx] = faceOtherAxis.getExtentMin();
        p1[faceOtherDimIdx] = faceOtherAxis.getExtentMax();
        var colorAndLineWidth = getAxisColorAndLineWidth(axis);
        linesGeo.addLine(p0, p1, colorAndLineWidth.color, colorAndLineWidth.lineWidth * dpr);
      }
      if (ifShowAxisPointer(cartesian.getAxis(faceInfo[2]))) {
        var p0 = point.slice();
        var p1 = point.slice();
        p1[otherDimIdx] = otherCoord;
        var colorAndLineWidth = getAxisColorAndLineWidth(cartesian.getAxis(faceInfo[2]));
        linesGeo.addLine(p0, p1, colorAndLineWidth.color, colorAndLineWidth.lineWidth * dpr);
      }
    }
    linesGeo.convertToTypedArray();
    this._updateAxisPointerLabelsMesh(data);
    this._api.getZr().refresh();
  },
  _updateAxisPointerLabelsMesh: function(data) {
    var grid3dModel = this._model;
    var axisPointerLabelsMesh = this._axisPointerLabelsMesh;
    var axisPointerLabelsSurface = this._axisPointerLabelsSurface;
    var cartesian = grid3dModel.coordinateSystem;
    var axisPointerParentModel = grid3dModel.getModel("axisPointer");
    axisPointerLabelsMesh.geometry.convertToDynamicArray(true);
    axisPointerLabelsSurface.clear();
    var otherDim2 = {
      x: "y",
      y: "x",
      z: "y"
    };
    this._axes.forEach(function(axisInfo, idx) {
      var axis = cartesian.getAxis(axisInfo.dim);
      var axisModel = axis.model;
      var axisPointerModel = axisModel.getModel("axisPointer", axisPointerParentModel);
      var labelModel = axisPointerModel.getModel("label");
      var lineColor = axisPointerModel.get("lineStyle.color");
      if (!labelModel.get("show") || !axisPointerModel.get("show")) {
        return;
      }
      var val = data[idx];
      var formatter = labelModel.get("formatter");
      var text = axis.scale.getLabel({
        value: val
      });
      if (formatter != null) {
        text = formatter(text, data);
      } else {
        if (axis.scale.type === "interval" || axis.scale.type === "log") {
          var precision = number_exports.getPrecisionSafe(axis.scale.getTicks()[0]);
          text = val.toFixed(precision + 2);
        }
      }
      var labelColor = labelModel.get("color");
      var textEl = new graphic_exports.Text({
        style: createTextStyle(labelModel, {
          text,
          fill: labelColor || lineColor,
          align: "left",
          verticalAlign: "top"
        })
      });
      var coords = axisPointerLabelsSurface.add(textEl);
      var rect = textEl.getBoundingRect();
      var dpr = this._api.getDevicePixelRatio();
      var pos = axisInfo.rootNode.position.toArray();
      var otherIdx = dimIndicesMap3[otherDim2[axisInfo.dim]];
      pos[otherIdx] += (axisInfo.flipped ? -1 : 1) * labelModel.get("margin");
      pos[dimIndicesMap3[axisInfo.dim]] = axis.dataToCoord(data[idx]);
      axisPointerLabelsMesh.geometry.addSprite(pos, [rect.width * dpr, rect.height * dpr], coords, axisInfo.textAlign, axisInfo.textVerticalAlign);
    }, this);
    axisPointerLabelsSurface.getZr().refreshImmediately();
    axisPointerLabelsMesh.material.set("uvScale", axisPointerLabelsSurface.getCoordsScale());
    axisPointerLabelsMesh.geometry.convertToTypedArray();
  },
  dispose: function() {
    this.groupGL.removeAll();
    this._control.dispose();
    this._axisLabelSurface.dispose();
    this._axisPointerLabelsSurface.dispose();
  }
});

// node_modules/echarts-gl/lib/coord/grid3D/Cartesian3D.js
function Cartesian3D(name) {
  Cartesian_default.call(this, name);
  this.type = "cartesian3D";
  this.dimensions = ["x", "y", "z"];
  this.size = [0, 0, 0];
}
Cartesian3D.prototype = {
  constructor: Cartesian3D,
  model: null,
  containPoint: function(point) {
    return this.getAxis("x").contain(point[0]) && this.getAxis("y").contain(point[2]) && this.getAxis("z").contain(point[1]);
  },
  containData: function(data) {
    return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]) && this.getAxis("z").containData(data[2]);
  },
  dataToPoint: function(data, out, clamp) {
    out = out || [];
    out[0] = this.getAxis("x").dataToCoord(data[0], clamp);
    out[2] = this.getAxis("y").dataToCoord(data[1], clamp);
    out[1] = this.getAxis("z").dataToCoord(data[2], clamp);
    return out;
  },
  pointToData: function(point, out, clamp) {
    out = out || [];
    out[0] = this.getAxis("x").coordToData(point[0], clamp);
    out[1] = this.getAxis("y").coordToData(point[2], clamp);
    out[2] = this.getAxis("z").coordToData(point[1], clamp);
    return out;
  }
};
util_exports.inherits(Cartesian3D, Cartesian_default);
var Cartesian3D_default = Cartesian3D;

// node_modules/echarts-gl/lib/coord/grid3D/Axis3D.js
function Axis3D(dim, scale, extent) {
  Axis_default.call(this, dim, scale, extent);
}
Axis3D.prototype = {
  constructor: Axis3D,
  getExtentMin: function() {
    var extent = this._extent;
    return Math.min(extent[0], extent[1]);
  },
  getExtentMax: function() {
    var extent = this._extent;
    return Math.max(extent[0], extent[1]);
  },
  calculateCategoryInterval: function() {
    return Math.floor(this.scale.count() / 8);
  }
};
util_exports.inherits(Axis3D, Axis_default);
var Axis3D_default = Axis3D;

// node_modules/echarts-gl/lib/coord/grid3DCreator.js
function resizeCartesian3D(grid3DModel, api) {
  var boxLayoutOption = grid3DModel.getBoxLayoutParams();
  var viewport = getLayoutRect(boxLayoutOption, {
    width: api.getWidth(),
    height: api.getHeight()
  });
  viewport.y = api.getHeight() - viewport.y - viewport.height;
  this.viewGL.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, api.getDevicePixelRatio());
  var boxWidth = grid3DModel.get("boxWidth");
  var boxHeight = grid3DModel.get("boxHeight");
  var boxDepth = grid3DModel.get("boxDepth");
  if (true) {
    ["x", "y", "z"].forEach(function(dim) {
      if (!this.getAxis(dim)) {
        throw new Error("Grid" + grid3DModel.id + " don't have " + dim + "Axis");
      }
    }, this);
  }
  this.getAxis("x").setExtent(-boxWidth / 2, boxWidth / 2);
  this.getAxis("y").setExtent(boxDepth / 2, -boxDepth / 2);
  this.getAxis("z").setExtent(-boxHeight / 2, boxHeight / 2);
  this.size = [boxWidth, boxHeight, boxDepth];
}
function updateCartesian3D(ecModel, api) {
  var dataExtents = {};
  function unionDataExtents(dim, extent) {
    dataExtents[dim] = dataExtents[dim] || [Infinity, -Infinity];
    dataExtents[dim][0] = Math.min(extent[0], dataExtents[dim][0]);
    dataExtents[dim][1] = Math.max(extent[1], dataExtents[dim][1]);
  }
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.coordinateSystem !== this) {
      return;
    }
    var data = seriesModel.getData();
    ["x", "y", "z"].forEach(function(coordDim) {
      data.mapDimensionsAll(coordDim, true).forEach(function(dataDim) {
        unionDataExtents(coordDim, data.getDataExtent(dataDim, true));
      });
    });
  }, this);
  ["xAxis3D", "yAxis3D", "zAxis3D"].forEach(function(axisType) {
    ecModel.eachComponent(axisType, function(axisModel) {
      var dim = axisType.charAt(0);
      var grid3DModel = axisModel.getReferringComponents("grid3D").models[0];
      var cartesian3D = grid3DModel.coordinateSystem;
      if (cartesian3D !== this) {
        return;
      }
      var axis = cartesian3D.getAxis(dim);
      if (axis) {
        if (true) {
          console.warn("Can't have two %s in one grid3D", axisType);
        }
        return;
      }
      var scale = helper_exports.createScale(dataExtents[dim] || [Infinity, -Infinity], axisModel);
      axis = new Axis3D_default(dim, scale);
      axis.type = axisModel.get("type");
      var isCategory = axis.type === "category";
      axis.onBand = isCategory && axisModel.get("boundaryGap");
      axis.inverse = axisModel.get("inverse");
      axisModel.axis = axis;
      axis.model = axisModel;
      axis.getLabelModel = function() {
        return axisModel.getModel("axisLabel", grid3DModel.getModel("axisLabel"));
      };
      axis.getTickModel = function() {
        return axisModel.getModel("axisTick", grid3DModel.getModel("axisTick"));
      };
      cartesian3D.addAxis(axis);
    }, this);
  }, this);
  this.resize(this.model, api);
}
var grid3DCreator = {
  dimensions: Cartesian3D_default.prototype.dimensions,
  create: function(ecModel, api) {
    var cartesian3DList = [];
    ecModel.eachComponent("grid3D", function(grid3DModel) {
      grid3DModel.__viewGL = grid3DModel.__viewGL || new ViewGL_default();
      var cartesian3D = new Cartesian3D_default();
      cartesian3D.model = grid3DModel;
      cartesian3D.viewGL = grid3DModel.__viewGL;
      grid3DModel.coordinateSystem = cartesian3D;
      cartesian3DList.push(cartesian3D);
      cartesian3D.resize = resizeCartesian3D;
      cartesian3D.update = updateCartesian3D;
    });
    var axesTypes = ["xAxis3D", "yAxis3D", "zAxis3D"];
    function findAxesModels(seriesModel, ecModel2) {
      return axesTypes.map(function(axisType) {
        var axisModel = seriesModel.getReferringComponents(axisType).models[0];
        if (axisModel == null) {
          axisModel = ecModel2.getComponent(axisType);
        }
        if (true) {
          if (!axisModel) {
            throw new Error(axisType + ' "' + retrieve_default.firstNotNull(seriesModel.get(axisType + "Index"), seriesModel.get(axisType + "Id"), 0) + '" not found');
          }
        }
        return axisModel;
      });
    }
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") !== "cartesian3D") {
        return;
      }
      var firstGridModel = seriesModel.getReferringComponents("grid3D").models[0];
      if (firstGridModel == null) {
        var axesModels = findAxesModels(seriesModel, ecModel);
        var firstGridModel = axesModels[0].getCoordSysModel();
        axesModels.forEach(function(axisModel) {
          var grid3DModel = axisModel.getCoordSysModel();
          if (true) {
            if (!grid3DModel) {
              throw new Error('grid3D "' + retrieve_default.firstNotNull(axisModel.get("gridIndex"), axisModel.get("gridId"), 0) + '" not found');
            }
            if (grid3DModel !== firstGridModel) {
              throw new Error("xAxis3D, yAxis3D, zAxis3D must use the same grid");
            }
          }
        });
      }
      var coordSys = firstGridModel.coordinateSystem;
      seriesModel.coordinateSystem = coordSys;
    });
    return cartesian3DList;
  }
};
var grid3DCreator_default = grid3DCreator;

// node_modules/echarts-gl/lib/component/grid3D/Axis3DModel.js
var Axis3DModel = Component_default.extend({
  type: "cartesian3DAxis",
  axis: null,
  /**
   * @override
   */
  getCoordSysModel: function() {
    return this.ecModel.queryComponents({
      mainType: "grid3D",
      index: this.option.gridIndex,
      id: this.option.gridId
    })[0];
  }
});
helper_exports.mixinAxisModelCommonMethods(Axis3DModel);
var Axis3DModel_default = Axis3DModel;

// node_modules/echarts-gl/lib/component/grid3D/axis3DDefault.js
var defaultOption = {
  show: true,
  grid3DIndex: 0,
  // 反向坐标轴
  inverse: false,
  // 坐标轴名字
  name: "",
  // 坐标轴名字位置
  nameLocation: "middle",
  nameTextStyle: {
    fontSize: 16
  },
  // 文字与轴线距离
  nameGap: 20,
  axisPointer: {},
  axisLine: {},
  // 坐标轴小标记
  axisTick: {},
  axisLabel: {},
  // 分隔区域
  splitArea: {}
};
var categoryAxis = util_exports.merge({
  // 类目起始和结束两端空白策略
  boundaryGap: true,
  // splitArea: {
  // show: false
  // },
  // 坐标轴小标记
  axisTick: {
    // If tick is align with label when boundaryGap is true
    // Default with axisTick
    alignWithLabel: false,
    interval: "auto"
  },
  // 坐标轴文本标签，详见axis.axisLabel
  axisLabel: {
    interval: "auto"
  },
  axisPointer: {
    label: {
      show: false
    }
  }
}, defaultOption);
var valueAxis = util_exports.merge({
  // 数值起始和结束两端空白策略
  boundaryGap: [0, 0],
  // 最小值, 设置成 'dataMin' 则从数据中计算最小值
  // min: null,
  // 最大值，设置成 'dataMax' 则从数据中计算最大值
  // max: null,
  // 脱离0值比例，放大聚焦到最终_min，_max区间
  // scale: false,
  // 分割段数，默认为5
  splitNumber: 5,
  // Minimum interval
  // minInterval: null
  axisPointer: {
    label: {}
  }
}, defaultOption);
var timeAxis = util_exports.defaults({
  scale: true,
  min: "dataMin",
  max: "dataMax"
}, valueAxis);
var logAxis = util_exports.defaults({
  logBase: 10
}, valueAxis);
logAxis.scale = true;
var axis3DDefault_default = {
  categoryAxis3D: categoryAxis,
  valueAxis3D: valueAxis,
  timeAxis3D: timeAxis,
  logAxis3D: logAxis
};

// node_modules/echarts-gl/lib/component/grid3D/createAxis3DModel.js
var AXIS_TYPES = ["value", "category", "time", "log"];
function createAxis3DModel_default(registers, dim, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
  AXIS_TYPES.forEach(function(axisType) {
    var AxisModel = BaseAxisModelClass.extend({
      type: dim + "Axis3D." + axisType,
      /**
       * @type readOnly
       */
      __ordinalMeta: null,
      mergeDefaultAndTheme: function(option, ecModel) {
        var themeModel = ecModel.getTheme();
        util_exports.merge(option, themeModel.get(axisType + "Axis3D"));
        util_exports.merge(option, this.getDefaultOption());
        option.type = axisTypeDefaulter(dim, option);
      },
      /**
       * @override
       */
      optionUpdated: function() {
        var thisOption = this.option;
        if (thisOption.type === "category") {
          this.__ordinalMeta = OrdinalMeta_default.createByAxisModel(this);
        }
      },
      getCategories: function() {
        if (this.option.type === "category") {
          return this.__ordinalMeta.categories;
        }
      },
      getOrdinalMeta: function() {
        return this.__ordinalMeta;
      },
      defaultOption: util_exports.merge(util_exports.clone(axis3DDefault_default[axisType + "Axis3D"]), extraDefaultOption || {}, true)
    });
    registers.registerComponentModel(AxisModel);
  });
  registers.registerSubTypeDefaulter(dim + "Axis3D", util_exports.curry(axisTypeDefaulter, dim));
}

// node_modules/echarts-gl/lib/component/grid3D/install.js
function getAxisType(axisDim, option) {
  return option.type || (option.data ? "category" : "value");
}
function install2(registers) {
  registers.registerComponentModel(Grid3DModel_default);
  registers.registerComponentView(Grid3DView_default);
  registers.registerCoordinateSystem("grid3D", grid3DCreator_default);
  ["x", "y", "z"].forEach(function(dim) {
    createAxis3DModel_default(registers, dim, Axis3DModel_default, getAxisType, {
      name: dim.toUpperCase()
    });
    const AxisView = registers.ComponentView.extend({
      type: dim + "Axis3D"
    });
    registers.registerComponentView(AxisView);
  });
  registers.registerAction({
    type: "grid3DChangeCamera",
    event: "grid3dcamerachanged",
    update: "series:updateCamera"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "grid3D",
      query: payload
    }, function(componentModel) {
      componentModel.setView(payload);
    });
  });
  registers.registerAction({
    type: "grid3DShowAxisPointer",
    event: "grid3dshowaxispointer",
    update: "grid3D:showAxisPointer"
  }, function(payload, ecModel) {
  });
  registers.registerAction({
    type: "grid3DHideAxisPointer",
    event: "grid3dhideaxispointer",
    update: "grid3D:hideAxisPointer"
  }, function(payload, ecModel) {
  });
}

// node_modules/echarts-gl/lib/component/globe/GlobeModel.js
function defaultId(option, idx) {
  option.id = option.id || option.name || idx + "";
}
var GlobeModel = Component_default.extend({
  type: "globe",
  layoutMode: "box",
  coordinateSystem: null,
  init: function() {
    GlobeModel.superApply(this, "init", arguments);
    util_exports.each(this.option.layers, function(layerOption, idx) {
      util_exports.merge(layerOption, this.defaultLayerOption);
      defaultId(layerOption, idx);
    }, this);
  },
  mergeOption: function(option) {
    var oldLayers = this.option.layers;
    this.option.layers = null;
    GlobeModel.superApply(this, "mergeOption", arguments);
    function createLayerMap(layers) {
      return util_exports.reduce(layers, function(obj, layerOption, idx) {
        defaultId(layerOption, idx);
        obj[layerOption.id] = layerOption;
        return obj;
      }, {});
    }
    if (oldLayers && oldLayers.length) {
      var newLayerMap = createLayerMap(option.layers);
      var oldLayerMap = createLayerMap(oldLayers);
      for (var id in newLayerMap) {
        if (oldLayerMap[id]) {
          util_exports.merge(oldLayerMap[id], newLayerMap[id], true);
        } else {
          oldLayers.push(option.layers[id]);
        }
      }
      this.option.layers = oldLayers;
    }
    util_exports.each(this.option.layers, function(layerOption) {
      util_exports.merge(layerOption, this.defaultLayerOption);
    }, this);
  },
  optionUpdated: function() {
    this.updateDisplacementHash();
  },
  defaultLayerOption: {
    show: true,
    type: "overlay"
  },
  defaultOption: {
    show: true,
    zlevel: -10,
    // Layout used for viewport
    left: 0,
    top: 0,
    width: "100%",
    height: "100%",
    environment: "auto",
    baseColor: "#fff",
    // Base albedo texture
    baseTexture: "",
    // Height texture for bump mapping and vertex displacement
    heightTexture: "",
    // Texture for vertex displacement, default use heightTexture
    displacementTexture: "",
    // Scale of vertex displacement, available only if displacementTexture is set.
    displacementScale: 0,
    // Detail of displacement. 'low', 'medium', 'high', 'ultra'
    displacementQuality: "medium",
    // Globe radius
    globeRadius: 100,
    // Globe outer radius. Which is max of altitude.
    globeOuterRadius: 150,
    // Shading of globe
    shading: "lambert",
    // Extend light
    light: {
      // Main sun light
      main: {
        // Time, default it will use system time
        time: ""
      }
    },
    // atmosphere
    atmosphere: {
      show: false,
      offset: 5,
      color: "#ffffff",
      glowPower: 6,
      innerGlowPower: 2
    },
    // light
    // postEffect
    // temporalSuperSampling
    viewControl: {
      autoRotate: true,
      panSensitivity: 0,
      targetCoord: null
    },
    // {
    //     show: true,
    //     name: 'cloud',
    //     type: 'overlay',
    //     shading: 'lambert',
    //     distance: 10,
    //     texture: ''
    // }
    // {
    //     type: 'blend',
    //     blendTo: 'albedo'
    //     blendType: 'source-over'
    // }
    layers: []
  },
  setDisplacementData: function(data, width, height) {
    this.displacementData = data;
    this.displacementWidth = width;
    this.displacementHeight = height;
  },
  getDisplacementTexture: function() {
    return this.get("displacementTexture") || this.get("heightTexture");
  },
  getDisplacemenScale: function() {
    var displacementTexture = this.getDisplacementTexture();
    var displacementScale = this.get("displacementScale");
    if (!displacementTexture || displacementTexture === "none") {
      displacementScale = 0;
    }
    return displacementScale;
  },
  hasDisplacement: function() {
    return this.getDisplacemenScale() > 0;
  },
  _displacementChanged: true,
  _displacementScale: 0,
  updateDisplacementHash: function() {
    var displacementTexture = this.getDisplacementTexture();
    var displacementScale = this.getDisplacemenScale();
    this._displacementChanged = this._displacementTexture !== displacementTexture || this._displacementScale !== displacementScale;
    this._displacementTexture = displacementTexture;
    this._displacementScale = displacementScale;
  },
  isDisplacementChanged: function() {
    return this._displacementChanged;
  }
});
util_exports.merge(GlobeModel.prototype, componentViewControlMixin_default);
util_exports.merge(GlobeModel.prototype, componentPostEffectMixin_default);
util_exports.merge(GlobeModel.prototype, componentLightMixin_default);
util_exports.merge(GlobeModel.prototype, componentShadingMixin_default);
var GlobeModel_default = GlobeModel;

// node_modules/echarts-gl/lib/util/sunCalc.js
var PI = Math.PI;
var sin = Math.sin;
var cos = Math.cos;
var tan = Math.tan;
var asin = Math.asin;
var atan = Math.atan2;
var rad = PI / 180;
var dayMs = 1e3 * 60 * 60 * 24;
var J1970 = 2440588;
var J2000 = 2451545;
function toJulian(date) {
  return date.valueOf() / dayMs - 0.5 + J1970;
}
function toDays(date) {
  return toJulian(date) - J2000;
}
var e = rad * 23.4397;
function rightAscension(l, b) {
  return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l));
}
function declination(l, b) {
  return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l));
}
function azimuth(H, phi, dec) {
  return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi));
}
function altitude(H, phi, dec) {
  return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H));
}
function siderealTime(d, lw) {
  return rad * (280.16 + 360.9856235 * d) - lw;
}
function solarMeanAnomaly(d) {
  return rad * (357.5291 + 0.98560028 * d);
}
function eclipticLongitude(M) {
  var C = rad * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 3e-4 * sin(3 * M)), P = rad * 102.9372;
  return M + C + P + PI;
}
function sunCoords(d) {
  var M = solarMeanAnomaly(d), L = eclipticLongitude(M);
  return {
    dec: declination(L, 0),
    ra: rightAscension(L, 0)
  };
}
var SunCalc = {};
SunCalc.getPosition = function(date, lat, lng) {
  var lw = rad * -lng, phi = rad * lat, d = toDays(date), c = sunCoords(d), H = siderealTime(d, lw) - c.ra;
  return {
    azimuth: azimuth(H, phi, c.dec),
    altitude: altitude(H, phi, c.dec)
  };
};
var sunCalc_default = SunCalc;

// node_modules/echarts-gl/lib/component/globe/atmosphere.glsl.js
var atmosphere_glsl_default = "@export ecgl.atmosphere.vertex\nattribute vec3 position: POSITION;\nattribute vec3 normal : NORMAL;\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 normalMatrix : WORLDINVERSETRANSPOSE;\n\nvarying vec3 v_Normal;\n\nvoid main() {\n v_Normal = normalize((normalMatrix * vec4(normal, 0.0)).xyz);\n gl_Position = worldViewProjection * vec4(position, 1.0);\n}\n@end\n\n\n@export ecgl.atmosphere.fragment\nuniform mat4 viewTranspose: VIEWTRANSPOSE;\nuniform float glowPower;\nuniform vec3 glowColor;\n\nvarying vec3 v_Normal;\n\nvoid main() {\n float intensity = pow(1.0 - dot(v_Normal, (viewTranspose * vec4(0.0, 0.0, 1.0, 0.0)).xyz), glowPower);\n gl_FragColor = vec4(glowColor, intensity * intensity);\n}\n@end";

// node_modules/echarts-gl/lib/component/globe/GlobeView.js
graphicGL_default.Shader["import"](util_glsl_default);
graphicGL_default.Shader["import"](atmosphere_glsl_default);
var GlobeView_default = Component_default2.extend({
  type: "globe",
  __ecgl__: true,
  _displacementScale: 0,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL_default.Node();
    this._sphereGeometry = new graphicGL_default.SphereGeometry({
      widthSegments: 200,
      heightSegments: 100,
      dynamic: true
    });
    this._overlayGeometry = new graphicGL_default.SphereGeometry({
      widthSegments: 80,
      heightSegments: 40
    });
    this._planeGeometry = new graphicGL_default.PlaneGeometry();
    this._earthMesh = new graphicGL_default.Mesh({
      renderNormal: true
    });
    this._atmosphereMesh = new graphicGL_default.Mesh();
    this._atmosphereGeometry = new graphicGL_default.SphereGeometry({
      widthSegments: 80,
      heightSegments: 40
    });
    this._atmosphereMaterial = new graphicGL_default.Material({
      shader: new graphicGL_default.Shader(graphicGL_default.Shader.source("ecgl.atmosphere.vertex"), graphicGL_default.Shader.source("ecgl.atmosphere.fragment")),
      transparent: true
    });
    this._atmosphereMesh.geometry = this._atmosphereGeometry;
    this._atmosphereMesh.material = this._atmosphereMaterial;
    this._atmosphereMesh.frontFace = graphicGL_default.Mesh.CW;
    this._lightRoot = new graphicGL_default.Node();
    this._sceneHelper = new SceneHelper_default();
    this._sceneHelper.initLight(this._lightRoot);
    this.groupGL.add(this._atmosphereMesh);
    this.groupGL.add(this._earthMesh);
    this._control = new OrbitControl_default({
      zr: api.getZr()
    });
    this._control.init();
    this._layerMeshes = {};
  },
  render: function(globeModel, ecModel, api) {
    var coordSys = globeModel.coordinateSystem;
    var shading = globeModel.get("shading");
    coordSys.viewGL.add(this._lightRoot);
    if (globeModel.get("show")) {
      coordSys.viewGL.add(this.groupGL);
    } else {
      coordSys.viewGL.remove(this.groupGL);
    }
    this._sceneHelper.setScene(coordSys.viewGL.scene);
    coordSys.viewGL.setPostEffect(globeModel.getModel("postEffect"), api);
    coordSys.viewGL.setTemporalSuperSampling(globeModel.getModel("temporalSuperSampling"));
    var earthMesh = this._earthMesh;
    earthMesh.geometry = this._sphereGeometry;
    var shadingPrefix = "ecgl." + shading;
    if (!earthMesh.material || earthMesh.material.shader.name !== shadingPrefix) {
      earthMesh.material = graphicGL_default.createMaterial(shadingPrefix);
    }
    graphicGL_default.setMaterialFromModel(shading, earthMesh.material, globeModel, api);
    ["roughnessMap", "metalnessMap", "detailMap", "normalMap"].forEach(function(texName) {
      var texture = earthMesh.material.get(texName);
      if (texture) {
        texture.flipY = false;
      }
    });
    earthMesh.material.set("color", graphicGL_default.parseColor(globeModel.get("baseColor")));
    var scale = coordSys.radius * 0.99;
    earthMesh.scale.set(scale, scale, scale);
    if (globeModel.get("atmosphere.show")) {
      earthMesh.material.define("both", "ATMOSPHERE_ENABLED");
      this._atmosphereMesh.invisible = false;
      this._atmosphereMaterial.setUniforms({
        glowPower: globeModel.get("atmosphere.glowPower") || 6,
        glowColor: globeModel.get("atmosphere.color") || "#ffffff"
      });
      earthMesh.material.setUniforms({
        glowPower: globeModel.get("atmosphere.innerGlowPower") || 2,
        glowColor: globeModel.get("atmosphere.color") || "#ffffff"
      });
      var offset = globeModel.get("atmosphere.offset") || 5;
      this._atmosphereMesh.scale.set(scale + offset, scale + offset, scale + offset);
    } else {
      earthMesh.material.undefine("both", "ATMOSPHERE_ENABLED");
      this._atmosphereMesh.invisible = true;
    }
    var diffuseTexture = earthMesh.material.setTextureImage("diffuseMap", globeModel.get("baseTexture"), api, {
      flipY: false,
      anisotropic: 8
    });
    if (diffuseTexture && diffuseTexture.surface) {
      diffuseTexture.surface.attachToMesh(earthMesh);
    }
    var bumpTexture = earthMesh.material.setTextureImage("bumpMap", globeModel.get("heightTexture"), api, {
      flipY: false,
      anisotropic: 8
    });
    if (bumpTexture && bumpTexture.surface) {
      bumpTexture.surface.attachToMesh(earthMesh);
    }
    earthMesh.material[globeModel.get("postEffect.enable") ? "define" : "undefine"]("fragment", "SRGB_DECODE");
    this._updateLight(globeModel, api);
    this._displaceVertices(globeModel, api);
    this._updateViewControl(globeModel, api);
    this._updateLayers(globeModel, api);
  },
  afterRender: function(globeModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    this._sceneHelper.updateAmbientCubemap(renderer, globeModel, api);
    this._sceneHelper.updateSkybox(renderer, globeModel, api);
  },
  _updateLayers: function(globeModel, api) {
    var coordSys = globeModel.coordinateSystem;
    var layers = globeModel.get("layers");
    var lastDistance = coordSys.radius;
    var layerDiffuseTextures = [];
    var layerDiffuseIntensity = [];
    var layerEmissiveTextures = [];
    var layerEmissionIntensity = [];
    util_exports.each(layers, function(layerOption) {
      var layerModel = new Model_default(layerOption);
      var layerType = layerModel.get("type");
      var texture = graphicGL_default.loadTexture(layerModel.get("texture"), api, {
        flipY: false,
        anisotropic: 8
      });
      if (texture.surface) {
        texture.surface.attachToMesh(this._earthMesh);
      }
      if (layerType === "blend") {
        var blendTo = layerModel.get("blendTo");
        var intensity = retrieve_default.firstNotNull(layerModel.get("intensity"), 1);
        if (blendTo === "emission") {
          layerEmissiveTextures.push(texture);
          layerEmissionIntensity.push(intensity);
        } else {
          layerDiffuseTextures.push(texture);
          layerDiffuseIntensity.push(intensity);
        }
      } else {
        var id = layerModel.get("id");
        var overlayMesh = this._layerMeshes[id];
        if (!overlayMesh) {
          overlayMesh = this._layerMeshes[id] = new graphicGL_default.Mesh({
            geometry: this._overlayGeometry,
            castShadow: false,
            ignorePicking: true
          });
        }
        var shading = layerModel.get("shading");
        if (shading === "lambert") {
          overlayMesh.material = overlayMesh.__lambertMaterial || new graphicGL_default.Material({
            autoUpdateTextureStatus: false,
            shader: graphicGL_default.createShader("ecgl.lambert"),
            transparent: true,
            depthMask: false
          });
          overlayMesh.__lambertMaterial = overlayMesh.material;
        } else {
          overlayMesh.material = overlayMesh.__colorMaterial || new graphicGL_default.Material({
            autoUpdateTextureStatus: false,
            shader: graphicGL_default.createShader("ecgl.color"),
            transparent: true,
            depthMask: false
          });
          overlayMesh.__colorMaterial = overlayMesh.material;
        }
        overlayMesh.material.enableTexture("diffuseMap");
        var distance = layerModel.get("distance");
        var radius = lastDistance + (distance == null ? coordSys.radius / 100 : distance);
        overlayMesh.scale.set(radius, radius, radius);
        lastDistance = radius;
        var blankTexture = this._blankTexture || (this._blankTexture = graphicGL_default.createBlankTexture("rgba(255, 255, 255, 0)"));
        overlayMesh.material.set("diffuseMap", blankTexture);
        graphicGL_default.loadTexture(layerModel.get("texture"), api, {
          flipY: false,
          anisotropic: 8
        }, function(texture2) {
          if (texture2.surface) {
            texture2.surface.attachToMesh(overlayMesh);
          }
          overlayMesh.material.set("diffuseMap", texture2);
          api.getZr().refresh();
        });
        layerModel.get("show") ? this.groupGL.add(overlayMesh) : this.groupGL.remove(overlayMesh);
      }
    }, this);
    var earthMaterial = this._earthMesh.material;
    earthMaterial.define("fragment", "LAYER_DIFFUSEMAP_COUNT", layerDiffuseTextures.length);
    earthMaterial.define("fragment", "LAYER_EMISSIVEMAP_COUNT", layerEmissiveTextures.length);
    earthMaterial.set("layerDiffuseMap", layerDiffuseTextures);
    earthMaterial.set("layerDiffuseIntensity", layerDiffuseIntensity);
    earthMaterial.set("layerEmissiveMap", layerEmissiveTextures);
    earthMaterial.set("layerEmissionIntensity", layerEmissionIntensity);
    var debugWireframeModel = globeModel.getModel("debug.wireframe");
    if (debugWireframeModel.get("show")) {
      earthMaterial.define("both", "WIREFRAME_TRIANGLE");
      var color = graphicGL_default.parseColor(debugWireframeModel.get("lineStyle.color") || "rgba(0,0,0,0.5)");
      var width = retrieve_default.firstNotNull(debugWireframeModel.get("lineStyle.width"), 1);
      earthMaterial.set("wireframeLineWidth", width);
      earthMaterial.set("wireframeLineColor", color);
    } else {
      earthMaterial.undefine("both", "WIREFRAME_TRIANGLE");
    }
  },
  _updateViewControl: function(globeModel, api) {
    var coordSys = globeModel.coordinateSystem;
    var viewControlModel = globeModel.getModel("viewControl");
    var camera = coordSys.viewGL.camera;
    var self = this;
    function makeAction() {
      return {
        type: "globeChangeCamera",
        alpha: control.getAlpha(),
        beta: control.getBeta(),
        distance: control.getDistance() - coordSys.radius,
        center: control.getCenter(),
        from: self.uid,
        globeId: globeModel.id
      };
    }
    var control = this._control;
    control.setViewGL(coordSys.viewGL);
    var coord = viewControlModel.get("targetCoord");
    var alpha, beta;
    if (coord != null) {
      beta = coord[0] + 90;
      alpha = coord[1];
    }
    control.setFromViewControlModel(viewControlModel, {
      baseDistance: coordSys.radius,
      alpha,
      beta
    });
    control.off("update");
    control.on("update", function() {
      api.dispatchAction(makeAction());
    });
  },
  _displaceVertices: function(globeModel, api) {
    var displacementQuality = globeModel.get("displacementQuality");
    var showDebugWireframe = globeModel.get("debug.wireframe.show");
    var globe = globeModel.coordinateSystem;
    if (!globeModel.isDisplacementChanged() && displacementQuality === this._displacementQuality && showDebugWireframe === this._showDebugWireframe) {
      return;
    }
    this._displacementQuality = displacementQuality;
    this._showDebugWireframe = showDebugWireframe;
    var geometry = this._sphereGeometry;
    var widthSegments = {
      low: 100,
      medium: 200,
      high: 400,
      ultra: 800
    }[displacementQuality] || 200;
    var heightSegments = widthSegments / 2;
    if (geometry.widthSegments !== widthSegments || showDebugWireframe) {
      geometry.widthSegments = widthSegments;
      geometry.heightSegments = heightSegments;
      geometry.build();
    }
    this._doDisplaceVertices(geometry, globe);
    if (showDebugWireframe) {
      geometry.generateBarycentric();
    }
  },
  _doDisplaceVertices: function(geometry, globe) {
    var positionArr = geometry.attributes.position.value;
    var uvArr = geometry.attributes.texcoord0.value;
    var originalPositionArr = geometry.__originalPosition;
    if (!originalPositionArr || originalPositionArr.length !== positionArr.length) {
      originalPositionArr = new Float32Array(positionArr.length);
      originalPositionArr.set(positionArr);
      geometry.__originalPosition = originalPositionArr;
    }
    var width = globe.displacementWidth;
    var height = globe.displacementHeight;
    var data = globe.displacementData;
    for (var i = 0; i < geometry.vertexCount; i++) {
      var i3 = i * 3;
      var i2 = i * 2;
      var x = originalPositionArr[i3 + 1];
      var y = originalPositionArr[i3 + 2];
      var z = originalPositionArr[i3 + 3];
      var u = uvArr[i2++];
      var v = uvArr[i2++];
      var j = Math.round(u * (width - 1));
      var k = Math.round(v * (height - 1));
      var idx = k * width + j;
      var scale = data ? data[idx] : 0;
      positionArr[i3 + 1] = x + x * scale;
      positionArr[i3 + 2] = y + y * scale;
      positionArr[i3 + 3] = z + z * scale;
    }
    geometry.generateVertexNormals();
    geometry.dirty();
    geometry.updateBoundingBox();
  },
  _updateLight: function(globeModel, api) {
    var earthMesh = this._earthMesh;
    this._sceneHelper.updateLight(globeModel);
    var mainLight = this._sceneHelper.mainLight;
    var time = globeModel.get("light.main.time") || /* @__PURE__ */ new Date();
    var pos = sunCalc_default.getPosition(number_exports.parseDate(time), 0, 0);
    var r0 = Math.cos(pos.altitude);
    mainLight.position.y = -r0 * Math.cos(pos.azimuth);
    mainLight.position.x = Math.sin(pos.altitude);
    mainLight.position.z = r0 * Math.sin(pos.azimuth);
    mainLight.lookAt(earthMesh.getWorldPosition());
  },
  dispose: function(ecModel, api) {
    this.groupGL.removeAll();
    this._control.dispose();
  }
});

// node_modules/echarts-gl/lib/coord/globe/Globe.js
var vec32 = glmatrix_default.vec3;
function Globe(radius) {
  this.radius = radius;
  this.viewGL = null;
  this.altitudeAxis;
  this.displacementData = null;
  this.displacementWidth;
  this.displacementHeight;
}
Globe.prototype = {
  constructor: Globe,
  dimensions: ["lng", "lat", "alt"],
  type: "globe",
  containPoint: function() {
  },
  setDisplacementData: function(data, width, height) {
    this.displacementData = data;
    this.displacementWidth = width;
    this.displacementHeight = height;
  },
  _getDisplacementScale: function(lng, lat) {
    var i = (lng + 180) / 360 * (this.displacementWidth - 1);
    var j = (90 - lat) / 180 * (this.displacementHeight - 1);
    var idx = Math.round(i) + Math.round(j) * this.displacementWidth;
    return this.displacementData[idx];
  },
  dataToPoint: function(data, out) {
    var lng = data[0];
    var lat = data[1];
    var altVal = data[2] || 0;
    var r = this.radius;
    if (this.displacementData) {
      r *= 1 + this._getDisplacementScale(lng, lat);
    }
    if (this.altitudeAxis) {
      r += this.altitudeAxis.dataToCoord(altVal);
    }
    lng = lng * Math.PI / 180;
    lat = lat * Math.PI / 180;
    var r0 = Math.cos(lat) * r;
    out = out || [];
    out[0] = -r0 * Math.cos(lng + Math.PI);
    out[1] = Math.sin(lat) * r;
    out[2] = r0 * Math.sin(lng + Math.PI);
    return out;
  },
  pointToData: function(point, out) {
    var x = point[0];
    var y = point[1];
    var z = point[2];
    var len = vec32.len(point);
    x /= len;
    y /= len;
    z /= len;
    var theta = Math.asin(y);
    var phi = Math.atan2(z, -x);
    if (phi < 0) {
      phi = Math.PI * 2 + phi;
    }
    var lat = theta * 180 / Math.PI;
    var lng = phi * 180 / Math.PI - 180;
    out = out || [];
    out[0] = lng;
    out[1] = lat;
    out[2] = len - this.radius;
    if (this.altitudeAxis) {
      out[2] = this.altitudeAxis.coordToData(out[2]);
    }
    return out;
  }
};
var Globe_default = Globe;

// node_modules/echarts-gl/lib/coord/globeCreator.js
function getDisplacementData(img, displacementScale) {
  var canvas = document.createElement("canvas");
  var ctx = canvas.getContext("2d");
  var width = img.width;
  var height = img.height;
  canvas.width = width;
  canvas.height = height;
  ctx.drawImage(img, 0, 0, width, height);
  var rgbaArr = ctx.getImageData(0, 0, width, height).data;
  var displacementArr = new Float32Array(rgbaArr.length / 4);
  for (var i = 0; i < rgbaArr.length / 4; i++) {
    var x = rgbaArr[i * 4];
    displacementArr[i] = x / 255 * displacementScale;
  }
  return {
    data: displacementArr,
    width,
    height
  };
}
function resizeGlobe(globeModel, api) {
  var boxLayoutOption = globeModel.getBoxLayoutParams();
  var viewport = getLayoutRect(boxLayoutOption, {
    width: api.getWidth(),
    height: api.getHeight()
  });
  viewport.y = api.getHeight() - viewport.y - viewport.height;
  this.viewGL.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, api.getDevicePixelRatio());
  this.radius = globeModel.get("globeRadius");
  var outerRadius = globeModel.get("globeOuterRadius");
  if (this.altitudeAxis) {
    this.altitudeAxis.setExtent(0, outerRadius - this.radius);
  }
}
function updateGlobe(ecModel, api) {
  var altitudeDataExtent = [Infinity, -Infinity];
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.coordinateSystem !== this) {
      return;
    }
    var data = seriesModel.getData();
    var altDims = seriesModel.coordDimToDataDim("alt");
    var altDim = altDims && altDims[0];
    if (altDim) {
      var dataExtent = data.getDataExtent(altDim, true);
      altitudeDataExtent[0] = Math.min(altitudeDataExtent[0], dataExtent[0]);
      altitudeDataExtent[1] = Math.max(altitudeDataExtent[1], dataExtent[1]);
    }
  }, this);
  if (altitudeDataExtent && isFinite(altitudeDataExtent[1] - altitudeDataExtent[0])) {
    var scale = helper_exports.createScale(altitudeDataExtent, {
      type: "value",
      // PENDING
      min: "dataMin",
      max: "dataMax"
    });
    this.altitudeAxis = new Axis_default("altitude", scale);
    this.resize(this.model, api);
  }
}
var globeCreator = {
  dimensions: Globe_default.prototype.dimensions,
  create: function(ecModel, api) {
    var globeList = [];
    ecModel.eachComponent("globe", function(globeModel) {
      globeModel.__viewGL = globeModel.__viewGL || new ViewGL_default();
      var globe = new Globe_default();
      globe.viewGL = globeModel.__viewGL;
      globeModel.coordinateSystem = globe;
      globe.model = globeModel;
      globeList.push(globe);
      globe.resize = resizeGlobe;
      globe.resize(globeModel, api);
      globe.update = updateGlobe;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "globe") {
        var globeModel = seriesModel.getReferringComponents("globe").models[0];
        if (!globeModel) {
          globeModel = ecModel.getComponent("globe");
        }
        if (!globeModel) {
          throw new Error('globe "' + retrieve_default.firstNotNull(seriesModel.get("globe3DIndex"), seriesModel.get("globe3DId"), 0) + '" not found');
        }
        var coordSys = globeModel.coordinateSystem;
        seriesModel.coordinateSystem = coordSys;
      }
    });
    ecModel.eachComponent("globe", function(globeModel, idx) {
      var globe = globeModel.coordinateSystem;
      var displacementTextureValue = globeModel.getDisplacementTexture();
      var displacementScale = globeModel.getDisplacemenScale();
      if (globeModel.isDisplacementChanged()) {
        if (globeModel.hasDisplacement()) {
          var immediateLoaded = true;
          graphicGL_default.loadTexture(displacementTextureValue, api, function(texture) {
            var img = texture.image;
            var displacementData = getDisplacementData(img, displacementScale);
            globeModel.setDisplacementData(displacementData.data, displacementData.width, displacementData.height);
            if (!immediateLoaded) {
              api.dispatchAction({
                type: "globeUpdateDisplacment"
              });
            }
          });
          immediateLoaded = false;
        } else {
          globe.setDisplacementData(null, 0, 0);
        }
        globe.setDisplacementData(globeModel.displacementData, globeModel.displacementWidth, globeModel.displacementHeight);
      }
    });
    return globeList;
  }
};
var globeCreator_default = globeCreator;

// node_modules/echarts-gl/lib/component/globe/install.js
function install3(registers) {
  registers.registerComponentModel(GlobeModel_default);
  registers.registerComponentView(GlobeView_default);
  registers.registerCoordinateSystem("globe", globeCreator_default);
  registers.registerAction({
    type: "globeChangeCamera",
    event: "globecamerachanged",
    update: "series:updateCamera"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "globe",
      query: payload
    }, function(componentModel) {
      componentModel.setView(payload);
    });
  });
  registers.registerAction({
    type: "globeUpdateDisplacment",
    event: "globedisplacementupdated",
    update: "update"
  }, function(payload, ecModel) {
  });
}

// node_modules/echarts-gl/lib/component/mapbox3D/Mapbox3DModel.js
var MAPBOX_CAMERA_OPTION = ["zoom", "center", "pitch", "bearing"];
var Mapbox3DModel = Component_default.extend({
  type: "mapbox3D",
  layoutMode: "box",
  coordinateSystem: null,
  defaultOption: {
    zlevel: -10,
    style: "mapbox://styles/mapbox/light-v9",
    center: [0, 0],
    zoom: 0,
    pitch: 0,
    bearing: 0,
    light: {
      main: {
        alpha: 20,
        beta: 30
      }
    },
    altitudeScale: 1,
    // Default depend on altitudeScale
    boxHeight: "auto"
  },
  getMapboxCameraOption: function() {
    var self = this;
    return MAPBOX_CAMERA_OPTION.reduce(function(obj, key) {
      obj[key] = self.get(key);
      return obj;
    }, {});
  },
  setMapboxCameraOption: function(option) {
    if (option != null) {
      MAPBOX_CAMERA_OPTION.forEach(function(key) {
        if (option[key] != null) {
          this.option[key] = option[key];
        }
      }, this);
    }
  },
  /**
   * Get mapbox instance
   */
  getMapbox: function() {
    return this._mapbox;
  },
  setMapbox: function(mapbox) {
    this._mapbox = mapbox;
  }
});
util_exports.merge(Mapbox3DModel.prototype, componentPostEffectMixin_default);
util_exports.merge(Mapbox3DModel.prototype, componentLightMixin_default);
var Mapbox3DModel_default = Mapbox3DModel;

// node_modules/echarts-gl/lib/component/mapbox3D/Mapbox3DLayer.js
function Mapbox3DLayer(id, zr) {
  this.id = id;
  this.zr = zr;
  this.dom = document.createElement("div");
  this.dom.style.cssText = "position:absolute;left:0;right:0;top:0;bottom:0;";
  if (!mapboxgl) {
    throw new Error("Mapbox GL library must be included. See https://www.mapbox.com/mapbox-gl-js/api/");
  }
  this._mapbox = new mapboxgl.Map({
    container: this.dom
  });
  this._initEvents();
}
Mapbox3DLayer.prototype.setUnpainted = function() {
};
Mapbox3DLayer.prototype.resize = function() {
  this._mapbox.resize();
};
Mapbox3DLayer.prototype.getMapbox = function() {
  return this._mapbox;
};
Mapbox3DLayer.prototype.clear = function() {
};
Mapbox3DLayer.prototype.refresh = function() {
  this._mapbox.resize();
};
var EVENTS = ["mousedown", "mouseup", "click", "dblclick", "mousemove", "mousewheel", "wheel", "touchstart", "touchend", "touchmove", "touchcancel"];
Mapbox3DLayer.prototype._initEvents = function() {
  var mapboxRoot = this._mapbox.getCanvasContainer();
  this._handlers = this._handlers || {
    contextmenu: function(e2) {
      e2.preventDefault();
      return false;
    }
  };
  EVENTS.forEach(function(eName) {
    this._handlers[eName] = function(e2) {
      var obj = {};
      for (var name in e2) {
        obj[name] = e2[name];
      }
      obj.bubbles = false;
      var newE = new e2.constructor(e2.type, obj);
      mapboxRoot.dispatchEvent(newE);
    };
    this.zr.dom.addEventListener(eName, this._handlers[eName]);
  }, this);
  this.zr.dom.addEventListener("contextmenu", this._handlers.contextmenu);
};
Mapbox3DLayer.prototype.dispose = function() {
  EVENTS.forEach(function(eName) {
    this.zr.dom.removeEventListener(eName, this._handlers[eName]);
  }, this);
};
var Mapbox3DLayer_default = Mapbox3DLayer;

// node_modules/echarts-gl/lib/util/shader/displayShadow.glsl.js
var displayShadow_glsl_default = "\n@export ecgl.displayShadow.vertex\n\n@import ecgl.common.transformUniforms\n\n@import ecgl.common.uv.header\n\n@import ecgl.common.attributes\n\nvarying vec3 v_WorldPosition;\n\nvarying vec3 v_Normal;\n\nvoid main()\n{\n @import ecgl.common.uv.main\n v_Normal = normalize((worldInverseTranspose * vec4(normal, 0.0)).xyz);\n\n v_WorldPosition = (world * vec4(position, 1.0)).xyz;\n gl_Position = worldViewProjection * vec4(position, 1.0);\n}\n\n@end\n\n\n@export ecgl.displayShadow.fragment\n\n@import ecgl.common.uv.fragmentHeader\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform float roughness: 0.2;\n\n#ifdef DIRECTIONAL_LIGHT_COUNT\n@import clay.header.directional_light\n#endif\n\n@import ecgl.common.ssaoMap.header\n\n@import clay.plugin.compute_shadow_map\n\nvoid main()\n{\n float shadow = 1.0;\n\n @import ecgl.common.ssaoMap.main\n\n#if defined(DIRECTIONAL_LIGHT_COUNT) && defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n float shadowContribsDir[DIRECTIONAL_LIGHT_COUNT];\n if(shadowEnabled)\n {\n computeShadowOfDirectionalLights(v_WorldPosition, shadowContribsDir);\n }\n for (int i = 0; i < DIRECTIONAL_LIGHT_COUNT; i++) {\n shadow = min(shadow, shadowContribsDir[i] * 0.5 + 0.5);\n }\n#endif\n\n shadow *= 0.5 + ao * 0.5;\n shadow = clamp(shadow, 0.0, 1.0);\n\n gl_FragColor = vec4(vec3(0.0), 1.0 - shadow);\n}\n\n@end";

// node_modules/echarts-gl/lib/component/mapbox3D/Mapbox3DView.js
graphicGL_default.Shader.import(displayShadow_glsl_default);
var Mapbox3DView_default = Component_default2.extend({
  type: "mapbox3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    var zr = api.getZr();
    this._zrLayer = new Mapbox3DLayer_default("mapbox3D", zr);
    zr.painter.insertLayer(-1e3, this._zrLayer);
    this._lightRoot = new graphicGL_default.Node();
    this._sceneHelper = new SceneHelper_default(this._lightRoot);
    this._sceneHelper.initLight(this._lightRoot);
    var mapbox = this._zrLayer.getMapbox();
    var dispatchInteractAction = this._dispatchInteractAction.bind(this, api, mapbox);
    ["zoom", "rotate", "drag", "pitch", "rotate", "move"].forEach(function(eName) {
      mapbox.on(eName, dispatchInteractAction);
    });
    this._groundMesh = new graphicGL_default.Mesh({
      geometry: new graphicGL_default.PlaneGeometry(),
      material: new graphicGL_default.Material({
        shader: new graphicGL_default.Shader({
          vertex: graphicGL_default.Shader.source("ecgl.displayShadow.vertex"),
          fragment: graphicGL_default.Shader.source("ecgl.displayShadow.fragment")
        }),
        depthMask: false
      }),
      // Render first
      renderOrder: -100,
      culling: false,
      castShadow: false,
      $ignorePicking: true,
      renderNormal: true
    });
  },
  render: function(mapbox3DModel, ecModel, api) {
    var mapbox = this._zrLayer.getMapbox();
    var styleDesc = mapbox3DModel.get("style");
    var styleStr = JSON.stringify(styleDesc);
    if (styleStr !== this._oldStyleStr) {
      if (styleDesc) {
        mapbox.setStyle(styleDesc);
      }
    }
    this._oldStyleStr = styleStr;
    mapbox.setCenter(mapbox3DModel.get("center"));
    mapbox.setZoom(mapbox3DModel.get("zoom"));
    mapbox.setPitch(mapbox3DModel.get("pitch"));
    mapbox.setBearing(mapbox3DModel.get("bearing"));
    mapbox3DModel.setMapbox(mapbox);
    var coordSys = mapbox3DModel.coordinateSystem;
    coordSys.viewGL.scene.add(this._lightRoot);
    coordSys.viewGL.add(this._groundMesh);
    this._updateGroundMesh();
    this._sceneHelper.setScene(coordSys.viewGL.scene);
    this._sceneHelper.updateLight(mapbox3DModel);
    coordSys.viewGL.setPostEffect(mapbox3DModel.getModel("postEffect"), api);
    coordSys.viewGL.setTemporalSuperSampling(mapbox3DModel.getModel("temporalSuperSampling"));
    this._mapbox3DModel = mapbox3DModel;
  },
  afterRender: function(mapbox3DModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    this._sceneHelper.updateAmbientCubemap(renderer, mapbox3DModel, api);
    this._sceneHelper.updateSkybox(renderer, mapbox3DModel, api);
    mapbox3DModel.coordinateSystem.viewGL.scene.traverse(function(mesh) {
      if (mesh.material) {
        mesh.material.define("fragment", "NORMAL_UP_AXIS", 2);
        mesh.material.define("fragment", "NORMAL_FRONT_AXIS", 1);
      }
    });
  },
  updateCamera: function(mapbox3DModel, ecModel, api, payload) {
    mapbox3DModel.coordinateSystem.setCameraOption(payload);
    this._updateGroundMesh();
    api.getZr().refresh();
  },
  _dispatchInteractAction: function(api, mapbox, mapbox3DModel) {
    api.dispatchAction({
      type: "mapbox3DChangeCamera",
      pitch: mapbox.getPitch(),
      zoom: mapbox.getZoom(),
      center: mapbox.getCenter().toArray(),
      bearing: mapbox.getBearing(),
      mapbox3DId: this._mapbox3DModel && this._mapbox3DModel.id
    });
  },
  _updateGroundMesh: function() {
    if (this._mapbox3DModel) {
      var coordSys = this._mapbox3DModel.coordinateSystem;
      var pt = coordSys.dataToPoint(coordSys.center);
      this._groundMesh.position.set(pt[0], pt[1], -1e-3);
      var plane = new graphicGL_default.Plane(new graphicGL_default.Vector3(0, 0, 1), 0);
      var ray1 = coordSys.viewGL.camera.castRay(new graphicGL_default.Vector2(-1, -1));
      var ray2 = coordSys.viewGL.camera.castRay(new graphicGL_default.Vector2(1, 1));
      var pos0 = ray1.intersectPlane(plane);
      var pos1 = ray2.intersectPlane(plane);
      var scale = pos0.dist(pos1) / coordSys.viewGL.rootNode.scale.x;
      this._groundMesh.scale.set(scale, scale, 1);
    }
  },
  dispose: function(ecModel, api) {
    if (this._zrLayer) {
      this._zrLayer.dispose();
    }
    api.getZr().painter.delLayer(-1e3);
  }
});

// node_modules/echarts-gl/lib/coord/mapServiceCommon/MapService3D.js
var mat4 = glmatrix_default.mat4;
var TILE_SIZE = 512;
var FOV = 0.6435011087932844;
var PI2 = Math.PI;
var WORLD_SCALE = 1 / 10;
function MapServiceCoordSys3D() {
  this.width = 0;
  this.height = 0;
  this.altitudeScale = 1;
  this.boxHeight = "auto";
  this.altitudeExtent;
  this.bearing = 0;
  this.pitch = 0;
  this.center = [0, 0];
  this._origin;
  this.zoom = 0;
  this._initialZoom;
  this.maxPitch = 60;
  this.zoomOffset = 0;
}
MapServiceCoordSys3D.prototype = {
  constructor: MapServiceCoordSys3D,
  dimensions: ["lng", "lat", "alt"],
  containPoint: function() {
  },
  setCameraOption: function(option) {
    this.bearing = option.bearing;
    this.pitch = option.pitch;
    this.center = option.center;
    this.zoom = option.zoom;
    if (!this._origin) {
      this._origin = this.projectOnTileWithScale(this.center, TILE_SIZE);
    }
    if (this._initialZoom == null) {
      this._initialZoom = this.zoom;
    }
    this.updateTransform();
  },
  // https://github.com/mapbox/mapbox-gl-js/blob/master/src/geo/transform.js#L479
  updateTransform: function() {
    if (!this.height) {
      return;
    }
    var cameraToCenterDistance = 0.5 / Math.tan(FOV / 2) * this.height * WORLD_SCALE;
    var pitch = Math.max(Math.min(this.pitch, this.maxPitch), 0) / 180 * Math.PI;
    var halfFov = FOV / 2;
    var groundAngle = Math.PI / 2 + pitch;
    var topHalfSurfaceDistance = Math.sin(halfFov) * cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov);
    var furthestDistance = Math.cos(Math.PI / 2 - pitch) * topHalfSurfaceDistance + cameraToCenterDistance;
    var farZ = furthestDistance * 1.1;
    if (this.pitch > 50) {
      farZ = 1e3;
    }
    var m = [];
    mat4.perspective(m, FOV, this.width / this.height, 1, farZ);
    this.viewGL.camera.projectionMatrix.setArray(m);
    this.viewGL.camera.decomposeProjectionMatrix();
    var m = mat4.identity([]);
    var pt = this.dataToPoint(this.center);
    mat4.scale(m, m, [1, -1, 1]);
    mat4.translate(m, m, [0, 0, -cameraToCenterDistance]);
    mat4.rotateX(m, m, pitch);
    mat4.rotateZ(m, m, -this.bearing / 180 * Math.PI);
    mat4.translate(m, m, [-pt[0] * this.getScale() * WORLD_SCALE, -pt[1] * this.getScale() * WORLD_SCALE, 0]);
    this.viewGL.camera.viewMatrix.array = m;
    var invertM = [];
    mat4.invert(invertM, m);
    this.viewGL.camera.worldTransform.array = invertM;
    this.viewGL.camera.decomposeWorldTransform();
    var worldSize = TILE_SIZE * this.getScale();
    var verticalScale;
    if (this.altitudeExtent && !isNaN(this.boxHeight)) {
      var range = this.altitudeExtent[1] - this.altitudeExtent[0];
      verticalScale = this.boxHeight / range * this.getScale() / Math.pow(2, this._initialZoom - this.zoomOffset);
    } else {
      verticalScale = worldSize / (2 * Math.PI * 6378e3 * Math.abs(Math.cos(this.center[1] * (Math.PI / 180)))) * this.altitudeScale * WORLD_SCALE;
    }
    this.viewGL.rootNode.scale.set(this.getScale() * WORLD_SCALE, this.getScale() * WORLD_SCALE, verticalScale);
  },
  getScale: function() {
    return Math.pow(2, this.zoom - this.zoomOffset);
  },
  projectOnTile: function(data, out) {
    return this.projectOnTileWithScale(data, this.getScale() * TILE_SIZE, out);
  },
  projectOnTileWithScale: function(data, scale, out) {
    var lng = data[0];
    var lat = data[1];
    var lambda2 = lng * PI2 / 180;
    var phi2 = lat * PI2 / 180;
    var x = scale * (lambda2 + PI2) / (2 * PI2);
    var y = scale * (PI2 - Math.log(Math.tan(PI2 / 4 + phi2 * 0.5))) / (2 * PI2);
    out = out || [];
    out[0] = x;
    out[1] = y;
    return out;
  },
  unprojectFromTile: function(point, out) {
    return this.unprojectOnTileWithScale(point, this.getScale() * TILE_SIZE, out);
  },
  unprojectOnTileWithScale: function(point, scale, out) {
    var x = point[0];
    var y = point[1];
    var lambda2 = x / scale * (2 * PI2) - PI2;
    var phi2 = 2 * (Math.atan(Math.exp(PI2 - y / scale * (2 * PI2))) - PI2 / 4);
    out = out || [];
    out[0] = lambda2 * 180 / PI2;
    out[1] = phi2 * 180 / PI2;
    return out;
  },
  dataToPoint: function(data, out) {
    out = this.projectOnTileWithScale(data, TILE_SIZE, out);
    out[0] -= this._origin[0];
    out[1] -= this._origin[1];
    out[2] = !isNaN(data[2]) ? data[2] : 0;
    if (!isNaN(data[2])) {
      out[2] = data[2];
      if (this.altitudeExtent) {
        out[2] -= this.altitudeExtent[0];
      }
    }
    return out;
  }
};
var MapService3D_default = MapServiceCoordSys3D;

// node_modules/echarts-gl/lib/coord/mapbox3D/Mapbox3D.js
function Mapbox3D() {
  MapService3D_default.apply(this, arguments);
}
Mapbox3D.prototype = new MapService3D_default();
Mapbox3D.prototype.constructor = Mapbox3D;
Mapbox3D.prototype.type = "mapbox3D";
var Mapbox3D_default = Mapbox3D;

// node_modules/echarts-gl/lib/coord/mapServiceCommon/createMapService3DCreator.js
function createMapService3DCreator_default(serviceComponentType, ServiceCtor, afterCreate) {
  function resizeMapService3D(mapService3DModel, api) {
    var width = api.getWidth();
    var height = api.getHeight();
    var dpr = api.getDevicePixelRatio();
    this.viewGL.setViewport(0, 0, width, height, dpr);
    this.width = width;
    this.height = height;
    this.altitudeScale = mapService3DModel.get("altitudeScale");
    this.boxHeight = mapService3DModel.get("boxHeight");
  }
  function updateService3D(ecModel, api) {
    if (this.model.get("boxHeight") === "auto") {
      return;
    }
    var altitudeDataExtent = [Infinity, -Infinity];
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.coordinateSystem !== this) {
        return;
      }
      var data = seriesModel.getData();
      var altDim = seriesModel.coordDimToDataDim("alt")[0];
      if (altDim) {
        var dataExtent = data.getDataExtent(altDim, true);
        altitudeDataExtent[0] = Math.min(altitudeDataExtent[0], dataExtent[0]);
        altitudeDataExtent[1] = Math.max(altitudeDataExtent[1], dataExtent[1]);
      }
    }, this);
    if (altitudeDataExtent && isFinite(altitudeDataExtent[1] - altitudeDataExtent[0])) {
      this.altitudeExtent = altitudeDataExtent;
    }
  }
  return {
    dimensions: ServiceCtor.prototype.dimensions,
    create: function(ecModel, api) {
      var mapService3DList = [];
      ecModel.eachComponent(serviceComponentType, function(mapService3DModel) {
        var viewGL = mapService3DModel.__viewGL;
        if (!viewGL) {
          viewGL = mapService3DModel.__viewGL = new ViewGL_default();
          viewGL.setRootNode(new graphicGL_default.Node());
        }
        var mapService3DCoordSys = new ServiceCtor();
        mapService3DCoordSys.viewGL = mapService3DModel.__viewGL;
        mapService3DCoordSys.resize = resizeMapService3D;
        mapService3DCoordSys.resize(mapService3DModel, api);
        mapService3DList.push(mapService3DCoordSys);
        mapService3DModel.coordinateSystem = mapService3DCoordSys;
        mapService3DCoordSys.model = mapService3DModel;
        mapService3DCoordSys.update = updateService3D;
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.get("coordinateSystem") === serviceComponentType) {
          var mapService3DModel = seriesModel.getReferringComponents(serviceComponentType).models[0];
          if (!mapService3DModel) {
            mapService3DModel = ecModel.getComponent(serviceComponentType);
          }
          if (!mapService3DModel) {
            throw new Error(serviceComponentType + ' "' + retrieve_default.firstNotNull(seriesModel.get(serviceComponentType + "Index"), seriesModel.get(serviceComponentType + "Id"), 0) + '" not found');
          }
          seriesModel.coordinateSystem = mapService3DModel.coordinateSystem;
        }
      });
      afterCreate && afterCreate(mapService3DList, ecModel, api);
      return mapService3DList;
    }
  };
}

// node_modules/echarts-gl/lib/coord/mapbox3DCreator.js
var mapbox3DCreator = createMapService3DCreator_default("mapbox3D", Mapbox3D_default, function(mapbox3DList) {
  mapbox3DList.forEach(function(mapbox3D) {
    mapbox3D.setCameraOption(mapbox3D.model.getMapboxCameraOption());
  });
});
var mapbox3DCreator_default = mapbox3DCreator;

// node_modules/echarts-gl/lib/component/mapbox3D/install.js
function install4(registers) {
  registers.registerComponentModel(Mapbox3DModel_default);
  registers.registerComponentView(Mapbox3DView_default);
  registers.registerCoordinateSystem("mapbox3D", mapbox3DCreator_default);
  registers.registerAction({
    type: "mapbox3DChangeCamera",
    event: "mapbox3dcamerachanged",
    update: "mapbox3D:updateCamera"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "mapbox3D",
      query: payload
    }, function(componentModel) {
      componentModel.setMapboxCameraOption(payload);
    });
  });
}

// node_modules/echarts-gl/lib/component/maptalks3D/Maptalks3DModel.js
var MAPTALKS_CAMERA_OPTION = ["zoom", "center", "pitch", "bearing"];
var Maptalks3DModel = Component_default.extend({
  type: "maptalks3D",
  layoutMode: "box",
  coordinateSystem: null,
  defaultOption: {
    zlevel: -10,
    urlTemplate: "http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png",
    attribution: '&copy; <a href="http://osm.org">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/">CARTO</a>',
    center: [0, 0],
    zoom: 0,
    pitch: 0,
    bearing: 0,
    light: {
      main: {
        alpha: 20,
        beta: 30
      }
    },
    altitudeScale: 1,
    // Default depend on altitudeScale
    boxHeight: "auto"
  },
  getMaptalksCameraOption: function() {
    var self = this;
    return MAPTALKS_CAMERA_OPTION.reduce(function(obj, key) {
      obj[key] = self.get(key);
      return obj;
    }, {});
  },
  setMaptalksCameraOption: function(option) {
    if (option != null) {
      MAPTALKS_CAMERA_OPTION.forEach(function(key) {
        if (option[key] != null) {
          this.option[key] = option[key];
        }
      }, this);
    }
  },
  /**
   * Get maptalks instance
   */
  getMaptalks: function() {
    return this._maptalks;
  },
  setMaptalks: function(maptalks2) {
    this._maptalks = maptalks2;
  }
});
util_exports.merge(Maptalks3DModel.prototype, componentPostEffectMixin_default);
util_exports.merge(Maptalks3DModel.prototype, componentLightMixin_default);
var Maptalks3DModel_default = Maptalks3DModel;

// node_modules/echarts-gl/lib/component/maptalks3D/Maptalks3DLayer.js
function Maptalks3DLayer(id, zr, defaultCenter, defaultZoom) {
  this.id = id;
  this.zr = zr;
  this.dom = document.createElement("div");
  this.dom.style.cssText = "position:absolute;left:0;right:0;top:0;bottom:0;";
  if (!maptalks) {
    throw new Error("Maptalks library must be included. See https://maptalks.org");
  }
  this._maptalks = new maptalks.Map(this.dom, {
    center: defaultCenter,
    zoom: defaultZoom,
    doubleClickZoom: false,
    fog: false
    // fogColor: [0, 0, 0]
  });
  this._initEvents();
}
Maptalks3DLayer.prototype.setUnpainted = function() {
};
Maptalks3DLayer.prototype.resize = function() {
  this._maptalks.checkSize();
};
Maptalks3DLayer.prototype.getMaptalks = function() {
  return this._maptalks;
};
Maptalks3DLayer.prototype.clear = function() {
};
Maptalks3DLayer.prototype.refresh = function() {
  this._maptalks.checkSize();
};
var EVENTS2 = ["mousedown", "mouseup", "click", "dblclick", "mousemove", "mousewheel", "DOMMouseScroll", "touchstart", "touchend", "touchmove", "touchcancel"];
Maptalks3DLayer.prototype._initEvents = function() {
  var maptalksRoot = this.dom;
  this._handlers = this._handlers || {
    contextmenu: function(e2) {
      e2.preventDefault();
      return false;
    }
  };
  EVENTS2.forEach(function(eName) {
    this._handlers[eName] = function(e2) {
      var obj = {};
      for (var name in e2) {
        obj[name] = e2[name];
      }
      obj.bubbles = false;
      var newE = new e2.constructor(e2.type, obj);
      if (eName === "mousewheel" || eName === "DOMMouseScroll") {
        maptalksRoot.dispatchEvent(newE);
      } else {
        maptalksRoot.firstElementChild.dispatchEvent(newE);
      }
    };
    this.zr.dom.addEventListener(eName, this._handlers[eName]);
  }, this);
  this.zr.dom.addEventListener("contextmenu", this._handlers.contextmenu);
};
Maptalks3DLayer.prototype.dispose = function() {
  EVENTS2.forEach(function(eName) {
    this.zr.dom.removeEventListener(eName, this._handlers[eName]);
  }, this);
  this._maptalks.remove();
};
var Maptalks3DLayer_default = Maptalks3DLayer;

// node_modules/echarts-gl/lib/component/maptalks3D/Maptalks3DView.js
graphicGL_default.Shader.import(displayShadow_glsl_default);
var Maptalks3DView_default = Component_default2.extend({
  type: "maptalks3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this._groundMesh = new graphicGL_default.Mesh({
      geometry: new graphicGL_default.PlaneGeometry(),
      material: new graphicGL_default.Material({
        shader: new graphicGL_default.Shader({
          vertex: graphicGL_default.Shader.source("ecgl.displayShadow.vertex"),
          fragment: graphicGL_default.Shader.source("ecgl.displayShadow.fragment")
        }),
        depthMask: false
      }),
      // Render first
      renderOrder: -100,
      culling: false,
      castShadow: false,
      $ignorePicking: true,
      renderNormal: true
    });
  },
  _initMaptalksLayer: function(mapbox3DModel, api) {
    var zr = api.getZr();
    this._zrLayer = new Maptalks3DLayer_default("maptalks3D", zr, mapbox3DModel.get("center"), mapbox3DModel.get("zoom"));
    zr.painter.insertLayer(-1e3, this._zrLayer);
    this._lightRoot = new graphicGL_default.Node();
    this._sceneHelper = new SceneHelper_default(this._lightRoot);
    this._sceneHelper.initLight(this._lightRoot);
    var maptalks2 = this._zrLayer.getMaptalks();
    var dispatchInteractAction = this._dispatchInteractAction.bind(this, api, maptalks2);
    ["zoomend", "zooming", "zoomstart", "dragrotating", "pitch", "pitchend", "movestart", "moving", "moveend", "resize", "touchstart", "touchmove", "touchend", "animating"].forEach(function(eName) {
      maptalks2.on(eName, dispatchInteractAction);
    });
  },
  render: function(maptalks3DModel, ecModel, api) {
    if (!this._zrLayer) {
      this._initMaptalksLayer(maptalks3DModel, api);
    }
    var mtks = this._zrLayer.getMaptalks();
    var urlTemplate = maptalks3DModel.get("urlTemplate");
    var baseLayer = mtks.getBaseLayer();
    if (urlTemplate !== this._oldUrlTemplate) {
      if (!baseLayer) {
        baseLayer = new maptalks.TileLayer("maptalks-echarts-gl-baselayer", {
          urlTemplate,
          // used sequentially to help with browser parallel requests per domain limitation
          subdomains: ["a", "b", "c"],
          attribution: maptalks3DModel.get("attribution")
        });
        mtks.setBaseLayer(baseLayer);
      } else {
        baseLayer.setOptions({
          urlTemplate,
          attribution: maptalks3DModel.get("attribution")
        });
      }
    }
    this._oldUrlTemplate = urlTemplate;
    mtks.setCenter(maptalks3DModel.get("center"));
    mtks.setZoom(maptalks3DModel.get("zoom"), {
      animation: false
    });
    mtks.setPitch(maptalks3DModel.get("pitch"));
    mtks.setBearing(maptalks3DModel.get("bearing"));
    maptalks3DModel.setMaptalks(mtks);
    var coordSys = maptalks3DModel.coordinateSystem;
    coordSys.viewGL.scene.add(this._lightRoot);
    coordSys.viewGL.add(this._groundMesh);
    this._updateGroundMesh();
    this._sceneHelper.setScene(coordSys.viewGL.scene);
    this._sceneHelper.updateLight(maptalks3DModel);
    coordSys.viewGL.setPostEffect(maptalks3DModel.getModel("postEffect"), api);
    coordSys.viewGL.setTemporalSuperSampling(maptalks3DModel.getModel("temporalSuperSampling"));
    this._maptalks3DModel = maptalks3DModel;
  },
  afterRender: function(maptalks3DModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    this._sceneHelper.updateAmbientCubemap(renderer, maptalks3DModel, api);
    this._sceneHelper.updateSkybox(renderer, maptalks3DModel, api);
    maptalks3DModel.coordinateSystem.viewGL.scene.traverse(function(mesh) {
      if (mesh.material) {
        mesh.material.define("fragment", "NORMAL_UP_AXIS", 2);
        mesh.material.define("fragment", "NORMAL_FRONT_AXIS", 1);
      }
    });
  },
  updateCamera: function(maptalks3DModel, ecModel, api, payload) {
    maptalks3DModel.coordinateSystem.setCameraOption(payload);
    this._updateGroundMesh();
    api.getZr().refresh();
  },
  _dispatchInteractAction: function(api, maptalks2, maptalks3DModel) {
    api.dispatchAction({
      type: "maptalks3DChangeCamera",
      pitch: maptalks2.getPitch(),
      zoom: getMapboxZoom(maptalks2.getResolution()) + 1,
      center: maptalks2.getCenter().toArray(),
      bearing: maptalks2.getBearing(),
      maptalks3DId: this._maptalks3DModel && this._maptalks3DModel.id
    });
  },
  _updateGroundMesh: function() {
    if (this._maptalks3DModel) {
      var coordSys = this._maptalks3DModel.coordinateSystem;
      var pt = coordSys.dataToPoint(coordSys.center);
      this._groundMesh.position.set(pt[0], pt[1], -1e-3);
      var plane = new graphicGL_default.Plane(new graphicGL_default.Vector3(0, 0, 1), 0);
      var ray1 = coordSys.viewGL.camera.castRay(new graphicGL_default.Vector2(-1, -1));
      var ray2 = coordSys.viewGL.camera.castRay(new graphicGL_default.Vector2(1, 1));
      var pos0 = ray1.intersectPlane(plane);
      var pos1 = ray2.intersectPlane(plane);
      var scale = pos0.dist(pos1) / coordSys.viewGL.rootNode.scale.x;
      this._groundMesh.scale.set(scale, scale, 1);
    }
  },
  dispose: function(ecModel, api) {
    if (this._zrLayer) {
      this._zrLayer.dispose();
    }
    api.getZr().painter.delLayer(-1e3);
  }
});
var MAX_RES = 2 * 6378137 * Math.PI / (256 * Math.pow(2, 20));
function getMapboxZoom(res) {
  return 19 - Math.log(res / MAX_RES) / Math.LN2;
}

// node_modules/echarts-gl/lib/coord/maptalks3D/Maptalks3D.js
function Maptalks3D() {
  MapService3D_default.apply(this, arguments);
  this.maxPitch = 85;
  this.zoomOffset = 1;
}
Maptalks3D.prototype = new MapService3D_default();
Maptalks3D.prototype.constructor = Maptalks3D;
Maptalks3D.prototype.type = "maptalks3D";
var Maptalks3D_default = Maptalks3D;

// node_modules/echarts-gl/lib/coord/maptalks3DCreator.js
var maptalks3DCreator = createMapService3DCreator_default("maptalks3D", Maptalks3D_default, function(maptalks3DList) {
  maptalks3DList.forEach(function(maptalks3D) {
    maptalks3D.setCameraOption(maptalks3D.model.getMaptalksCameraOption());
  });
});
var maptalks3DCreator_default = maptalks3DCreator;

// node_modules/echarts-gl/lib/component/maptalks3D/install.js
function install5(registers) {
  registers.registerComponentModel(Maptalks3DModel_default);
  registers.registerComponentView(Maptalks3DView_default);
  registers.registerCoordinateSystem("maptalks3D", maptalks3DCreator_default);
  registers.registerAction({
    type: "maptalks3DChangeCamera",
    event: "maptalks3dcamerachanged",
    update: "maptalks3D:updateCamera"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "maptalks3D",
      query: payload
    }, function(componentModel) {
      componentModel.setMaptalksCameraOption(payload);
    });
  });
}
export {
  install as Geo3DComponent,
  install3 as GlobeComponent,
  install2 as Grid3DComponent,
  install4 as Mapbox3DComponent,
  install5 as Maptalks3DComponent
};
//# sourceMappingURL=echarts-gl_components.js.map
