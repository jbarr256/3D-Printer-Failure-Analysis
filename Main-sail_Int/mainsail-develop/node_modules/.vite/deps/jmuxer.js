import {
  __commonJS
} from "./chunk-ROME4SDB.js";

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/jmuxer/dist/jmuxer.min.js
var require_jmuxer_min = __commonJS({
  "node_modules/jmuxer/dist/jmuxer.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t(require_stream()) : "function" == typeof define && define.amd ? define(["stream"], t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).JMuxer = t(e.stream);
    }(exports, function(e) {
      "use strict";
      function t(e2) {
        return t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, t(e2);
      }
      function n(e2, t2) {
        if (!(e2 instanceof t2))
          throw new TypeError("Cannot call a class as a function");
      }
      function r(e2, t2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var r2 = t2[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);
        }
      }
      function i(e2, t2, n2) {
        return t2 && r(e2.prototype, t2), n2 && r(e2, n2), e2;
      }
      function s(e2, t2, n2) {
        return t2 in e2 ? Object.defineProperty(e2, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e2[t2] = n2, e2;
      }
      function a(e2, t2) {
        if ("function" != typeof t2 && null !== t2)
          throw new TypeError("Super expression must either be null or a function");
        e2.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e2, writable: true, configurable: true } }), t2 && u(e2, t2);
      }
      function o(e2) {
        return o = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {
          return e3.__proto__ || Object.getPrototypeOf(e3);
        }, o(e2);
      }
      function u(e2, t2) {
        return u = Object.setPrototypeOf || function(e3, t3) {
          return e3.__proto__ = t3, e3;
        }, u(e2, t2);
      }
      function c(e2) {
        if (void 0 === e2)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e2;
      }
      function f(e2, t2) {
        if (t2 && ("object" == typeof t2 || "function" == typeof t2))
          return t2;
        if (void 0 !== t2)
          throw new TypeError("Derived constructors may only return object or undefined");
        return c(e2);
      }
      function l(e2) {
        var t2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (e3) {
            return false;
          }
        }();
        return function() {
          var n2, r2 = o(e2);
          if (t2) {
            var i2 = o(this).constructor;
            n2 = Reflect.construct(r2, arguments, i2);
          } else
            n2 = r2.apply(this, arguments);
          return f(this, n2);
        };
      }
      function h(e2, t2) {
        return function(e3) {
          if (Array.isArray(e3))
            return e3;
        }(e2) || function(e3, t3) {
          var n2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (null == n2)
            return;
          var r2, i2, s2 = [], a2 = true, o2 = false;
          try {
            for (n2 = n2.call(e3); !(a2 = (r2 = n2.next()).done) && (s2.push(r2.value), !t3 || s2.length !== t3); a2 = true)
              ;
          } catch (e4) {
            o2 = true, i2 = e4;
          } finally {
            try {
              a2 || null == n2.return || n2.return();
            } finally {
              if (o2)
                throw i2;
            }
          }
          return s2;
        }(e2, t2) || d(e2, t2) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function d(e2, t2) {
        if (e2) {
          if ("string" == typeof e2)
            return y(e2, t2);
          var n2 = Object.prototype.toString.call(e2).slice(8, -1);
          return "Object" === n2 && e2.constructor && (n2 = e2.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e2) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? y(e2, t2) : void 0;
        }
      }
      function y(e2, t2) {
        (null == t2 || t2 > e2.length) && (t2 = e2.length);
        for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
          r2[n2] = e2[n2];
        return r2;
      }
      function p(e2, t2) {
        var n2 = "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
        if (!n2) {
          if (Array.isArray(e2) || (n2 = d(e2)) || t2 && e2 && "number" == typeof e2.length) {
            n2 && (e2 = n2);
            var r2 = 0, i2 = function() {
            };
            return { s: i2, n: function() {
              return r2 >= e2.length ? { done: true } : { done: false, value: e2[r2++] };
            }, e: function(e3) {
              throw e3;
            }, f: i2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var s2, a2 = true, o2 = false;
        return { s: function() {
          n2 = n2.call(e2);
        }, n: function() {
          var e3 = n2.next();
          return a2 = e3.done, e3;
        }, e: function(e3) {
          o2 = true, s2 = e3;
        }, f: function() {
          try {
            a2 || null == n2.return || n2.return();
          } finally {
            if (o2)
              throw s2;
          }
        } };
      }
      var v, m;
      function k(e2) {
        if (v) {
          for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
            n2[r2 - 1] = arguments[r2];
          v.apply(void 0, [e2].concat(n2));
        }
      }
      function g(e2) {
        if (m) {
          for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
            n2[r2 - 1] = arguments[r2];
          m.apply(void 0, [e2].concat(n2));
        }
      }
      var b = function() {
        function e2(t2) {
          n(this, e2), this.payload = t2, this.nri = (96 & this.payload[0]) >> 5, this.ntype = 31 & this.payload[0], this.isvcl = 1 == this.ntype || 5 == this.ntype, this.stype = "", this.isfmb = false;
        }
        return i(e2, [{ key: "toString", value: function() {
          return "".concat(e2.type(this), ": NRI: ").concat(this.getNri());
        } }, { key: "getNri", value: function() {
          return this.nri;
        } }, { key: "type", value: function() {
          return this.ntype;
        } }, { key: "isKeyframe", value: function() {
          return this.ntype === e2.IDR;
        } }, { key: "getPayload", value: function() {
          return this.payload;
        } }, { key: "getPayloadSize", value: function() {
          return this.payload.byteLength;
        } }, { key: "getSize", value: function() {
          return 4 + this.getPayloadSize();
        } }, { key: "getData", value: function() {
          var e3 = new Uint8Array(this.getSize());
          return new DataView(e3.buffer).setUint32(0, this.getSize() - 4), e3.set(this.getPayload(), 4), e3;
        } }], [{ key: "NDR", get: function() {
          return 1;
        } }, { key: "IDR", get: function() {
          return 5;
        } }, { key: "SEI", get: function() {
          return 6;
        } }, { key: "SPS", get: function() {
          return 7;
        } }, { key: "PPS", get: function() {
          return 8;
        } }, { key: "AUD", get: function() {
          return 9;
        } }, { key: "TYPES", get: function() {
          var t2;
          return s(t2 = {}, e2.IDR, "IDR"), s(t2, e2.SEI, "SEI"), s(t2, e2.SPS, "SPS"), s(t2, e2.PPS, "PPS"), s(t2, e2.NDR, "NDR"), s(t2, e2.AUD, "AUD"), t2;
        } }, { key: "type", value: function(t2) {
          return t2.ntype in e2.TYPES ? e2.TYPES[t2.ntype] : "UNKNOWN";
        } }]), e2;
      }();
      function S(e2, t2) {
        var n2 = new Uint8Array((0 | e2.byteLength) + (0 | t2.byteLength));
        return n2.set(e2, 0), n2.set(t2, 0 | e2.byteLength), n2;
      }
      var w = function() {
        function e2(t2) {
          n(this, e2), this.data = t2, this.index = 0, this.bitLength = 8 * t2.byteLength;
        }
        return i(e2, [{ key: "setData", value: function(e3) {
          this.data = e3, this.index = 0, this.bitLength = 8 * e3.byteLength;
        } }, { key: "bitsAvailable", get: function() {
          return this.bitLength - this.index;
        } }, { key: "skipBits", value: function(e3) {
          if (this.bitsAvailable < e3)
            return false;
          this.index += e3;
        } }, { key: "readBits", value: function(e3) {
          var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n2 = this.getBits(e3, this.index, t2);
          return n2;
        } }, { key: "getBits", value: function(e3, t2) {
          var n2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
          if (this.bitsAvailable < e3)
            return 0;
          var r2 = t2 % 8, i2 = this.data[t2 / 8 | 0] & 255 >>> r2, s2 = 8 - r2;
          if (s2 >= e3)
            return n2 && (this.index += e3), i2 >> s2 - e3;
          n2 && (this.index += s2);
          var a2 = e3 - s2;
          return i2 << a2 | this.getBits(a2, t2 + s2, n2);
        } }, { key: "skipLZ", value: function() {
          var e3;
          for (e3 = 0; e3 < this.bitLength - this.index; ++e3)
            if (0 !== this.getBits(1, this.index + e3, false))
              return this.index += e3, e3;
          return e3;
        } }, { key: "skipUEG", value: function() {
          this.skipBits(1 + this.skipLZ());
        } }, { key: "skipEG", value: function() {
          this.skipBits(1 + this.skipLZ());
        } }, { key: "readUEG", value: function() {
          var e3 = this.skipLZ();
          return this.readBits(e3 + 1) - 1;
        } }, { key: "readEG", value: function() {
          var e3 = this.readUEG();
          return 1 & e3 ? 1 + e3 >>> 1 : -1 * (e3 >>> 1);
        } }, { key: "readBoolean", value: function() {
          return 1 === this.readBits(1);
        } }, { key: "readUByte", value: function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
          return this.readBits(8 * e3);
        } }, { key: "readUShort", value: function() {
          return this.readBits(16);
        } }, { key: "readUInt", value: function() {
          return this.readBits(32);
        } }]), e2;
      }(), x = function() {
        function e2(t2) {
          n(this, e2), this.remuxer = t2, this.track = t2.mp4track;
        }
        return i(e2, [{ key: "parseSPS", value: function(t2) {
          var n2 = e2.readSPS(new Uint8Array(t2));
          this.track.fps = n2.fps, this.track.width = n2.width, this.track.height = n2.height, this.track.sps = [new Uint8Array(t2)], this.track.codec = "avc1.";
          for (var r2 = new DataView(t2.buffer, t2.byteOffset + 1, 4), i2 = 0; i2 < 3; ++i2) {
            var s2 = r2.getUint8(i2).toString(16);
            s2.length < 2 && (s2 = "0" + s2), this.track.codec += s2;
          }
        } }, { key: "parsePPS", value: function(e3) {
          this.track.pps = [new Uint8Array(e3)];
        } }, { key: "parseNAL", value: function(e3) {
          if (!e3)
            return false;
          var t2 = false;
          switch (e3.type()) {
            case b.IDR:
            case b.NDR:
              t2 = true;
              break;
            case b.PPS:
              this.track.pps || (this.parsePPS(e3.getPayload()), !this.remuxer.readyToDecode && this.track.pps && this.track.sps && (this.remuxer.readyToDecode = true)), t2 = true;
              break;
            case b.SPS:
              this.track.sps || (this.parseSPS(e3.getPayload()), !this.remuxer.readyToDecode && this.track.pps && this.track.sps && (this.remuxer.readyToDecode = true)), t2 = true;
              break;
            case b.AUD:
              k("AUD - ignoing");
              break;
            case b.SEI:
              k("SEI - ignoing");
          }
          return t2;
        } }], [{ key: "extractNALu", value: function(e3) {
          for (var t2, n2, r2 = 0, i2 = e3.byteLength, s2 = 0, a2 = [], o2 = 0; r2 < i2; )
            switch (t2 = e3[r2++], s2) {
              case 0:
                0 === t2 && (s2 = 1);
                break;
              case 1:
                s2 = 0 === t2 ? 2 : 0;
                break;
              case 2:
              case 3:
                0 === t2 ? s2 = 3 : 1 === t2 && r2 < i2 ? (o2 != r2 - s2 - 1 && a2.push(e3.subarray(o2, r2 - s2 - 1)), o2 = r2, s2 = 0) : s2 = 0;
            }
          return o2 < i2 && (n2 = e3.subarray(o2, i2)), [a2, n2];
        } }, { key: "skipScalingList", value: function(e3, t2) {
          for (var n2 = 8, r2 = 8, i2 = 0; i2 < t2; i2++)
            0 !== r2 && (r2 = (n2 + e3.readEG() + 256) % 256), n2 = 0 === r2 ? n2 : r2;
        } }, { key: "readSPS", value: function(t2) {
          var n2, r2, i2, s2, a2, o2, u2 = new w(t2), c2 = 0, f2 = 0, l2 = 0, h2 = 0, d2 = 1, y2 = 0;
          u2.readUByte();
          for (var p2 = [], v2 = t2.byteLength, m2 = 1; m2 < v2; m2++)
            m2 + 2 < v2 && 3 === u2.readBits(24, false) ? (p2.push(u2.readBits(8)), p2.push(u2.readBits(8)), m2 += 2, u2.readBits(8)) : p2.push(u2.readBits(8));
          if (u2.setData(new Uint8Array(p2)), n2 = u2.readUByte(), u2.readBits(5), u2.skipBits(3), u2.readUByte(), u2.skipUEG(), 100 === n2 || 110 === n2 || 122 === n2 || 244 === n2 || 44 === n2 || 83 === n2 || 86 === n2 || 118 === n2 || 128 === n2) {
            var k2 = u2.readUEG();
            if (3 === k2 && u2.skipBits(1), u2.skipUEG(), u2.skipUEG(), u2.skipBits(1), u2.readBoolean()) {
              o2 = 3 !== k2 ? 8 : 12;
              for (var g2 = 0; g2 < o2; ++g2)
                u2.readBoolean() && (g2 < 6 ? e2.skipScalingList(u2, 16) : e2.skipScalingList(u2, 64));
            }
          }
          u2.skipUEG();
          var b2 = u2.readUEG();
          if (0 === b2)
            u2.readUEG();
          else if (1 === b2) {
            u2.skipBits(1), u2.skipEG(), u2.skipEG(), r2 = u2.readUEG();
            for (var S2 = 0; S2 < r2; ++S2)
              u2.skipEG();
          }
          if (u2.skipUEG(), u2.skipBits(1), i2 = u2.readUEG(), s2 = u2.readUEG(), 0 === (a2 = u2.readBits(1)) && u2.skipBits(1), u2.skipBits(1), u2.readBoolean() && (c2 = u2.readUEG(), f2 = u2.readUEG(), l2 = u2.readUEG(), h2 = u2.readUEG()), u2.readBoolean()) {
            if (u2.readBoolean()) {
              var x2;
              switch (u2.readUByte()) {
                case 1:
                  x2 = [1, 1];
                  break;
                case 2:
                  x2 = [12, 11];
                  break;
                case 3:
                  x2 = [10, 11];
                  break;
                case 4:
                  x2 = [16, 11];
                  break;
                case 5:
                  x2 = [40, 33];
                  break;
                case 6:
                  x2 = [24, 11];
                  break;
                case 7:
                  x2 = [20, 11];
                  break;
                case 8:
                  x2 = [32, 11];
                  break;
                case 9:
                  x2 = [80, 33];
                  break;
                case 10:
                  x2 = [18, 11];
                  break;
                case 11:
                  x2 = [15, 11];
                  break;
                case 12:
                  x2 = [64, 33];
                  break;
                case 13:
                  x2 = [160, 99];
                  break;
                case 14:
                  x2 = [4, 3];
                  break;
                case 15:
                  x2 = [3, 2];
                  break;
                case 16:
                  x2 = [2, 1];
                  break;
                case 255:
                  x2 = [u2.readUByte() << 8 | u2.readUByte(), u2.readUByte() << 8 | u2.readUByte()];
              }
              x2 && x2[0] > 0 && x2[1] > 0 && (d2 = x2[0] / x2[1]);
            }
            if (u2.readBoolean() && u2.skipBits(1), u2.readBoolean() && (u2.skipBits(4), u2.readBoolean() && u2.skipBits(24)), u2.readBoolean() && (u2.skipUEG(), u2.skipUEG()), u2.readBoolean()) {
              var A2 = u2.readUInt(), U2 = u2.readUInt();
              u2.readBoolean() && (y2 = U2 / (2 * A2));
            }
          }
          return { fps: y2 > 0 ? y2 : void 0, width: Math.ceil((16 * (i2 + 1) - 2 * c2 - 2 * f2) * d2), height: (2 - a2) * (s2 + 1) * 16 - (a2 ? 2 : 4) * (l2 + h2) };
        } }, { key: "parseHeader", value: function(e3) {
          var t2 = new w(e3.getPayload());
          t2.readUByte(), e3.isfmb = 0 === t2.readUEG(), e3.stype = t2.readUEG();
        } }]), e2;
      }(), A = function() {
        function e2(t2) {
          n(this, e2), this.remuxer = t2, this.track = t2.mp4track;
        }
        return i(e2, [{ key: "extractAAC", value: function(t2) {
          var n2, r2, i2 = 0, s2 = t2.byteLength, a2 = [];
          if (!e2.isAACPattern(t2))
            return g("Invalid ADTS audio format"), a2;
          for (n2 = e2.getHeaderLength(t2), this.aacHeader || (this.aacHeader = t2.subarray(0, n2)); i2 < s2; )
            r2 = e2.getFrameLength(t2), a2.push(t2.subarray(n2, r2)), t2 = t2.slice(r2), i2 += r2;
          return a2;
        } }, { key: "setAACConfig", value: function() {
          var e3, t2, n2, r2 = new Uint8Array(2), i2 = this.aacHeader;
          i2 && (e3 = 1 + ((192 & i2[2]) >>> 6), t2 = (60 & i2[2]) >>> 2, n2 = (1 & i2[2]) << 2, n2 |= (192 & i2[3]) >>> 6, r2[0] = e3 << 3, r2[0] |= (14 & t2) >> 1, r2[1] |= (1 & t2) << 7, r2[1] |= n2 << 3, this.track.codec = "mp4a.40." + e3, this.track.channelCount = n2, this.track.config = r2, this.remuxer.readyToDecode = true);
        } }], [{ key: "samplingRateMap", get: function() {
          return [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
        } }, { key: "getHeaderLength", value: function(e3) {
          return 1 & e3[1] ? 7 : 9;
        } }, { key: "getFrameLength", value: function(e3) {
          return (3 & e3[3]) << 11 | e3[4] << 3 | (224 & e3[5]) >>> 5;
        } }, { key: "isAACPattern", value: function(e3) {
          return 255 === e3[0] && 240 == (240 & e3[1]) && 0 == (6 & e3[1]);
        } }]), e2;
      }(), U = function() {
        function e2(t2) {
          n(this, e2), this.listener = {}, this.type = "" | t2;
        }
        return i(e2, [{ key: "on", value: function(e3, t2) {
          return this.listener[e3] || (this.listener[e3] = []), this.listener[e3].push(t2), true;
        } }, { key: "off", value: function(e3, t2) {
          if (this.listener[e3]) {
            var n2 = this.listener[e3].indexOf(t2);
            return n2 > -1 && this.listener[e3].splice(n2, 1), true;
          }
          return false;
        } }, { key: "offAll", value: function() {
          this.listener = {};
        } }, { key: "dispatch", value: function(e3, t2) {
          return !!this.listener[e3] && (this.listener[e3].map(function(e4) {
            e4.apply(null, [t2]);
          }), true);
        } }]), e2;
      }(), B = function() {
        function e2() {
          n(this, e2);
        }
        return i(e2, null, [{ key: "init", value: function() {
          var t2;
          for (t2 in e2.types = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], mvex: [], mvhd: [], sdtp: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [], smhd: [] }, e2.types)
            e2.types.hasOwnProperty(t2) && (e2.types[t2] = [t2.charCodeAt(0), t2.charCodeAt(1), t2.charCodeAt(2), t2.charCodeAt(3)]);
          var n2 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), r2 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
          e2.HDLR_TYPES = { video: n2, audio: r2 };
          var i2 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), s2 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
          e2.STTS = e2.STSC = e2.STCO = s2, e2.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e2.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), e2.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e2.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
          var a2 = new Uint8Array([105, 115, 111, 109]), o2 = new Uint8Array([97, 118, 99, 49]), u2 = new Uint8Array([0, 0, 0, 1]);
          e2.FTYP = e2.box(e2.types.ftyp, a2, u2, a2, o2), e2.DINF = e2.box(e2.types.dinf, e2.box(e2.types.dref, i2));
        } }, { key: "box", value: function(e3) {
          for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
            n2[r2 - 1] = arguments[r2];
          for (var i2, s2 = 8, a2 = n2.length, o2 = a2; a2--; )
            s2 += n2[a2].byteLength;
          for ((i2 = new Uint8Array(s2))[0] = s2 >> 24 & 255, i2[1] = s2 >> 16 & 255, i2[2] = s2 >> 8 & 255, i2[3] = 255 & s2, i2.set(e3, 4), a2 = 0, s2 = 8; a2 < o2; ++a2)
            i2.set(n2[a2], s2), s2 += n2[a2].byteLength;
          return i2;
        } }, { key: "hdlr", value: function(t2) {
          return e2.box(e2.types.hdlr, e2.HDLR_TYPES[t2]);
        } }, { key: "mdat", value: function(t2) {
          return e2.box(e2.types.mdat, t2);
        } }, { key: "mdhd", value: function(t2, n2) {
          return e2.box(e2.types.mdhd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, t2 >> 24 & 255, t2 >> 16 & 255, t2 >> 8 & 255, 255 & t2, n2 >> 24, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2, 85, 196, 0, 0]));
        } }, { key: "mdia", value: function(t2) {
          return e2.box(e2.types.mdia, e2.mdhd(t2.timescale, t2.duration), e2.hdlr(t2.type), e2.minf(t2));
        } }, { key: "mfhd", value: function(t2) {
          return e2.box(e2.types.mfhd, new Uint8Array([0, 0, 0, 0, t2 >> 24, t2 >> 16 & 255, t2 >> 8 & 255, 255 & t2]));
        } }, { key: "minf", value: function(t2) {
          return "audio" === t2.type ? e2.box(e2.types.minf, e2.box(e2.types.smhd, e2.SMHD), e2.DINF, e2.stbl(t2)) : e2.box(e2.types.minf, e2.box(e2.types.vmhd, e2.VMHD), e2.DINF, e2.stbl(t2));
        } }, { key: "moof", value: function(t2, n2, r2) {
          return e2.box(e2.types.moof, e2.mfhd(t2), e2.traf(r2, n2));
        } }, { key: "moov", value: function(t2, n2, r2) {
          for (var i2 = t2.length, s2 = []; i2--; )
            s2[i2] = e2.trak(t2[i2]);
          return e2.box.apply(null, [e2.types.moov, e2.mvhd(r2, n2)].concat(s2).concat(e2.mvex(t2)));
        } }, { key: "mvex", value: function(t2) {
          for (var n2 = t2.length, r2 = []; n2--; )
            r2[n2] = e2.trex(t2[n2]);
          return e2.box.apply(null, [e2.types.mvex].concat(r2));
        } }, { key: "mvhd", value: function(t2, n2) {
          var r2 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, t2 >> 24 & 255, t2 >> 16 & 255, t2 >> 8 & 255, 255 & t2, n2 >> 24 & 255, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
          return e2.box(e2.types.mvhd, r2);
        } }, { key: "sdtp", value: function(t2) {
          var n2, r2, i2 = t2.samples || [], s2 = new Uint8Array(4 + i2.length);
          for (r2 = 0; r2 < i2.length; r2++)
            n2 = i2[r2].flags, s2[r2 + 4] = n2.dependsOn << 4 | n2.isDependedOn << 2 | n2.hasRedundancy;
          return e2.box(e2.types.sdtp, s2);
        } }, { key: "stbl", value: function(t2) {
          return e2.box(e2.types.stbl, e2.stsd(t2), e2.box(e2.types.stts, e2.STTS), e2.box(e2.types.stsc, e2.STSC), e2.box(e2.types.stsz, e2.STSZ), e2.box(e2.types.stco, e2.STCO));
        } }, { key: "avc1", value: function(t2) {
          var n2, r2, i2, s2 = [], a2 = [];
          for (n2 = 0; n2 < t2.sps.length; n2++)
            i2 = (r2 = t2.sps[n2]).byteLength, s2.push(i2 >>> 8 & 255), s2.push(255 & i2), s2 = s2.concat(Array.prototype.slice.call(r2));
          for (n2 = 0; n2 < t2.pps.length; n2++)
            i2 = (r2 = t2.pps[n2]).byteLength, a2.push(i2 >>> 8 & 255), a2.push(255 & i2), a2 = a2.concat(Array.prototype.slice.call(r2));
          var o2 = e2.box(e2.types.avcC, new Uint8Array([1, s2[3], s2[4], s2[5], 255, 224 | t2.sps.length].concat(s2).concat([t2.pps.length]).concat(a2))), u2 = t2.width, c2 = t2.height;
          return e2.box(e2.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, u2 >> 8 & 255, 255 & u2, c2 >> 8 & 255, 255 & c2, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 98, 105, 110, 101, 108, 112, 114, 111, 46, 114, 117, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o2, e2.box(e2.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])));
        } }, { key: "esds", value: function(e3) {
          var t2 = e3.config.byteLength, n2 = new Uint8Array(26 + t2 + 3);
          return n2.set([0, 0, 0, 0, 3, 23 + t2, 0, 1, 0, 4, 15 + t2, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, t2]), n2.set(e3.config, 26), n2.set([6, 1, 2], 26 + t2), n2;
        } }, { key: "mp4a", value: function(t2) {
          var n2 = t2.audiosamplerate;
          return e2.box(e2.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t2.channelCount, 0, 16, 0, 0, 0, 0, n2 >> 8 & 255, 255 & n2, 0, 0]), e2.box(e2.types.esds, e2.esds(t2)));
        } }, { key: "stsd", value: function(t2) {
          return "audio" === t2.type ? e2.box(e2.types.stsd, e2.STSD, e2.mp4a(t2)) : e2.box(e2.types.stsd, e2.STSD, e2.avc1(t2));
        } }, { key: "tkhd", value: function(t2) {
          var n2 = t2.id, r2 = t2.duration, i2 = t2.width, s2 = t2.height, a2 = t2.volume;
          return e2.box(e2.types.tkhd, new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, n2 >> 24 & 255, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2, 0, 0, 0, 0, r2 >> 24, r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a2 >> 0 & 255, a2 % 1 * 10 >> 0 & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, i2 >> 8 & 255, 255 & i2, 0, 0, s2 >> 8 & 255, 255 & s2, 0, 0]));
        } }, { key: "traf", value: function(t2, n2) {
          var r2 = e2.sdtp(t2), i2 = t2.id;
          return e2.box(e2.types.traf, e2.box(e2.types.tfhd, new Uint8Array([0, 0, 0, 0, i2 >> 24, i2 >> 16 & 255, i2 >> 8 & 255, 255 & i2])), e2.box(e2.types.tfdt, new Uint8Array([0, 0, 0, 0, n2 >> 24, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2])), e2.trun(t2, r2.length + 16 + 16 + 8 + 16 + 8 + 8), r2);
        } }, { key: "trak", value: function(t2) {
          return t2.duration = t2.duration || 4294967295, e2.box(e2.types.trak, e2.tkhd(t2), e2.mdia(t2));
        } }, { key: "trex", value: function(t2) {
          var n2 = t2.id;
          return e2.box(e2.types.trex, new Uint8Array([0, 0, 0, 0, n2 >> 24, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]));
        } }, { key: "trun", value: function(t2, n2) {
          var r2, i2, s2, a2, o2, u2, c2 = t2.samples || [], f2 = c2.length, l2 = 12 + 16 * f2, h2 = new Uint8Array(l2);
          for (n2 += 8 + l2, h2.set([0, 0, 15, 1, f2 >>> 24 & 255, f2 >>> 16 & 255, f2 >>> 8 & 255, 255 & f2, n2 >>> 24 & 255, n2 >>> 16 & 255, n2 >>> 8 & 255, 255 & n2], 0), r2 = 0; r2 < f2; r2++)
            s2 = (i2 = c2[r2]).duration, a2 = i2.size, o2 = i2.flags, u2 = i2.cts, h2.set([s2 >>> 24 & 255, s2 >>> 16 & 255, s2 >>> 8 & 255, 255 & s2, a2 >>> 24 & 255, a2 >>> 16 & 255, a2 >>> 8 & 255, 255 & a2, o2.isLeading << 2 | o2.dependsOn, o2.isDependedOn << 6 | o2.hasRedundancy << 4 | o2.paddingValue << 1 | o2.isNonSync, 61440 & o2.degradPrio, 15 & o2.degradPrio, u2 >>> 24 & 255, u2 >>> 16 & 255, u2 >>> 8 & 255, 255 & u2], 12 + 16 * r2);
          return e2.box(e2.types.trun, h2);
        } }, { key: "initSegment", value: function(t2, n2, r2) {
          e2.types || e2.init();
          var i2, s2 = e2.moov(t2, n2, r2);
          return (i2 = new Uint8Array(e2.FTYP.byteLength + s2.byteLength)).set(e2.FTYP), i2.set(s2, e2.FTYP.byteLength), i2;
        } }]), e2;
      }(), D = 1, C = function() {
        function e2() {
          n(this, e2);
        }
        return i(e2, [{ key: "flush", value: function() {
          this.mp4track.len = 0, this.mp4track.samples = [];
        } }, { key: "isReady", value: function() {
          return !(!this.readyToDecode || !this.samples.length) || null;
        } }], [{ key: "getTrackID", value: function() {
          return D++;
        } }]), e2;
      }(), E = function(e2) {
        a(r2, e2);
        var t2 = l(r2);
        function r2(e3) {
          var i2;
          return n(this, r2), (i2 = t2.call(this)).readyToDecode = false, i2.nextDts = 0, i2.dts = 0, i2.mp4track = { id: C.getTrackID(), type: "audio", channelCount: 0, len: 0, fragmented: true, timescale: e3, duration: e3, samples: [], config: "", codec: "" }, i2.samples = [], i2.aac = new A(c(i2)), i2;
        }
        return i(r2, [{ key: "resetTrack", value: function() {
          this.readyToDecode = false, this.mp4track.codec = "", this.mp4track.channelCount = "", this.mp4track.config = "", this.mp4track.timescale = this.timescale, this.nextDts = 0, this.dts = 0;
        } }, { key: "remux", value: function(e3) {
          if (e3.length > 0)
            for (var t3 = 0; t3 < e3.length; t3++) {
              var n2 = e3[t3], r3 = n2.units, i2 = r3.byteLength;
              this.samples.push({ units: r3, size: i2, duration: n2.duration }), this.mp4track.len += i2, this.readyToDecode || this.aac.setAACConfig();
            }
        } }, { key: "getPayload", value: function() {
          if (!this.isReady())
            return null;
          var e3, t3, n2 = new Uint8Array(this.mp4track.len), r3 = 0, i2 = this.mp4track.samples;
          for (this.dts = this.nextDts; this.samples.length; ) {
            var s2 = this.samples.shift();
            s2.units, (t3 = s2.duration) <= 0 ? (k("remuxer: invalid sample duration at DTS: ".concat(this.nextDts, " :").concat(t3)), this.mp4track.len -= s2.size) : (this.nextDts += t3, e3 = { size: s2.size, duration: t3, cts: 0, flags: { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: 1 } }, n2.set(s2.units, r3), r3 += s2.size, i2.push(e3));
          }
          return i2.length ? new Uint8Array(n2.buffer, 0, this.mp4track.len) : null;
        } }, { key: "getAacParser", value: function() {
          return this.aac;
        } }]), r2;
      }(C), T = function(e2) {
        a(r2, e2);
        var t2 = l(r2);
        function r2(e3) {
          var i2;
          return n(this, r2), (i2 = t2.call(this)).readyToDecode = false, i2.nextDts = 0, i2.dts = 0, i2.mp4track = { id: C.getTrackID(), type: "video", len: 0, fragmented: true, sps: "", pps: "", fps: 30, width: 0, height: 0, timescale: e3, duration: e3, samples: [] }, i2.samples = [], i2.h264 = new x(c(i2)), i2;
        }
        return i(r2, [{ key: "resetTrack", value: function() {
          this.readyToDecode = false, this.mp4track.sps = "", this.mp4track.pps = "", this.nextDts = 0, this.dts = 0;
        } }, { key: "remux", value: function(e3) {
          var t3, n2 = p(e3);
          try {
            for (n2.s(); !(t3 = n2.n()).done; ) {
              var r3, i2 = t3.value, s2 = [], a2 = 0, o2 = p(i2.units);
              try {
                for (o2.s(); !(r3 = o2.n()).done; ) {
                  var u2 = r3.value;
                  this.h264.parseNAL(u2) && (s2.push(u2), a2 += u2.getSize());
                }
              } catch (e4) {
                o2.e(e4);
              } finally {
                o2.f();
              }
              s2.length > 0 && this.readyToDecode && (this.mp4track.len += a2, this.samples.push({ units: s2, size: a2, keyFrame: i2.keyFrame, duration: i2.duration, compositionTimeOffset: i2.compositionTimeOffset }));
            }
          } catch (e4) {
            n2.e(e4);
          } finally {
            n2.f();
          }
        } }, { key: "getPayload", value: function() {
          if (!this.isReady())
            return null;
          var e3, t3, n2 = new Uint8Array(this.mp4track.len), r3 = 0, i2 = this.mp4track.samples;
          for (this.dts = this.nextDts; this.samples.length; ) {
            var s2 = this.samples.shift(), a2 = s2.units;
            if ((t3 = s2.duration) <= 0)
              k("remuxer: invalid sample duration at DTS: ".concat(this.nextDts, " :").concat(t3)), this.mp4track.len -= s2.size;
            else {
              this.nextDts += t3, e3 = { size: s2.size, duration: t3, cts: s2.compositionTimeOffset || 0, flags: { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, isNonSync: s2.keyFrame ? 0 : 1, dependsOn: s2.keyFrame ? 2 : 1 } };
              var o2, u2 = p(a2);
              try {
                for (u2.s(); !(o2 = u2.n()).done; ) {
                  var c2 = o2.value;
                  n2.set(c2.getData(), r3), r3 += c2.getSize();
                }
              } catch (e4) {
                u2.e(e4);
              } finally {
                u2.f();
              }
              i2.push(e3);
            }
          }
          return i2.length ? new Uint8Array(n2.buffer, 0, this.mp4track.len) : null;
        } }]), r2;
      }(C), P = function(e2) {
        a(r2, e2);
        var t2 = l(r2);
        function r2(e3) {
          var i2;
          return n(this, r2), (i2 = t2.call(this, "remuxer")).initialized = false, i2.trackTypes = [], i2.tracks = {}, i2.seq = 1, i2.env = e3, i2.timescale = 1e3, i2.mediaDuration = 0, i2.aacParser = null, i2;
        }
        return i(r2, [{ key: "addTrack", value: function(e3) {
          if ("video" !== e3 && "both" !== e3 || (this.tracks.video = new T(this.timescale), this.trackTypes.push("video")), "audio" === e3 || "both" === e3) {
            var t3 = new E(this.timescale);
            this.aacParser = t3.getAacParser(), this.tracks.audio = t3, this.trackTypes.push("audio");
          }
        } }, { key: "reset", value: function() {
          var e3, t3 = p(this.trackTypes);
          try {
            for (t3.s(); !(e3 = t3.n()).done; ) {
              var n2 = e3.value;
              this.tracks[n2].resetTrack();
            }
          } catch (e4) {
            t3.e(e4);
          } finally {
            t3.f();
          }
          this.initialized = false;
        } }, { key: "destroy", value: function() {
          this.tracks = {}, this.offAll();
        } }, { key: "flush", value: function() {
          if (this.initialized) {
            var e3, t3 = p(this.trackTypes);
            try {
              for (t3.s(); !(e3 = t3.n()).done; ) {
                var n2 = e3.value, r3 = this.tracks[n2], i2 = r3.getPayload();
                if (i2 && i2.byteLength) {
                  var s2 = { type: n2, payload: S(B.moof(this.seq, r3.dts, r3.mp4track), B.mdat(i2)), dts: r3.dts };
                  "video" === n2 && (s2.fps = r3.mp4track.fps), this.dispatch("buffer", s2);
                  var a2 = (o2 = r3.dts / this.timescale, u2 = void 0, c2 = void 0, f2 = void 0, l2 = void 0, l2 = "", u2 = Math.floor(o2), (c2 = parseInt(u2 / 3600, 10) % 24) > 0 && (l2 += (c2 < 10 ? "0" + c2 : c2) + ":"), l2 += ((f2 = parseInt(u2 / 60, 10) % 60) < 10 ? "0" + f2 : f2) + ":" + ((u2 = u2 < 0 ? 0 : u2 % 60) < 10 ? "0" + u2 : u2));
                  k("put segment (".concat(n2, "): dts: ").concat(r3.dts, " frames: ").concat(r3.mp4track.samples.length, " second: ").concat(a2)), r3.flush(), this.seq++;
                }
              }
            } catch (e4) {
              t3.e(e4);
            } finally {
              t3.f();
            }
          } else
            this.isReady() && (this.dispatch("ready"), this.initSegment(), this.initialized = true, this.flush());
          var o2, u2, c2, f2, l2;
        } }, { key: "initSegment", value: function() {
          var e3, t3 = [], n2 = p(this.trackTypes);
          try {
            for (n2.s(); !(e3 = n2.n()).done; ) {
              var r3 = e3.value, i2 = this.tracks[r3];
              if ("browser" == this.env) {
                var s2 = { type: r3, payload: B.initSegment([i2.mp4track], this.mediaDuration, this.timescale) };
                this.dispatch("buffer", s2);
              } else
                t3.push(i2.mp4track);
            }
          } catch (e4) {
            n2.e(e4);
          } finally {
            n2.f();
          }
          if ("node" == this.env) {
            var a2 = { type: "all", payload: B.initSegment(t3, this.mediaDuration, this.timescale) };
            this.dispatch("buffer", a2);
          }
          k("Initial segment generated.");
        } }, { key: "isReady", value: function() {
          var e3, t3 = p(this.trackTypes);
          try {
            for (t3.s(); !(e3 = t3.n()).done; ) {
              var n2 = e3.value;
              if (!this.tracks[n2].readyToDecode || !this.tracks[n2].samples.length)
                return false;
            }
          } catch (e4) {
            t3.e(e4);
          } finally {
            t3.f();
          }
          return true;
        } }, { key: "remux", value: function(e3) {
          var t3, n2 = p(this.trackTypes);
          try {
            for (n2.s(); !(t3 = n2.n()).done; ) {
              var r3 = t3.value, i2 = e3[r3];
              "audio" === r3 && this.tracks.video && !this.tracks.video.readyToDecode || i2.length > 0 && this.tracks[r3].remux(i2);
            }
          } catch (e4) {
            n2.e(e4);
          } finally {
            n2.f();
          }
          this.flush();
        } }]), r2;
      }(U), L = function(e2) {
        a(r2, e2);
        var t2 = l(r2);
        function r2(e3, i2) {
          var s2;
          return n(this, r2), (s2 = t2.call(this, "buffer")).type = i2, s2.queue = new Uint8Array(), s2.cleaning = false, s2.pendingCleaning = 0, s2.cleanOffset = 30, s2.cleanRanges = [], s2.sourceBuffer = e3, s2.sourceBuffer.addEventListener("updateend", function() {
            s2.pendingCleaning > 0 && (s2.initCleanup(s2.pendingCleaning), s2.pendingCleaning = 0), s2.cleaning = false, s2.cleanRanges.length && s2.doCleanup();
          }), s2.sourceBuffer.addEventListener("error", function() {
            s2.dispatch("error", { type: s2.type, name: "buffer", error: "buffer error" });
          }), s2;
        }
        return i(r2, [{ key: "destroy", value: function() {
          this.queue = null, this.sourceBuffer = null, this.offAll();
        } }, { key: "doCleanup", value: function() {
          if (this.cleanRanges.length) {
            var e3 = this.cleanRanges.shift();
            k("".concat(this.type, " remove range [").concat(e3[0], " - ").concat(e3[1], ")")), this.cleaning = true, this.sourceBuffer.remove(e3[0], e3[1]);
          } else
            this.cleaning = false;
        } }, { key: "initCleanup", value: function(e3) {
          try {
            if (this.sourceBuffer.updating)
              return void (this.pendingCleaning = e3);
            if (this.sourceBuffer.buffered && this.sourceBuffer.buffered.length && !this.cleaning) {
              for (var t3 = 0; t3 < this.sourceBuffer.buffered.length; ++t3) {
                var n2 = this.sourceBuffer.buffered.start(t3), r3 = this.sourceBuffer.buffered.end(t3);
                e3 - n2 > this.cleanOffset && n2 < (r3 = e3 - this.cleanOffset) && this.cleanRanges.push([n2, r3]);
              }
              this.doCleanup();
            }
          } catch (e4) {
            g("Error occured while cleaning ".concat(this.type, " buffer - ").concat(e4.name, ": ").concat(e4.message));
          }
        } }, { key: "doAppend", value: function() {
          if (this.queue.length && this.sourceBuffer && !this.sourceBuffer.updating)
            try {
              this.sourceBuffer.appendBuffer(this.queue), this.queue = new Uint8Array();
            } catch (t3) {
              var e3 = "unexpectedError";
              "QuotaExceededError" === t3.name ? (k("".concat(this.type, " buffer quota full")), e3 = "QuotaExceeded") : (g("Error occured while appending ".concat(this.type, " buffer - ").concat(t3.name, ": ").concat(t3.message)), e3 = "InvalidStateError"), this.dispatch("error", { type: this.type, name: e3, error: "buffer error" });
            }
        } }, { key: "feed", value: function(e3) {
          this.queue = S(this.queue, e3);
        } }]), r2;
      }(U);
      return function(r2) {
        a(o2, r2);
        var s2 = l(o2);
        function o2(e2) {
          var r3;
          n(this, o2), (r3 = s2.call(this, "jmuxer")).isReset = false;
          return r3.options = Object.assign({}, { node: "", mode: "both", flushingTime: 500, maxDelay: 500, clearBuffer: true, fps: 30, readFpsFromTrack: false, debug: false, onReady: function() {
          }, onError: function() {
          }, onMissingVideoFrames: function() {
          }, onMissingAudioFrames: function() {
          } }, e2), r3.env = "object" === ("undefined" == typeof process ? "undefined" : t(process)) && "undefined" == typeof window ? "node" : "browser", r3.options.debug && (v = console.log, m = console.error), r3.options.fps || (r3.options.fps = 30), r3.frameDuration = 1e3 / r3.options.fps | 0, r3.remuxController = new P(r3.env), r3.remuxController.addTrack(r3.options.mode), r3.initData(), r3.remuxController.on("buffer", r3.onBuffer.bind(c(r3))), "browser" == r3.env && (r3.remuxController.on("ready", r3.createBuffer.bind(c(r3))), r3.initBrowser()), r3;
        }
        return i(o2, [{ key: "initData", value: function() {
          this.lastCleaningTime = Date.now(), this.kfPosition = [], this.kfCounter = 0, this.pendingUnits = {}, this.remainingData = new Uint8Array(), this.startInterval();
        } }, { key: "initBrowser", value: function() {
          "string" == typeof this.options.node && "" == this.options.node && g("no video element were found to render, provide a valid video element"), this.node = "string" == typeof this.options.node ? document.getElementById(this.options.node) : this.options.node, this.mseReady = false, this.setupMSE();
        } }, { key: "createStream", value: function() {
          var t2 = this.feed.bind(this), n2 = this.destroy.bind(this);
          return this.stream = new e.Duplex({ writableObjectMode: true, read: function(e2) {
          }, write: function(e2, n3, r3) {
            t2(e2), r3();
          }, final: function(e2) {
            n2(), e2();
          } }), this.stream;
        } }, { key: "setupMSE", value: function() {
          if (window.MediaSource = window.MediaSource || window.WebKitMediaSource, !window.MediaSource)
            throw "Oops! Browser does not support media source extension.";
          this.isMSESupported = !!window.MediaSource, this.mediaSource = new MediaSource(), this.url = URL.createObjectURL(this.mediaSource), this.node.src = this.url, this.mseEnded = false, this.mediaSource.addEventListener("sourceopen", this.onMSEOpen.bind(this)), this.mediaSource.addEventListener("sourceclose", this.onMSEClose.bind(this)), this.mediaSource.addEventListener("webkitsourceopen", this.onMSEOpen.bind(this)), this.mediaSource.addEventListener("webkitsourceclose", this.onMSEClose.bind(this));
        } }, { key: "endMSE", value: function() {
          if (!this.mseEnded)
            try {
              this.mseEnded = true, this.mediaSource.endOfStream();
            } catch (e2) {
              g("mediasource is not available to end");
            }
        } }, { key: "feed", value: function(e2) {
          var t2, n2, r3, i2 = false, s3 = { video: [], audio: [] };
          if (e2 && this.remuxController) {
            if (r3 = e2.duration ? parseInt(e2.duration) : 0, e2.video) {
              e2.video = S(this.remainingData, e2.video);
              var a2 = h(x.extractNALu(e2.video), 2);
              if (t2 = a2[0], n2 = a2[1], this.remainingData = n2 || new Uint8Array(), !(t2.length > 0))
                return g("Failed to extract any NAL units from video data:", n2), void ("function" == typeof this.options.onMissingVideoFrames && this.options.onMissingVideoFrames.call(null, e2));
              s3.video = this.getVideoFrames(t2, r3, e2.compositionTimeOffset), i2 = true;
            }
            if (e2.audio) {
              if (!((t2 = this.remuxController.aacParser.extractAAC(e2.audio)).length > 0))
                return g("Failed to extract audio data from:", e2.audio), void ("function" == typeof this.options.onMissingAudioFrames && this.options.onMissingAudioFrames.call(null, e2));
              s3.audio = this.getAudioFrames(t2, r3), i2 = true;
            }
            i2 ? this.remuxController.remux(s3) : g("Input object must have video and/or audio property. Make sure it is a valid typed array");
          }
        } }, { key: "getVideoFrames", value: function(e2, t2, n2) {
          var r3, i2 = this, s3 = [], a2 = [], o3 = 0, u2 = false, c2 = false;
          this.pendingUnits.units && (s3 = this.pendingUnits.units, c2 = this.pendingUnits.vcl, u2 = this.pendingUnits.keyFrame, this.pendingUnits = {});
          var f2, l2 = p(e2);
          try {
            for (l2.s(); !(f2 = l2.n()).done; ) {
              var h2 = f2.value, d2 = new b(h2);
              d2.type() !== b.IDR && d2.type() !== b.NDR || x.parseHeader(d2), s3.length && c2 && (d2.isfmb || !d2.isvcl) && (a2.push({ units: s3, keyFrame: u2 }), s3 = [], u2 = false, c2 = false), s3.push(d2), u2 = u2 || d2.isKeyframe(), c2 = c2 || d2.isvcl;
            }
          } catch (e3) {
            l2.e(e3);
          } finally {
            l2.f();
          }
          if (s3.length)
            if (t2)
              if (c2)
                a2.push({ units: s3, keyFrame: u2 });
              else {
                var y2 = a2.length - 1;
                y2 >= 0 && (a2[y2].units = a2[y2].units.concat(s3));
              }
            else
              this.pendingUnits = { units: s3, keyFrame: u2, vcl: c2 };
          return r3 = t2 ? t2 / a2.length | 0 : this.frameDuration, o3 = t2 ? t2 - r3 * a2.length : 0, a2.map(function(e3) {
            e3.duration = r3, e3.compositionTimeOffset = n2, o3 > 0 && (e3.duration++, o3--), i2.kfCounter++, e3.keyFrame && i2.options.clearBuffer && i2.kfPosition.push(i2.kfCounter * r3 / 1e3);
          }), k("jmuxer: No. of frames of the last chunk: ".concat(a2.length)), a2;
        } }, { key: "getAudioFrames", value: function(e2, t2) {
          var n2, r3, i2 = [], s3 = 0, a2 = p(e2);
          try {
            for (a2.s(); !(r3 = a2.n()).done; ) {
              var o3 = r3.value;
              i2.push({ units: o3 });
            }
          } catch (e3) {
            a2.e(e3);
          } finally {
            a2.f();
          }
          return n2 = t2 ? t2 / i2.length | 0 : this.frameDuration, s3 = t2 ? t2 - n2 * i2.length : 0, i2.map(function(e3) {
            e3.duration = n2, s3 > 0 && (e3.duration++, s3--);
          }), i2;
        } }, { key: "destroy", value: function() {
          if (this.stopInterval(), this.stream && (this.remuxController.flush(), this.stream.push(null), this.stream = null), this.remuxController && (this.remuxController.destroy(), this.remuxController = null), this.bufferControllers) {
            for (var e2 in this.bufferControllers)
              this.bufferControllers[e2].destroy();
            this.bufferControllers = null, this.endMSE();
          }
          this.node = false, this.mseReady = false, this.videoStarted = false, this.mediaSource = null;
        } }, { key: "reset", value: function() {
          if (this.stopInterval(), this.isReset = true, this.node.pause(), this.remuxController && this.remuxController.reset(), this.bufferControllers) {
            for (var e2 in this.bufferControllers)
              this.bufferControllers[e2].destroy();
            this.bufferControllers = null, this.endMSE();
          }
          this.initData(), "browser" == this.env && this.initBrowser(), k("JMuxer was reset");
        } }, { key: "createBuffer", value: function() {
          if (this.mseReady && this.remuxController && this.remuxController.isReady() && !this.bufferControllers)
            for (var e2 in this.bufferControllers = {}, this.remuxController.tracks) {
              var t2 = this.remuxController.tracks[e2];
              if (!o2.isSupported("".concat(e2, '/mp4; codecs="').concat(t2.mp4track.codec, '"')))
                return g("Browser does not support codec"), false;
              var n2 = this.mediaSource.addSourceBuffer("".concat(e2, '/mp4; codecs="').concat(t2.mp4track.codec, '"'));
              this.bufferControllers[e2] = new L(n2, e2), this.bufferControllers[e2].on("error", this.onBufferError.bind(this));
            }
        } }, { key: "startInterval", value: function() {
          var e2 = this;
          this.interval = setInterval(function() {
            e2.options.flushingTime ? e2.applyAndClearBuffer() : e2.bufferControllers && e2.cancelDelay();
          }, this.options.flushingTime || 1e3);
        } }, { key: "stopInterval", value: function() {
          this.interval && clearInterval(this.interval);
        } }, { key: "cancelDelay", value: function() {
          if (this.node.buffered && this.node.buffered.length > 0 && !this.node.seeking) {
            var e2 = this.node.buffered.end(0);
            e2 - this.node.currentTime > this.options.maxDelay / 1e3 && (console.log("delay"), this.node.currentTime = e2 - 1e-3);
          }
        } }, { key: "releaseBuffer", value: function() {
          for (var e2 in this.bufferControllers)
            this.bufferControllers[e2].doAppend();
        } }, { key: "applyAndClearBuffer", value: function() {
          this.bufferControllers && (this.releaseBuffer(), this.clearBuffer());
        } }, { key: "getSafeClearOffsetOfBuffer", value: function(e2) {
          for (var t2, n2 = "audio" === this.options.mode && e2 || 0, r3 = 0; r3 < this.kfPosition.length && !(this.kfPosition[r3] >= e2); r3++)
            t2 = this.kfPosition[r3];
          return t2 && (this.kfPosition = this.kfPosition.filter(function(e3) {
            return e3 < t2 && (n2 = e3), e3 >= t2;
          })), n2;
        } }, { key: "clearBuffer", value: function() {
          if (this.options.clearBuffer && Date.now() - this.lastCleaningTime > 1e4) {
            for (var e2 in this.bufferControllers) {
              var t2 = this.getSafeClearOffsetOfBuffer(this.node.currentTime);
              this.bufferControllers[e2].initCleanup(t2);
            }
            this.lastCleaningTime = Date.now();
          }
        } }, { key: "onBuffer", value: function(e2) {
          this.options.readFpsFromTrack && void 0 !== e2.fps && this.options.fps != e2.fps && (this.options.fps = e2.fps, this.frameDuration = Math.ceil(1e3 / e2.fps), k("JMuxer changed FPS to ".concat(e2.fps, " from track data"))), "browser" == this.env ? this.bufferControllers && this.bufferControllers[e2.type] && this.bufferControllers[e2.type].feed(e2.payload) : this.stream && this.stream.push(e2.payload), 0 === this.options.flushingTime && this.applyAndClearBuffer();
        } }, { key: "onMSEOpen", value: function() {
          this.mseReady = true, URL.revokeObjectURL(this.url), "function" == typeof this.options.onReady && this.options.onReady.call(null, this.isReset);
        } }, { key: "onMSEClose", value: function() {
          this.mseReady = false, this.videoStarted = false;
        } }, { key: "onBufferError", value: function(e2) {
          if ("QuotaExceeded" == e2.name)
            return k("JMuxer cleaning ".concat(e2.type, " buffer due to QuotaExceeded error")), void this.bufferControllers[e2.type].initCleanup(this.node.currentTime);
          "InvalidStateError" == e2.name ? (k("JMuxer is reseting due to InvalidStateError"), this.reset()) : this.endMSE(), "function" == typeof this.options.onError && this.options.onError.call(null, e2);
        } }], [{ key: "isSupported", value: function(e2) {
          return window.MediaSource && window.MediaSource.isTypeSupported(e2);
        } }]), o2;
      }(U);
    });
  }
});
export default require_jmuxer_min();
//# sourceMappingURL=jmuxer.js.map
